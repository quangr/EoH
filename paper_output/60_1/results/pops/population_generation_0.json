[
     {
          "algorithm": "Select an unplaced item, iterate through orientations to find a valid placement in an existing or new truck, prioritizing placements that minimize remaining space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select an unplaced item, iterate through orientations to find a valid placement in an existing or new truck, prioritizing placements that minimize remaining space.}\n    def _select_item_to_place(self, unplaced_items):\n        eligible_items = [i for i, item in enumerate(unplaced_items) if item['quantity'] > 0]\n        if not eligible_items:\n            return None\n        return max(eligible_items, key=lambda i: unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height'])\n\n    def _find_valid_position(self, item_type, orientation, container_dims, occupied_volumes):\n        item_dims = self._get_orientations(item_type)[orientation][1]\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        \n        if not occupied_volumes:\n            return 0.0, 0.0, 0.0\n            \n        occupied_volumes.sort(key=lambda x: (x['z'], x['y'], x['x']))\n\n        positions_to_check = []\n        positions_to_check.append((0.0, 0.0, 0.0))        \n        for placed_item in occupied_volumes:\n            positions_to_check.append((placed_item['x'] + placed_item['length'], placed_item['y'], placed_item['z']))\n            positions_to_check.append((placed_item['x'], placed_item['y'] + placed_item['width'], placed_item['z']))\n            positions_to_check.append((placed_item['x'], placed_item['y'], placed_item['z'] + placed_item['height']))\n\n        for x, y, z in positions_to_check:\n            if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                return x, y, z\n            \n        return None\n\n    def _evaluate_placement(self, item_dims, container_dims, x, y, z, occupied_volumes):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        remaining_space = (cl - (x + il)) * (cw - (y + iw)) * (ch - (z + ih))\n        return remaining_space\n    \n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item_to_place(unplaced_items)\n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n\n        best_truck_index = -1\n        best_orientation = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_remaining_space = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            occupied_volumes = truck['occupied_volumes']\n            for orientation in range(6):\n                item_type = unplaced_items[item_index]\n                position = self._find_valid_position(item_type, orientation, truck_type, occupied_volumes)\n                if position:\n                    x, y, z = position\n                    item_dims = self._get_orientations(item_type)[orientation][1]\n                    remaining_space = self._evaluate_placement(item_dims, truck_type, x, y, z, occupied_volumes)\n                    if remaining_space < best_remaining_space:\n                        best_truck_index = truck_index\n                        best_orientation = orientation\n                        best_x, best_y, best_z = x, y, z\n                        best_remaining_space = remaining_space\n\n        if best_truck_index == -1:\n            best_truck_index = -1\n            best_orientation = -1\n            for orientation in range(6):\n                item_type = unplaced_items[item_index]\n                item_dims = self._get_orientations(item_type)[orientation][1]\n                if self._is_valid_placement((0.0, 0.0, 0.0), item_dims, truck_type, []):\n                        best_orientation = orientation\n                        break\n\n            if best_orientation != -1:\n                best_x, best_y, best_z = 0.0, 0.0, 0.0\n            else:\n                return -1, -1, 0, 0, 0, 0\n\n        return best_truck_index, item_index, best_x, best_y, best_z, best_orientation",
          "objective": 24.55,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects the most constrained item, iterates through truck and orientation, and places according to best fit with minimal waste.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the most constrained item, iterates through truck and orientation, and places according to best fit with minimal waste.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index = -1\n        item_index = -1\n        x, y, z = 0.0, 0.0, 0.0\n        orientation = 0\n\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n        best_placement = None\n        \n        for ti in range(len(trucks_in_use) + 1):\n            if ti < len(trucks_in_use):\n                truck = trucks_in_use[ti]\n            else:\n                truck = {'occupied_volumes': []}\n            \n            for orient in range(6):\n                item_dims = self._get_orientations(unplaced_items[item_index])[orient][1]\n                placement = self._find_best_position(unplaced_items[item_index], item_dims, truck['occupied_volumes'], truck_type)\n\n                if placement:\n                    if best_placement is None or placement['waste'] < best_placement['waste']:\n                        best_placement = {\n                            'truck_index': ti,\n                            'item_index': item_index,\n                            'x': placement['x'],\n                            'y': placement['y'],\n                            'z': placement['z'],\n                            'orientation': orient,\n                            'waste': placement['waste']\n                        }\n\n        if best_placement:\n            truck_index = best_placement['truck_index']\n            item_index = best_placement['item_index']\n            x = best_placement['x']\n            y = best_placement['y']\n            z = best_placement['z']\n            orientation = best_placement['orientation']\n        \n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_position(self, item, item_dims, occupied_volumes, container_dims):\n        best_position = None\n        min_waste = float('inf')\n\n        free_spots = [(0.0, 0.0, 0.0)]\n        for placed_item in occupied_volumes:\n            x, y, z = placed_item['x'], placed_item['y'], placed_item['z']\n            l, w, h = placed_item['length'], placed_item['width'], placed_item['height']\n            free_spots.extend([(x + l, y, z), (x, y + w, z), (x, y, z + h)])\n\n        for pos in free_spots:\n            if self._is_valid_placement(pos, item_dims, container_dims, occupied_volumes):\n                x, y, z = pos\n                l, w, h = item_dims\n                waste = self._calculate_waste(x, y, z, l, w, h, container_dims, occupied_volumes)\n\n                if waste < min_waste:\n                    min_waste = waste\n                    best_position = {'x': x, 'y': y, 'z': z, 'waste': waste}\n\n        return best_position\n    \n    def _calculate_waste(self, x, y, z, l, w, h, container_dims, occupied_volumes):\n        total_waste = float('inf')\n        \n        if self._is_valid_placement((x,y,z), (l,w,h), container_dims, occupied_volumes):\n            total_waste = (container_dims[0] - (x + l)) + (container_dims[1] - (y + w)) + (container_dims[2] - (z + h))\n        \n        return total_waste\nclass AlgorithmFIX1(Algorithm):\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index = -1\n        item_index = -1\n        x, y, z = 0.0, 0.0, 0.0\n        orientation = 0\n\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n        best_placement = None\n\n        for ti in range(len(trucks_in_use) + 1):\n            if ti < len(trucks_in_use):\n                truck = trucks_in_use[ti]\n            else:\n                truck = {'occupied_volumes': []}\n\n            for orient in range(6):\n                item_dims = self._get_orientations(unplaced_items[item_index])[orient][1]\n                placement = self._find_best_position(unplaced_items[item_index], item_dims, truck['occupied_volumes'], truck_type)\n\n                if placement:\n                    if best_placement is None or placement['waste'] < best_placement['waste']:\n                        best_placement = {\n                            'truck_index': ti,\n                            'item_index': item_index,\n                            'x': placement['x'],\n                            'y': placement['y'],\n                            'z': placement['z'],\n                            'orientation': orient,\n                            'waste': placement['waste']\n                        }\n\n        if best_placement:\n            truck_index = best_placement['truck_index']\n            item_index = best_placement['item_index']\n            x = best_placement['x']\n            y = best_placement['y']\n            z = best_placement['z']\n            orientation = best_placement['orientation']\n        else:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n        return truck_index, item_index, x, y, z, orientation\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index = -1\n        item_index = -1\n        x, y, z = 0.0, 0.0, 0.0\n        orientation = 0\n\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n        best_placement = None\n\n        for ti in range(len(trucks_in_use) + 1):\n            if ti < len(trucks_in_use):\n                truck = trucks_in_use[ti]\n            else:\n                truck = {'occupied_volumes': []}\n\n            for orient in range(6):\n                item_dims = self._get_orientations(unplaced_items[item_index])[orient][1]\n                placement = self._find_best_position(unplaced_items[item_index], item_dims, truck['occupied_volumes'], truck_type)\n\n                if placement:\n                    if best_placement is None or placement['waste'] < best_placement['waste']:\n                        best_placement = {\n                            'truck_index': ti,\n                            'item_index': item_index,\n                            'x': placement['x'],\n                            'y': placement['y'],\n                            'z': placement['z'],\n                            'orientation': orient,\n                            'waste': placement['waste']\n                        }\n\n        if best_placement:\n            truck_index = best_placement['truck_index']\n            item_index = best_placement['item_index']\n            x = best_placement['x']\n            y = best_placement['y']\n            z = best_placement['z']\n            orientation = best_placement['orientation']\n\n            if best_placement['truck_index'] == len(trucks_in_use):\n                truck_index = -1\n        else:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n        return truck_index, item_index, x, y, z, orientation",
          "objective": 24.75,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     },
     {
          "algorithm": "Selects the item with the most remaining quantity, iterates through truck and orientations, finds the best placement based on a volume utilization heuristic, and places the item; if no placement is found, a new truck is used.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item with the most remaining quantity, iterates through truck and orientations, finds the best placement based on a volume utilization heuristic, and places the item; if no placement is found, a new truck is used.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        best_truck_index, best_x, best_y, best_z, best_orientation, best_volume_utilization = -1, None, None, None, None, -1\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            x, y, z, orientation, volume_utilization = self._find_best_placement_in_truck(unplaced_items[item_index], truck, truck_type)\n            if x is not None and volume_utilization > best_volume_utilization:\n                best_truck_index, best_x, best_y, best_z, best_orientation, best_volume_utilization = truck_index, x, y, z, orientation, volume_utilization\n\n        if best_truck_index == -1:\n            best_x, best_y, best_z, best_orientation, best_volume_utilization = self._find_best_placement_in_new_truck(unplaced_items[item_index], truck_type)\n            if best_x is None:\n                return None, None, None, None, None, None\n\n        return best_truck_index, item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index, max_quantity = None, -1\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > max_quantity:\n                best_item_index, max_quantity = i, item['quantity']\n        return best_item_index\n\n    def _find_best_placement_in_truck(self, item_type, truck, truck_type):\n        best_x, best_y, best_z, best_orientation, best_volume_utilization = None, None, None, None, -1\n        occupied_volumes = truck['occupied_volumes']\n        for orientation, dims in self._get_orientations(item_type):\n            l, w, h = dims\n            for x in np.arange(0, truck_type[0] - l + self.epsilon, min(l,w,h)/2):\n                for y in np.arange(0, truck_type[1] - w + self.epsilon, min(l,w,h)/2):\n                    for z in np.arange(0, truck_type[2] - h + self.epsilon, min(l,w,h)/2):\n                        x, y, z = round(x, 6), round(y, 6), round(z, 6)\n                        if self._is_valid_placement((x, y, z), (l, w, h), truck_type, occupied_volumes):\n                            volume_utilization = l * w * h / (truck_type[0] * truck_type[1] * truck_type[2])\n                            if volume_utilization > best_volume_utilization:\n                                best_x, best_y, best_z, best_orientation, best_volume_utilization = x, y, z, orientation, volume_utilization\n        return best_x, best_y, best_z, best_orientation, best_volume_utilization\n\n    def _find_best_placement_in_new_truck(self, item_type, truck_type):\n        best_x, best_y, best_z, best_orientation, best_volume_utilization = None, None, None, None, -1\n        for orientation, dims in self._get_orientations(item_type):\n            l, w, h = dims\n            x, y, z = 0, 0, 0\n            if self._is_valid_placement((x, y, z), (l, w, h), truck_type, []):\n                volume_utilization = l * w * h / (truck_type[0] * truck_type[1] * truck_type[2])\n                best_x, best_y, best_z, best_orientation, best_volume_utilization = x, y, z, orientation, volume_utilization\n                break\n        return best_x, best_y, best_z, best_orientation, best_volume_utilization\nclass AlgorithmFIX1(Algorithm):\n    def _find_best_placement_in_truck(self, item_type, truck, truck_type):\n        best_x, best_y, best_z, best_orientation, best_volume_utilization = None, None, None, None, -1\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n        for orientation, dims in orientations:\n            l, w, h = dims\n            step_size = min(l, w, h) / 2 if min(l, w, h) > 0 else 1\n            if step_size==0:\n                step_size=1\n            max_x = truck_type[0] - l + self.epsilon\n            max_y = truck_type[1] - w + self.epsilon\n            max_z = truck_type[2] - h + self.epsilon\n            \n            x_coords = np.arange(0, max_x, step_size)\n            y_coords = np.arange(0, max_y, step_size)\n            z_coords = np.arange(0, max_z, step_size)\n\n            for x in x_coords:\n                for y in y_coords:\n                    for z in z_coords:\n                        x, y, z = round(x, 6), round(y, 6), round(z, 6)\n                        if self._is_valid_placement((x, y, z), (l, w, h), truck_type, occupied_volumes):\n                            volume_utilization = l * w * h / (truck_type[0] * truck_type[1] * truck_type[2]) if (truck_type[0] * truck_type[1] * truck_type[2]) > 0 else 0\n                            if volume_utilization > best_volume_utilization:\n                                best_x, best_y, best_z, best_orientation, best_volume_utilization = x, y, z, orientation, volume_utilization\n        return best_x, best_y, best_z, best_orientation, best_volume_utilization\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_best_placement_in_truck(self, item_type, truck, truck_type):\n        best_x, best_y, best_z, best_orientation, best_volume_utilization = None, None, None, None, -1\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n        for orientation, dims in orientations:\n            l, w, h = dims\n            step_size = min(l, w, h) / 2 if min(l, w, h) > 0 else 1\n            if step_size == 0:\n                step_size = 1\n            \n            num_x_steps = 5 if (truck_type[0] - l) / step_size > 5 else int((truck_type[0] - l) / step_size) +1\n            num_y_steps = 5 if (truck_type[1] - w) / step_size > 5 else int((truck_type[1] - w) / step_size) +1\n            num_z_steps = 5 if (truck_type[2] - h) / step_size > 5 else int((truck_type[2] - h) / step_size) +1\n            \n            x_coords = np.linspace(0, truck_type[0] - l, num_x_steps) if num_x_steps > 1 else [0]\n            y_coords = np.linspace(0, truck_type[1] - w, num_y_steps) if num_y_steps > 1 else [0]\n            z_coords = np.linspace(0, truck_type[2] - h, num_z_steps) if num_z_steps > 1 else [0]\n            \n            for x in x_coords:\n                for y in y_coords:\n                    for z in z_coords:\n                        x, y, z = round(x, 6), round(y, 6), round(z, 6)\n                        if self._is_valid_placement((x, y, z), (l, w, h), truck_type, occupied_volumes):\n                            volume_utilization = l * w * h / (truck_type[0] * truck_type[1] * truck_type[2]) if (truck_type[0] * truck_type[1] * truck_type[2]) > 0 else 0\n                            if volume_utilization > best_volume_utilization:\n                                best_x, best_y, best_z, best_orientation, best_volume_utilization = x, y, z, orientation, volume_utilization\n        return best_x, best_y, best_z, best_orientation, best_volume_utilization\nclass AlgorithmFIX3(AlgorithmFIX2):\n    def _find_best_placement_in_truck(self, item_type, truck, truck_type):\n        best_x, best_y, best_z, best_orientation, best_volume_utilization = None, None, None, None, -1\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n        \n        max_items_to_test = 20\n\n        for orientation, dims in orientations:\n            l, w, h = dims\n            \n            potential_positions = []\n            \n            # Heuristic: Prioritize corners and edges of the container\n            if not occupied_volumes:\n                potential_positions.append((0, 0, 0))\n            else:\n                for placed_item in occupied_volumes:\n                    # Potential positions based on existing items\n                    potential_positions.append((placed_item['x'] + placed_item['length'], placed_item['y'], placed_item['z']))\n                    potential_positions.append((placed_item['x'], placed_item['y'] + placed_item['width'], placed_item['z']))\n                    potential_positions.append((placed_item['x'], placed_item['y'], placed_item['z'] + placed_item['height']))\n            \n            # Filter out invalid positions and deduplicate\n            valid_positions = []\n            seen_positions = set()\n            for x, y, z in potential_positions:\n                if (x,y,z) not in seen_positions and self._is_within_container_bounds((x, y, z), (l,w,h), truck_type):\n                    valid_positions.append((x, y, z))\n                    seen_positions.add((x,y,z))\n\n            \n            num_positions_tested = 0\n            \n            for x, y, z in valid_positions:\n                if num_positions_tested >= max_items_to_test:\n                   break\n                x, y, z = round(x, 6), round(y, 6), round(z, 6)\n                if self._is_valid_placement((x, y, z), (l, w, h), truck_type, occupied_volumes):\n                    volume_utilization = l * w * h / (truck_type[0] * truck_type[1] * truck_type[2]) if (truck_type[0] * truck_type[1] * truck_type[2]) > 0 else 0\n                    if volume_utilization > best_volume_utilization:\n                        best_x, best_y, best_z, best_orientation, best_volume_utilization = x, y, z, orientation, volume_utilization\n                num_positions_tested +=1\n        return best_x, best_y, best_z, best_orientation, best_volume_utilization",
          "objective": 25.05,
          "other_inf": null,
          "class_name": "AlgorithmFIX3"
     },
     {
          "algorithm": "Selects items based on a volume-based heuristic, then finds the best orientation and position sequentially using bottom-left fill, and creates a new truck if no suitable placement is found.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects items based on a volume-based heuristic, then finds the best orientation and position sequentially using bottom-left fill, and creates a new truck if no suitable placement is found.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def _select_item(self, unplaced_items):\n        \"\"\"Selects an item to place based on a volume heuristic.\"\"\"\n        if not unplaced_items:\n            return None\n        \n        item_volumes = [item['length'] * item['width'] * item['height'] * item['quantity'] for item in unplaced_items]\n        total_volume = sum(item_volumes)\n        probabilities = [volume / total_volume for volume in item_volumes]\n        \n        return np.random.choice(len(unplaced_items), p=probabilities)\n\n    def _find_valid_position(self, item_dims, container_dims, occupied_volumes):\n        \"\"\"Finds a valid bottom-left position for an item in the container.\"\"\"\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n\n        # Find potential positions (bottom-left corner principle). Start with (0,0,0) and then add some potential positions.\n        potential_positions = [(0.0, 0.0, 0.0)]\n\n        for placed_item in occupied_volumes:\n            potential_positions.append((placed_item['x'] + placed_item['length'], placed_item['y'], placed_item['z']))\n            potential_positions.append((placed_item['x'], placed_item['y'] + placed_item['width'], placed_item['z']))\n            potential_positions.append((placed_item['x'], placed_item['y'], placed_item['z'] + placed_item['height']))\n\n        # Filter only unique positions to avoid redundant work\n        unique_positions = []\n        [unique_positions.append(pos) for pos in potential_positions if pos not in unique_positions]\n\n        for x, y, z in unique_positions:\n            position = (x, y, z)\n            if self._is_valid_placement(position, item_dims, container_dims, occupied_volumes):\n                return position\n            \n        return None\n\n    def _evaluate_placement(self, item_index, orientation, position):\n        \"\"\"Evaluates a placement (currently a placeholder).\"\"\"\n        return 0  # Can be improved with placement scoring\n\n    def _find_best_truck(self, unplaced_items, trucks_in_use, truck_type, item_index):\n            \n        best_truck_index = -1\n        best_orientation = -1\n        best_position = None\n        best_evaluation = float('inf')\n        \n        item_type = unplaced_items[item_index]\n\n        #Iterate through orientations\n        for orientation, item_dims in self._get_orientations(item_type):\n\n            #Iterate through trucks to find the best placement.\n            for truck_index, truck in enumerate(trucks_in_use):\n                position = self._find_valid_position(item_dims, truck_type, truck['occupied_volumes'])\n                \n                if position:\n                    evaluation = self._evaluate_placement(item_index, orientation, position)\n                    \n                    if evaluation < best_evaluation:\n                        best_evaluation = evaluation\n                        best_truck_index = truck_index\n                        best_orientation = orientation\n                        best_position = position\n        \n        return best_truck_index, best_orientation, best_position\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        \"\"\"Places an item into a container, considering orientations and positions.\"\"\"\n        item_index = self._select_item(unplaced_items)\n        \n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n\n        best_truck_index, best_orientation, best_position = self._find_best_truck(unplaced_items, trucks_in_use, truck_type, item_index)\n\n        if best_truck_index == -1:\n            truck_index = -1\n            item_type = unplaced_items[item_index]\n\n            for orientation, item_dims in self._get_orientations(item_type):\n                if self._is_valid_placement((0.0, 0.0, 0.0), item_dims, truck_type, []):\n                    x, y, z = (0.0, 0.0, 0.0)\n                    return truck_index, item_index, x, y, z, orientation\n            return -1, -1, 0, 0, 0, 0  # should be unreachable\n\n        else:\n            x, y, z = best_position\n            truck_index = best_truck_index\n            orientation = best_orientation\n        \n        return truck_index, item_index, x, y, z, orientation",
          "objective": 25.1,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "The algorithm uses a best-fit heuristic, prioritizing items with lower remaining quantity and placing them in the most suitable orientation in an existing or new container based on maximizing space utilization.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {The algorithm uses a best-fit heuristic, prioritizing items with lower remaining quantity and placing them in the most suitable orientation in an existing or new container based on maximizing space utilization.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(item_index, unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        min_quantity = float('inf')\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                if item['quantity'] < min_quantity:\n                    min_quantity = item['quantity']\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, item_index, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        max_space_utilization = -1\n\n        for truck_index in range(-1, len(trucks_in_use)):\n            if truck_index == -1:\n                x, y, z, orientation, space_utilization = self._try_place_in_new_truck(item_index, unplaced_items, truck_type)\n                if space_utilization > max_space_utilization:\n                    best_truck_index = -1\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n                    max_space_utilization = space_utilization\n            else:\n                x, y, z, orientation, space_utilization = self._try_place_in_existing_truck(item_index, unplaced_items, trucks_in_use[truck_index], truck_type)\n                if space_utilization > max_space_utilization:\n                    best_truck_index = truck_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n                    max_space_utilization = space_utilization\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _try_place_in_new_truck(self, item_index, unplaced_items, truck_type):\n        item_type = unplaced_items[item_index]\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        max_space_utilization = -1\n\n        for orientation, dims in self._get_orientations(item_type):\n            if self._is_valid_placement((0, 0, 0), dims, truck_type, []):\n                space_utilization = (dims[0] * dims[1] * dims[2]) / (truck_type[0] * truck_type[1] * truck_type[2])\n                if space_utilization > max_space_utilization:\n                    max_space_utilization = space_utilization\n                    best_x = 0\n                    best_y = 0\n                    best_z = 0\n                    best_orientation = orientation\n\n        return best_x, best_y, best_z, best_orientation, max_space_utilization\n\n    def _try_place_in_existing_truck(self, item_index, unplaced_items, truck, truck_type):\n        item_type = unplaced_items[item_index]\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        max_space_utilization = -1\n        occupied_volumes = truck['occupied_volumes']\n\n        for orientation, dims in self._get_orientations(item_type):\n            for x in np.arange(0, truck_type[0], 1.0):\n                for y in np.arange(0, truck_type[1], 1.0):\n                    for z in np.arange(0, truck_type[2], 1.0):\n                        if self._is_valid_placement((x, y, z), dims, truck_type, occupied_volumes):\n                            space_utilization = (dims[0] * dims[1] * dims[2]) / (truck_type[0] * truck_type[1] * truck_type[2])\n                            if space_utilization > max_space_utilization:\n                                max_space_utilization = space_utilization\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation\n        return best_x, best_y, best_z, best_orientation, max_space_utilization\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _try_place_in_existing_truck(self, item_index, unplaced_items, truck, truck_type):\n        item_type = unplaced_items[item_index]\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        max_space_utilization = -1\n        occupied_volumes = truck['occupied_volumes']\n\n        for orientation, dims in self._get_orientations(item_type):\n            # Iterate through possible positions with a coarser step to reduce computation\n            step_size = max(1, min(dims) / 2)\n            for x in np.arange(0, truck_type[0] - dims[0] + self.epsilon, step_size):\n                for y in np.arange(0, truck_type[1] - dims[1] + self.epsilon, step_size):\n                    for z in np.arange(0, truck_type[2] - dims[2] + self.epsilon, step_size):\n                        x = round(x, 3)\n                        y = round(y, 3)\n                        z = round(z, 3)\n\n                        if self._is_valid_placement((x, y, z), dims, truck_type, occupied_volumes):\n                            space_utilization = (dims[0] * dims[1] * dims[2]) / (truck_type[0] * truck_type[1] * truck_type[2])\n                            if space_utilization > max_space_utilization:\n                                max_space_utilization = space_utilization\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation\n        return best_x, best_y, best_z, best_orientation, max_space_utilization\nimport numpy as np\n\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_best_placement(self, item_index, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        max_space_utilization = -1\n\n        # Always try to place in an existing truck first\n        for truck_index in range(len(trucks_in_use)):\n            x, y, z, orientation, space_utilization = self._try_place_in_existing_truck(item_index, unplaced_items, trucks_in_use[truck_index], truck_type)\n            if space_utilization > max_space_utilization:\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                max_space_utilization = space_utilization\n\n        # If no placement was found in existing containers, try a new one\n        if best_truck_index == -1:\n            x, y, z, orientation, space_utilization = self._try_place_in_new_truck(item_index, unplaced_items, truck_type)\n            if space_utilization > max_space_utilization:\n                best_truck_index = -1\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                max_space_utilization = space_utilization\n        \n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\nimport numpy as np\n\nclass AlgorithmFIX3(AlgorithmFIX2):\n    def _try_place_in_existing_truck(self, item_index, unplaced_items, truck, truck_type):\n        item_type = unplaced_items[item_index]\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        max_space_utilization = -1\n        occupied_volumes = truck['occupied_volumes']\n\n        for orientation, dims in self._get_orientations(item_type):\n            step_size = max(1, min(dims) / 2)\n            # Reduce the search space: only try placing items at corners of existing items\n            potential_positions = []\n            if not occupied_volumes:\n                potential_positions.append((0, 0, 0))\n            else:\n                for item in occupied_volumes:\n                    x, y, z = item['x'], item['y'], item['z']\n                    l, w, h = item['length'], item['width'], item['height']\n\n                    potential_positions.extend([\n                        (x + l, y, z), (x, y + w, z), (x, y, z + h),\n                        (x + l, y + w, z), (x + l, y, z + h), (x, y + w, z + h),\n                        (x + l, y + w, z + h)\n                    ])\n                # Add origin as a potential position\n                potential_positions.append((0, 0, 0))\n            \n            for x, y, z in potential_positions:\n                x = round(x, 3)\n                y = round(y, 3)\n                z = round(z, 3)\n                \n                if 0 <= x <= truck_type[0] - dims[0] and 0 <= y <= truck_type[1] - dims[1] and 0 <= z <= truck_type[2] - dims[2]:\n                    if self._is_valid_placement((x, y, z), dims, truck_type, occupied_volumes):\n                        space_utilization = (dims[0] * dims[1] * dims[2]) / (truck_type[0] * truck_type[1] * truck_type[2])\n                        if space_utilization > max_space_utilization:\n                            max_space_utilization = space_utilization\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            best_orientation = orientation\n\n        return best_x, best_y, best_z, best_orientation, max_space_utilization",
          "objective": 26.45,
          "other_inf": null,
          "class_name": "AlgorithmFIX3"
     }
]