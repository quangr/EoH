[
     {
          "algorithm": "Prioritizes filling containers by placing items based on a space-filling heuristic, favoring orientations and positions that minimize wasted space within each layer.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Prioritizes filling containers by placing items based on a space-filling heuristic, favoring orientations and positions that minimize wasted space within each layer.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item_to_place(unplaced_items)\n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n\n        best_placement = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n\n        if best_placement:\n            return (best_placement['truck_index'], item_index, best_placement['x'],\n                    best_placement['y'], best_placement['z'], best_placement['orientation'])\n        else:\n            return -1, -1, 0, 0, 0, 0\n\n    def _select_item_to_place(self, unplaced_items):\n        eligible_items = [i for i, item in enumerate(unplaced_items) if item['quantity'] > 0]\n        if not eligible_items:\n            return None\n        return max(eligible_items, key=lambda i: unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height'])\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_placement = None\n        min_waste = float('inf')\n\n        for truck_index in range(len(trucks_in_use) + 1):\n            truck = trucks_in_use[truck_index] if truck_index < len(trucks_in_use) else {'occupied_volumes': []}\n\n            for orientation in range(6):\n                item_type = unplaced_items[item_index]\n                item_dims = self._get_orientations(item_type)[orientation][1]\n                position = self._find_valid_position(item_type, orientation, truck_type, truck['occupied_volumes'])\n\n                if position:\n                    x, y, z = position\n                    waste = self._calculate_waste(x, y, z, item_dims, truck_type, truck['occupied_volumes'])\n\n                    if waste < min_waste:\n                        min_waste = waste\n                        best_placement = {\n                            'truck_index': truck_index,\n                            'x': x,\n                            'y': y,\n                            'z': z,\n                            'orientation': orientation\n                        }\n        return best_placement\n\n    def _find_valid_position(self, item_type, orientation, container_dims, occupied_volumes):\n        item_dims = self._get_orientations(item_type)[orientation][1]\n        cl, cw, ch = container_dims\n\n        potential_positions = self._generate_potential_positions(occupied_volumes)\n\n        for x, y, z in potential_positions:\n            if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                return x, y, z\n        return None\n\n    def _generate_potential_positions(self, occupied_volumes):\n        positions = [(0.0, 0.0, 0.0)]\n        for item in occupied_volumes:\n            x, y, z = item['x'], item['y'], item['z']\n            l, w, h = item['length'], item['width'], item['height']\n            positions.extend([(x + l, y, z), (x, y + w, z), (x, y, z + h)])\n        return positions\n\n    def _calculate_waste(self, x, y, z, item_dims, container_dims, occupied_volumes):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        total_waste = (cl - (x + il)) * (cw - (y + iw)) * (ch - (z + ih))\n        return total_waste\nclass AlgorithmFIX1(Algorithm):\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item_to_place(unplaced_items)\n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n\n        best_placement = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n\n        if best_placement:\n            truck_index = best_placement['truck_index']\n            if truck_index == len(trucks_in_use):\n                truck_index = -1\n            return (truck_index, item_index, best_placement['x'],\n                    best_placement['y'], best_placement['z'], best_placement['orientation'])\n        else:\n            return -1, -1, 0, 0, 0, 0",
          "objective": 23.4,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     },
     {
          "algorithm": "Select the item with the largest volume and place it into the best truck or a new truck, trying all orientations and prioritizing the lowest z coordinate for stable packing.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select the item with the largest volume and place it into the best truck or a new truck, trying all orientations and prioritizing the lowest z coordinate for stable packing.}\n    def _select_item_to_place(self, unplaced_items):\n        eligible_items = [i for i, item in enumerate(unplaced_items) if item['quantity'] > 0]\n        if not eligible_items:\n            return None\n        return max(eligible_items, key=lambda i: unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height'])\n    \n    def _find_valid_position_with_min_z(self, item_type, orientation, container_dims, occupied_volumes):\n        item_dims = self._get_orientations(item_type)[orientation][1]\n        \n        valid_positions = []\n        \n        x_step = min(item_dims[0], 1.0)\n        y_step = min(item_dims[1], 1.0)\n        z_step = min(item_dims[2], 1.0)\n\n        for z in np.arange(0.0, container_dims[2], z_step):\n            for y in np.arange(0.0, container_dims[1], y_step):\n                for x in np.arange(0.0, container_dims[0], x_step):\n                  \n                    x, y, z = round(x, 6), round(y, 6), round(z, 6)\n\n                    if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                      \n                        valid_positions.append((x, y, z))\n        \n        if not valid_positions:\n            return None\n\n        return min(valid_positions, key=lambda pos: pos[2])\n        \n    def _evaluate_placement(self, item_dims, container_dims, x, y, z):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        return (cl - (x + il)) * (cw - (y + iw)) * (ch - (z + ih))\n    \n    def _find_best_truck(self, item_index, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_orientation = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_space_utilization = float('-inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            occupied_volumes = truck['occupied_volumes']\n            for orientation in range(6):\n                item_type = unplaced_items[item_index]\n                position = self._find_valid_position_with_min_z(item_type, orientation, truck_type, occupied_volumes)\n                if position:\n                    x, y, z = position\n                    item_dims = self._get_orientations(item_type)[orientation][1]\n                    space_utilization = (truck_type[0] * truck_type[1] * truck_type[2]) - self._evaluate_placement(item_dims, truck_type, x, y, z)\n                    if space_utilization > best_space_utilization:\n                        best_truck_index = truck_index\n                        best_orientation = orientation\n                        best_x, best_y, best_z = x, y, z\n                        best_space_utilization = space_utilization\n\n        return best_truck_index, best_orientation, best_x, best_y, best_z\n    \n    def _find_valid_position_new_truck(self, item_type, orientation, truck_type):\n        item_dims = self._get_orientations(item_type)[orientation][1]\n        if self._is_valid_placement((0.0, 0.0, 0.0), item_dims, truck_type, []):\n            return 0.0, 0.0, 0.0\n        return None\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item_to_place(unplaced_items)\n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n            \n        best_truck_index, best_orientation, best_x, best_y, best_z = self._find_best_truck(item_index, unplaced_items, trucks_in_use, truck_type)\n\n        if best_truck_index == -1:\n            best_orientation = -1\n            for orientation in range(6):\n                item_type = unplaced_items[item_index]\n                position = self._find_valid_position_new_truck(item_type, orientation, truck_type)\n                if position:\n                    best_orientation = orientation\n                    best_x, best_y, best_z = position\n                    break\n\n            if best_orientation == -1:\n                return -1, -1, 0, 0, 0, 0\n\n        return best_truck_index, item_index, best_x, best_y, best_z, best_orientation\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_valid_position_with_min_z(self, item_type, orientation, container_dims, occupied_volumes):\n        item_dims = self._get_orientations(item_type)[orientation][1]\n        \n        valid_positions = []\n        \n        x_step = item_dims[0]\n        y_step = item_dims[1]\n        z_step = item_dims[2]\n\n        x_positions = [0.0]\n        y_positions = [0.0]\n        z_positions = [0.0]\n\n        for item in occupied_volumes:\n            x_positions.append(item['x'] + item['length'])\n            y_positions.append(item['y'] + item['width'])\n            z_positions.append(item['z'] + item['height'])\n        \n        for z in sorted(list(set(z_positions))):\n            for y in sorted(list(set(y_positions))):\n                for x in sorted(list(set(x_positions))):\n\n                    x, y, z = round(x, 6), round(y, 6), round(z, 6)\n\n                    if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                        valid_positions.append((x, y, z))\n        \n        if not valid_positions:\n            return None\n\n        return min(valid_positions, key=lambda pos: pos[2])",
          "objective": 24.45,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     },
     {
          "algorithm": "Select an unplaced item, iterate through orientations to find a valid placement in an existing or new truck, prioritizing placements that minimize remaining space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select an unplaced item, iterate through orientations to find a valid placement in an existing or new truck, prioritizing placements that minimize remaining space.}\n    def _select_item_to_place(self, unplaced_items):\n        eligible_items = [i for i, item in enumerate(unplaced_items) if item['quantity'] > 0]\n        if not eligible_items:\n            return None\n        return max(eligible_items, key=lambda i: unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height'])\n\n    def _find_valid_position(self, item_type, orientation, container_dims, occupied_volumes):\n        item_dims = self._get_orientations(item_type)[orientation][1]\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        \n        if not occupied_volumes:\n            return 0.0, 0.0, 0.0\n            \n        occupied_volumes.sort(key=lambda x: (x['z'], x['y'], x['x']))\n\n        positions_to_check = []\n        positions_to_check.append((0.0, 0.0, 0.0))        \n        for placed_item in occupied_volumes:\n            positions_to_check.append((placed_item['x'] + placed_item['length'], placed_item['y'], placed_item['z']))\n            positions_to_check.append((placed_item['x'], placed_item['y'] + placed_item['width'], placed_item['z']))\n            positions_to_check.append((placed_item['x'], placed_item['y'], placed_item['z'] + placed_item['height']))\n\n        for x, y, z in positions_to_check:\n            if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                return x, y, z\n            \n        return None\n\n    def _evaluate_placement(self, item_dims, container_dims, x, y, z, occupied_volumes):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        remaining_space = (cl - (x + il)) * (cw - (y + iw)) * (ch - (z + ih))\n        return remaining_space\n    \n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item_to_place(unplaced_items)\n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n\n        best_truck_index = -1\n        best_orientation = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_remaining_space = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            occupied_volumes = truck['occupied_volumes']\n            for orientation in range(6):\n                item_type = unplaced_items[item_index]\n                position = self._find_valid_position(item_type, orientation, truck_type, occupied_volumes)\n                if position:\n                    x, y, z = position\n                    item_dims = self._get_orientations(item_type)[orientation][1]\n                    remaining_space = self._evaluate_placement(item_dims, truck_type, x, y, z, occupied_volumes)\n                    if remaining_space < best_remaining_space:\n                        best_truck_index = truck_index\n                        best_orientation = orientation\n                        best_x, best_y, best_z = x, y, z\n                        best_remaining_space = remaining_space\n\n        if best_truck_index == -1:\n            best_truck_index = -1\n            best_orientation = -1\n            for orientation in range(6):\n                item_type = unplaced_items[item_index]\n                item_dims = self._get_orientations(item_type)[orientation][1]\n                if self._is_valid_placement((0.0, 0.0, 0.0), item_dims, truck_type, []):\n                        best_orientation = orientation\n                        break\n\n            if best_orientation != -1:\n                best_x, best_y, best_z = 0.0, 0.0, 0.0\n            else:\n                return -1, -1, 0, 0, 0, 0\n\n        return best_truck_index, item_index, best_x, best_y, best_z, best_orientation",
          "objective": 24.55,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects the largest remaining item type, then attempts to place it using a corner-filling approach within existing trucks, prioritizing corners with the smallest combined coordinates; if no placement is possible, opens a new truck.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the largest remaining item type, then attempts to place it using a corner-filling approach within existing trucks, prioritizing corners with the smallest combined coordinates; if no placement is possible, opens a new truck.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def _select_item(self, unplaced_items):\n        eligible_items = [i for i, item in enumerate(unplaced_items) if item['quantity'] > 0]\n        if not eligible_items:\n            return None\n        return max(eligible_items, key=lambda i: unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height'])\n\n    def _find_corner_positions(self, container_dims, occupied_volumes):\n        corners = [(0.0, 0.0, 0.0)]\n        for item in occupied_volumes:\n            corners.append((item['x'] + item['length'], item['y'], item['z']))\n            corners.append((item['x'], item['y'] + item['width'], item['z']))\n            corners.append((item['x'], item['y'], item['z'] + item['height']))\n        \n        unique_corners = []\n        for corner in corners:\n            if corner not in unique_corners:\n                unique_corners.append(corner)\n\n        return unique_corners\n\n    def _evaluate_corner(self, x, y, z):\n        return x + y + z\n\n    def _find_best_position_and_orientation(self, item_type, container_dims, occupied_volumes):\n        best_position = None\n        best_orientation = -1\n        best_corner_evaluation = float('inf')\n        \n        corners = self._find_corner_positions(container_dims, occupied_volumes)\n\n        for orientation, item_dims in self._get_orientations(item_type):\n            for x, y, z in corners:\n                position = (x, y, z)\n                if self._is_valid_placement(position, item_dims, container_dims, occupied_volumes):\n                    corner_evaluation = self._evaluate_corner(x, y, z)\n                    if corner_evaluation < best_corner_evaluation:\n                        best_corner_evaluation = corner_evaluation\n                        best_position = position\n                        best_orientation = orientation\n\n        return best_position, best_orientation\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n\n        best_truck_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = -1\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            item_type = unplaced_items[item_index]\n            position, orientation = self._find_best_position_and_orientation(item_type, truck_type, truck['occupied_volumes'])\n            if position:\n                best_truck_index = truck_index\n                best_x, best_y, best_z = position\n                best_orientation = orientation\n                break\n\n        if best_truck_index == -1:\n            item_type = unplaced_items[item_index]\n            for orientation, item_dims in self._get_orientations(item_type):\n                if self._is_valid_placement((0.0, 0.0, 0.0), item_dims, truck_type, []):\n                    best_orientation = orientation\n                    break\n            if best_orientation != -1:\n                best_x, best_y, best_z = 0.0, 0.0, 0.0\n            else:\n                return -1, -1, 0, 0, 0, 0\n\n        return best_truck_index, item_index, best_x, best_y, best_z, best_orientation",
          "objective": 24.7,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects the most constrained item, iterates through truck and orientation, and places according to best fit with minimal waste.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the most constrained item, iterates through truck and orientation, and places according to best fit with minimal waste.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index = -1\n        item_index = -1\n        x, y, z = 0.0, 0.0, 0.0\n        orientation = 0\n\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n        best_placement = None\n        \n        for ti in range(len(trucks_in_use) + 1):\n            if ti < len(trucks_in_use):\n                truck = trucks_in_use[ti]\n            else:\n                truck = {'occupied_volumes': []}\n            \n            for orient in range(6):\n                item_dims = self._get_orientations(unplaced_items[item_index])[orient][1]\n                placement = self._find_best_position(unplaced_items[item_index], item_dims, truck['occupied_volumes'], truck_type)\n\n                if placement:\n                    if best_placement is None or placement['waste'] < best_placement['waste']:\n                        best_placement = {\n                            'truck_index': ti,\n                            'item_index': item_index,\n                            'x': placement['x'],\n                            'y': placement['y'],\n                            'z': placement['z'],\n                            'orientation': orient,\n                            'waste': placement['waste']\n                        }\n\n        if best_placement:\n            truck_index = best_placement['truck_index']\n            item_index = best_placement['item_index']\n            x = best_placement['x']\n            y = best_placement['y']\n            z = best_placement['z']\n            orientation = best_placement['orientation']\n        \n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_position(self, item, item_dims, occupied_volumes, container_dims):\n        best_position = None\n        min_waste = float('inf')\n\n        free_spots = [(0.0, 0.0, 0.0)]\n        for placed_item in occupied_volumes:\n            x, y, z = placed_item['x'], placed_item['y'], placed_item['z']\n            l, w, h = placed_item['length'], placed_item['width'], placed_item['height']\n            free_spots.extend([(x + l, y, z), (x, y + w, z), (x, y, z + h)])\n\n        for pos in free_spots:\n            if self._is_valid_placement(pos, item_dims, container_dims, occupied_volumes):\n                x, y, z = pos\n                l, w, h = item_dims\n                waste = self._calculate_waste(x, y, z, l, w, h, container_dims, occupied_volumes)\n\n                if waste < min_waste:\n                    min_waste = waste\n                    best_position = {'x': x, 'y': y, 'z': z, 'waste': waste}\n\n        return best_position\n    \n    def _calculate_waste(self, x, y, z, l, w, h, container_dims, occupied_volumes):\n        total_waste = float('inf')\n        \n        if self._is_valid_placement((x,y,z), (l,w,h), container_dims, occupied_volumes):\n            total_waste = (container_dims[0] - (x + l)) + (container_dims[1] - (y + w)) + (container_dims[2] - (z + h))\n        \n        return total_waste\nclass AlgorithmFIX1(Algorithm):\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index = -1\n        item_index = -1\n        x, y, z = 0.0, 0.0, 0.0\n        orientation = 0\n\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n        best_placement = None\n\n        for ti in range(len(trucks_in_use) + 1):\n            if ti < len(trucks_in_use):\n                truck = trucks_in_use[ti]\n            else:\n                truck = {'occupied_volumes': []}\n\n            for orient in range(6):\n                item_dims = self._get_orientations(unplaced_items[item_index])[orient][1]\n                placement = self._find_best_position(unplaced_items[item_index], item_dims, truck['occupied_volumes'], truck_type)\n\n                if placement:\n                    if best_placement is None or placement['waste'] < best_placement['waste']:\n                        best_placement = {\n                            'truck_index': ti,\n                            'item_index': item_index,\n                            'x': placement['x'],\n                            'y': placement['y'],\n                            'z': placement['z'],\n                            'orientation': orient,\n                            'waste': placement['waste']\n                        }\n\n        if best_placement:\n            truck_index = best_placement['truck_index']\n            item_index = best_placement['item_index']\n            x = best_placement['x']\n            y = best_placement['y']\n            z = best_placement['z']\n            orientation = best_placement['orientation']\n        else:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n        return truck_index, item_index, x, y, z, orientation\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index = -1\n        item_index = -1\n        x, y, z = 0.0, 0.0, 0.0\n        orientation = 0\n\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n        best_placement = None\n\n        for ti in range(len(trucks_in_use) + 1):\n            if ti < len(trucks_in_use):\n                truck = trucks_in_use[ti]\n            else:\n                truck = {'occupied_volumes': []}\n\n            for orient in range(6):\n                item_dims = self._get_orientations(unplaced_items[item_index])[orient][1]\n                placement = self._find_best_position(unplaced_items[item_index], item_dims, truck['occupied_volumes'], truck_type)\n\n                if placement:\n                    if best_placement is None or placement['waste'] < best_placement['waste']:\n                        best_placement = {\n                            'truck_index': ti,\n                            'item_index': item_index,\n                            'x': placement['x'],\n                            'y': placement['y'],\n                            'z': placement['z'],\n                            'orientation': orient,\n                            'waste': placement['waste']\n                        }\n\n        if best_placement:\n            truck_index = best_placement['truck_index']\n            item_index = best_placement['item_index']\n            x = best_placement['x']\n            y = best_placement['y']\n            z = best_placement['z']\n            orientation = best_placement['orientation']\n\n            if best_placement['truck_index'] == len(trucks_in_use):\n                truck_index = -1\n        else:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n        return truck_index, item_index, x, y, z, orientation",
          "objective": 24.75,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     }
]