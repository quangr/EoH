[
     {
          "algorithm": "Prioritizes item placement by maximizing the contact surface area between the item and existing items or container walls.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Prioritizes item placement by maximizing the contact surface area between the item and existing items or container walls.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item_to_place(unplaced_items)\n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n\n        best_placement = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n\n        if best_placement:\n            return (best_placement['truck_index'], item_index, best_placement['x'],\n                    best_placement['y'], best_placement['z'], best_placement['orientation'])\n        else:\n            return -1, -1, 0, 0, 0, 0\n\n    def _select_item_to_place(self, unplaced_items):\n        eligible_items = [i for i, item in enumerate(unplaced_items) if item['quantity'] > 0]\n        if not eligible_items:\n            return None\n        return max(eligible_items, key=lambda i: unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height'])\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_placement = None\n        max_contact_area = -1\n\n        for truck_index in range(len(trucks_in_use) + 1):\n            truck = trucks_in_use[truck_index] if truck_index < len(trucks_in_use) else {'occupied_volumes': []}\n\n            for orientation in range(6):\n                item_type = unplaced_items[item_index]\n                item_dims = self._get_orientations(item_type)[orientation][1]\n                position = self._find_valid_position(item_type, orientation, truck_type, truck['occupied_volumes'])\n\n                if position:\n                    x, y, z = position\n                    contact_area = self._calculate_contact_area(x, y, z, item_dims, truck_type, truck['occupied_volumes'])\n\n                    if contact_area > max_contact_area:\n                        max_contact_area = contact_area\n                        best_placement = {\n                            'truck_index': truck_index,\n                            'x': x,\n                            'y': y,\n                            'z': z,\n                            'orientation': orientation\n                        }\n        return best_placement\n\n    def _find_valid_position(self, item_type, orientation, container_dims, occupied_volumes):\n        item_dims = self._get_orientations(item_type)[orientation][1]\n        cl, cw, ch = container_dims\n\n        potential_positions = self._generate_potential_positions(occupied_volumes)\n\n        for x, y, z in potential_positions:\n            if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                return x, y, z\n        return None\n\n    def _generate_potential_positions(self, occupied_volumes):\n        positions = [(0.0, 0.0, 0.0)]\n        for item in occupied_volumes:\n            x, y, z = item['x'], item['y'], item['z']\n            l, w, h = item['length'], item['width'], item['height']\n            positions.extend([(x + l, y, z), (x, y + w, z), (x, y, z + h), (x - item_type['length'], y, z), (x, y-item_type['width'], z), (x, y, z-item_type['height'])])\n        return positions\n\n    def _calculate_contact_area(self, x, y, z, item_dims, container_dims, occupied_volumes):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        contact_area = 0\n\n        if x == 0:\n            contact_area += iw * ih\n        if y == 0:\n            contact_area += il * ih\n        if z == 0:\n            contact_area += il * iw\n\n        if x + il == cl:\n            contact_area += iw * ih\n        if y + iw == cw:\n            contact_area += il * ih\n        if z + ih == ch:\n            contact_area += il * iw\n                    \n        for placed_item in occupied_volumes:\n            px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n            pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n\n            if (x + il == px and y < py + pw and y + iw > py and z < pz + ph and z + ih > pz):\n                contact_area += iw * ih\n            if (y + iw == py and x < px + pl and x + il > px and z < pz + ph and z + ih > pz):\n                contact_area += il * ih\n            if (z + ih == pz and x < px + pl and x + il > px and y < py + pw and y + iw > py):\n                contact_area += il * iw\n            \n            if (x == px + pl and y < py + pw and y + iw > py and z < pz + ph and z + ih > pz):\n                contact_area += iw * ih\n            if (y == py + pw and x < px + pl and x + il > px and z < pz + ph and z + ih > pz):\n                contact_area += il * ih\n            if (z == pz + ph and x < px + pl and x + il > px and y < py + pw and y + iw > py):\n                contact_area += il * iw\n\n        return contact_area\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item_to_place(unplaced_items)\n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n\n        best_placement = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n\n        if best_placement:\n            truck_index = best_placement['truck_index']\n            if truck_index == len(trucks_in_use):\n                truck_index = -1\n            return (truck_index, item_index, best_placement['x'],\n                    best_placement['y'], best_placement['z'], best_placement['orientation'])\n        else:\n            return -1, -1, 0, 0, 0, 0\nimport numpy as np\n\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _generate_potential_positions(self, occupied_volumes):\n        positions = [(0.0, 0.0, 0.0)]\n        for item in occupied_volumes:\n            x, y, z = item['x'], item['y'], item['z']\n            l, w, h = item['length'], item['width'], item['height']\n            positions.extend([(x + l, y, z), (x, y + w, z), (x, y, z + h)])\n        return positions",
          "objective": 22.55,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     },
     {
          "algorithm": "Prioritizes item selection using a volume-to-quantity ratio, adjusted by a compactness score derived from the item's dimensions, favoring items that fill the container more efficiently.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Prioritizes item selection using a volume-to-quantity ratio, adjusted by a compactness score derived from the item's dimensions, favoring items that fill the container more efficiently.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n\n        truck_index, x, y, z, orientation = self._find_best_placement(item_index, unplaced_items, trucks_in_use, truck_type)\n\n        if truck_index == len(trucks_in_use):\n            truck_index = -1\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        eligible_items = [i for i, item in enumerate(unplaced_items) if item['quantity'] > 0]\n        if not eligible_items:\n            return None\n\n        def item_score(i):\n            item = unplaced_items[i]\n            volume = item['length'] * item['width'] * item['height']\n            dims = sorted([item['length'], item['width'], item['height']])\n            compactness = dims[0] * dims[1] / (dims[2]**2)\n            adjusted_volume = volume * (1 + compactness)\n            return adjusted_volume/ item['quantity']\n\n        return max(eligible_items, key=item_score)\n\n    def _find_best_placement(self, item_index, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = -1\n        min_waste_score = float('inf')\n\n        for truck_index in range(len(trucks_in_use) + 1):\n            if truck_index < len(trucks_in_use):\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n            else:\n                occupied_volumes = []\n\n            for orientation in range(6):\n                item_type = unplaced_items[item_index]\n                item_dims = self._get_orientations(item_type)[orientation][1]\n                x, y, z = self._find_position_in_truck(item_dims, truck_type, occupied_volumes)\n\n                if x is not None:\n                    waste_score = self._calculate_waste_score(x, y, z, item_dims, truck_type, occupied_volumes)\n                    if waste_score < min_waste_score:\n                        min_waste_score = waste_score\n                        best_truck_index = truck_index\n                        best_x, best_y, best_z = x, y, z\n                        best_orientation = orientation\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_dims, truck_type, occupied_volumes):\n        potential_positions = self._generate_potential_positions(occupied_volumes)\n        for x, y, z in potential_positions:\n            if self._is_valid_placement((x, y, z), item_dims, truck_type, occupied_volumes):\n                return x, y, z\n        return None, None, None\n\n    def _generate_potential_positions(self, occupied_volumes):\n        positions = [(0.0, 0.0, 0.0)]\n        for item in occupied_volumes:\n            x, y, z = item['x'], item['y'], item['z']\n            l, w, h = item['length'], item['width'], item['height']\n            positions.extend([(x + l, y, z), (x, y + w, z), (x, y, z + h)])\n        return positions\n\n    def _calculate_waste_score(self, x, y, z, item_dims, container_dims, occupied_volumes):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        height_waste = ch - (z + ih)\n        area_waste = (cl - (x + il)) * (cw - (y + iw))\n        return height_waste + area_waste",
          "objective": 22.85,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Select items based on a weighted score of remaining quantity and volume, giving higher priority to items with larger quantities and adjusting the volume score by a flatness term.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select items based on a weighted score of remaining quantity and volume, giving higher priority to items with larger quantities and adjusting the volume score by a flatness term.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n\n        truck_index, x, y, z, orientation = self._find_best_placement(item_index, unplaced_items, trucks_in_use, truck_type)\n\n        if truck_index == len(trucks_in_use):\n            truck_index = -1\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        eligible_items = [i for i, item in enumerate(unplaced_items) if item['quantity'] > 0]\n        if not eligible_items:\n            return None\n\n        def item_score(i):\n            item = unplaced_items[i]\n            volume = item['length'] * item['width'] * item['height']\n            dims = sorted([item['length'], item['width'], item['height']])\n            flatness = dims[0] / dims[2]\n            adjusted_volume = volume * (1 + flatness)\n            return adjusted_volume * item['quantity']\n\n        return max(eligible_items, key=item_score)\n\n    def _find_best_placement(self, item_index, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = -1\n        min_waste_score = float('inf')\n\n        for truck_index in range(len(trucks_in_use) + 1):\n            if truck_index < len(trucks_in_use):\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n            else:\n                occupied_volumes = []\n\n            for orientation in range(6):\n                item_type = unplaced_items[item_index]\n                item_dims = self._get_orientations(item_type)[orientation][1]\n                x, y, z = self._find_position_in_truck(item_dims, truck_type, occupied_volumes)\n\n                if x is not None:\n                    waste_score = self._calculate_waste_score(x, y, z, item_dims, truck_type, occupied_volumes)\n                    if waste_score < min_waste_score:\n                        min_waste_score = waste_score\n                        best_truck_index = truck_index\n                        best_x, best_y, best_z = x, y, z\n                        best_orientation = orientation\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_dims, truck_type, occupied_volumes):\n        potential_positions = self._generate_potential_positions(occupied_volumes)\n        for x, y, z in potential_positions:\n            if self._is_valid_placement((x, y, z), item_dims, truck_type, occupied_volumes):\n                return x, y, z\n        return None, None, None\n\n    def _generate_potential_positions(self, occupied_volumes):\n        positions = [(0.0, 0.0, 0.0)]\n        for item in occupied_volumes:\n            x, y, z = item['x'], item['y'], item['z']\n            l, w, h = item['length'], item['width'], item['height']\n            positions.extend([(x + l, y, z), (x, y + w, z), (x, y, z + h)])\n        return positions\n\n    def _calculate_waste_score(self, x, y, z, item_dims, container_dims, occupied_volumes):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        height_waste = ch - (z + ih)\n        area_waste = (cl - (x + il)) * (cw - (y + iw))\n        return height_waste + area_waste",
          "objective": 22.95,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Select items based on a weighted score of remaining quantity and a modified volume focusing on minimizing the largest dimension.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select items based on a weighted score of remaining quantity and a modified volume focusing on minimizing the largest dimension.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n\n        truck_index, x, y, z, orientation = self._find_best_placement(item_index, unplaced_items, trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        eligible_items = [i for i, item in enumerate(unplaced_items) if item['quantity'] > 0]\n        if not eligible_items:\n            return None\n\n        def item_score(i):\n            item = unplaced_items[i]\n            volume = item['length'] * item['width'] * item['height']\n            max_dim = max(item['length'], item['width'], item['height'])\n            modified_volume = volume / max_dim\n            return modified_volume * item['quantity']\n\n        return max(eligible_items, key=item_score)\n\n    def _find_best_placement(self, item_index, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = -1\n        min_waste_score = float('inf')\n\n        for truck_index in range(len(trucks_in_use) + 1):\n            if truck_index < len(trucks_in_use):\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n            else:\n                occupied_volumes = []\n\n            for orientation in range(6):\n                item_type = unplaced_items[item_index]\n                item_dims = self._get_orientations(item_type)[orientation][1]\n                x, y, z = self._find_position_in_truck(item_dims, truck_type, occupied_volumes)\n\n                if x is not None:\n                    waste_score = self._calculate_waste_score(x, y, z, item_dims, truck_type, occupied_volumes)\n                    if waste_score < min_waste_score:\n                        min_waste_score = waste_score\n                        best_truck_index = truck_index\n                        best_x, best_y, best_z = x, y, z\n                        best_orientation = orientation\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_dims, truck_type, occupied_volumes):\n        potential_positions = self._generate_potential_positions(occupied_volumes)\n        for x, y, z in potential_positions:\n            if self._is_valid_placement((x, y, z), item_dims, truck_type, occupied_volumes):\n                return x, y, z\n        return None, None, None\n\n    def _generate_potential_positions(self, occupied_volumes):\n        positions = [(0.0, 0.0, 0.0)]\n        for item in occupied_volumes:\n            x, y, z = item['x'], item['y'], item['z']\n            l, w, h = item['length'], item['width'], item['height']\n            positions.extend([(x + l, y, z), (x, y + w, z), (x, y, z + h)])\n        return positions\n\n    def _calculate_waste_score(self, x, y, z, item_dims, container_dims, occupied_volumes):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        height_waste = ch - (z + ih)\n        area_waste = (cl - (x + il)) * (cw - (y + iw))\n        return height_waste + area_waste\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n\n        truck_index, x, y, z, orientation = self._find_best_placement(item_index, unplaced_items, trucks_in_use, truck_type)\n\n        if truck_index == len(trucks_in_use):\n            truck_index = -1\n\n        return truck_index, item_index, x, y, z, orientation",
          "objective": 23.0,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     },
     {
          "algorithm": "Select item types based on a combined score of modified volume and remaining quantity, prioritizing placements that minimize height and area waste.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select item types based on a combined score of modified volume and remaining quantity, prioritizing placements that minimize height and area waste.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n\n        truck_index, x, y, z, orientation = self._find_best_placement(item_index, unplaced_items, trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        eligible_items = [i for i, item in enumerate(unplaced_items) if item['quantity'] > 0]\n        if not eligible_items:\n            return None\n\n        def item_score(i):\n          item = unplaced_items[i]\n          volume = item['length'] * item['width'] * item['height']\n          modified_volume = volume / (item['width'] + item['height'])\n          return modified_volume * item['quantity']\n\n        return max(eligible_items, key=item_score)\n\n    def _find_best_placement(self, item_index, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = -1\n        min_waste_score = float('inf')\n\n        for truck_index in range(len(trucks_in_use) + 1):\n            if truck_index < len(trucks_in_use):\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n            else:\n                occupied_volumes = []\n\n            for orientation in range(6):\n                item_type = unplaced_items[item_index]\n                item_dims = self._get_orientations(item_type)[orientation][1]\n                x, y, z = self._find_position_in_truck(item_dims, truck_type, occupied_volumes)\n\n                if x is not None:\n                    waste_score = self._calculate_waste_score(x, y, z, item_dims, truck_type, occupied_volumes)\n                    if waste_score < min_waste_score:\n                        min_waste_score = waste_score\n                        best_truck_index = truck_index\n                        best_x, best_y, best_z = x, y, z\n                        best_orientation = orientation\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_dims, truck_type, occupied_volumes):\n        potential_positions = self._generate_potential_positions(occupied_volumes)\n        for x, y, z in potential_positions:\n            if self._is_valid_placement((x, y, z), item_dims, truck_type, occupied_volumes):\n                return x, y, z\n        return None, None, None\n\n    def _generate_potential_positions(self, occupied_volumes):\n        positions = [(0.0, 0.0, 0.0)]\n        for item in occupied_volumes:\n            x, y, z = item['x'], item['y'], item['z']\n            l, w, h = item['length'], item['width'], item['height']\n            positions.extend([(x + l, y, z), (x, y + w, z), (x, y, z + h)])\n        return positions\n\n    def _calculate_waste_score(self, x, y, z, item_dims, container_dims, occupied_volumes):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        height_waste = ch - (z + ih)\n        area_waste = (cl - (x + il)) * (cw - (y + iw))\n        return height_waste + area_waste\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n\n        truck_index, x, y, z, orientation = self._find_best_placement(item_index, unplaced_items, trucks_in_use, truck_type)\n\n        if truck_index == len(trucks_in_use):\n            truck_index = -1\n\n        return truck_index, item_index, x, y, z, orientation",
          "objective": 23.05,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     }
]