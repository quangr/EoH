{
     "algorithm": "Select the item with the largest volume and place it into the best truck or a new truck, trying all orientations and prioritizing the lowest z coordinate for stable packing.",
     "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select the item with the largest volume and place it into the best truck or a new truck, trying all orientations and prioritizing the lowest z coordinate for stable packing.}\n    def _select_item_to_place(self, unplaced_items):\n        eligible_items = [i for i, item in enumerate(unplaced_items) if item['quantity'] > 0]\n        if not eligible_items:\n            return None\n        return max(eligible_items, key=lambda i: unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height'])\n    \n    def _find_valid_position_with_min_z(self, item_type, orientation, container_dims, occupied_volumes):\n        item_dims = self._get_orientations(item_type)[orientation][1]\n        \n        valid_positions = []\n        \n        x_step = min(item_dims[0], 1.0)\n        y_step = min(item_dims[1], 1.0)\n        z_step = min(item_dims[2], 1.0)\n\n        for z in np.arange(0.0, container_dims[2], z_step):\n            for y in np.arange(0.0, container_dims[1], y_step):\n                for x in np.arange(0.0, container_dims[0], x_step):\n                  \n                    x, y, z = round(x, 6), round(y, 6), round(z, 6)\n\n                    if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                      \n                        valid_positions.append((x, y, z))\n        \n        if not valid_positions:\n            return None\n\n        return min(valid_positions, key=lambda pos: pos[2])\n        \n    def _evaluate_placement(self, item_dims, container_dims, x, y, z):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        return (cl - (x + il)) * (cw - (y + iw)) * (ch - (z + ih))\n    \n    def _find_best_truck(self, item_index, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_orientation = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_space_utilization = float('-inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            occupied_volumes = truck['occupied_volumes']\n            for orientation in range(6):\n                item_type = unplaced_items[item_index]\n                position = self._find_valid_position_with_min_z(item_type, orientation, truck_type, occupied_volumes)\n                if position:\n                    x, y, z = position\n                    item_dims = self._get_orientations(item_type)[orientation][1]\n                    space_utilization = (truck_type[0] * truck_type[1] * truck_type[2]) - self._evaluate_placement(item_dims, truck_type, x, y, z)\n                    if space_utilization > best_space_utilization:\n                        best_truck_index = truck_index\n                        best_orientation = orientation\n                        best_x, best_y, best_z = x, y, z\n                        best_space_utilization = space_utilization\n\n        return best_truck_index, best_orientation, best_x, best_y, best_z\n    \n    def _find_valid_position_new_truck(self, item_type, orientation, truck_type):\n        item_dims = self._get_orientations(item_type)[orientation][1]\n        if self._is_valid_placement((0.0, 0.0, 0.0), item_dims, truck_type, []):\n            return 0.0, 0.0, 0.0\n        return None\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item_to_place(unplaced_items)\n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n            \n        best_truck_index, best_orientation, best_x, best_y, best_z = self._find_best_truck(item_index, unplaced_items, trucks_in_use, truck_type)\n\n        if best_truck_index == -1:\n            best_orientation = -1\n            for orientation in range(6):\n                item_type = unplaced_items[item_index]\n                position = self._find_valid_position_new_truck(item_type, orientation, truck_type)\n                if position:\n                    best_orientation = orientation\n                    best_x, best_y, best_z = position\n                    break\n\n            if best_orientation == -1:\n                return -1, -1, 0, 0, 0, 0\n\n        return best_truck_index, item_index, best_x, best_y, best_z, best_orientation\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_valid_position_with_min_z(self, item_type, orientation, container_dims, occupied_volumes):\n        item_dims = self._get_orientations(item_type)[orientation][1]\n        \n        valid_positions = []\n        \n        x_step = item_dims[0]\n        y_step = item_dims[1]\n        z_step = item_dims[2]\n\n        x_positions = [0.0]\n        y_positions = [0.0]\n        z_positions = [0.0]\n\n        for item in occupied_volumes:\n            x_positions.append(item['x'] + item['length'])\n            y_positions.append(item['y'] + item['width'])\n            z_positions.append(item['z'] + item['height'])\n        \n        for z in sorted(list(set(z_positions))):\n            for y in sorted(list(set(y_positions))):\n                for x in sorted(list(set(x_positions))):\n\n                    x, y, z = round(x, 6), round(y, 6), round(z, 6)\n\n                    if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                        valid_positions.append((x, y, z))\n        \n        if not valid_positions:\n            return None\n\n        return min(valid_positions, key=lambda pos: pos[2])",
     "objective": 24.45,
     "other_inf": null,
     "class_name": "AlgorithmFIX1"
}