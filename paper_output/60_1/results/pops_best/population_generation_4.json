{
     "algorithm": "Greedily place items based on remaining quantity, selecting the best-fit position and orientation that minimizes dead space in existing trucks or opens a new one if no fit is found.",
     "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Greedily place items based on remaining quantity, selecting the best-fit position and orientation that minimizes dead space in existing trucks or opens a new one if no fit is found.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n\n        truck_index, x, y, z, orientation = self._find_best_placement(item_index, unplaced_items, trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        eligible_items = [i for i, item in enumerate(unplaced_items) if item['quantity'] > 0]\n        if not eligible_items:\n            return None\n        return max(eligible_items, key=lambda i: unplaced_items[i]['quantity'])\n\n    def _find_best_placement(self, item_index, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = -1\n        min_dead_space = float('inf')\n\n        for truck_index in range(len(trucks_in_use) + 1):\n            if truck_index < len(trucks_in_use):\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n            else:\n                occupied_volumes = []\n\n            for orientation in range(6):\n                item_type = unplaced_items[item_index]\n                item_dims = self._get_orientations(item_type)[orientation][1]\n                x, y, z = self._find_position_in_truck(item_dims, truck_type, occupied_volumes)\n\n                if x is not None:\n                    dead_space = self._calculate_dead_space(x, y, z, item_dims, truck_type, occupied_volumes)\n                    if dead_space < min_dead_space:\n                        min_dead_space = dead_space\n                        best_truck_index = truck_index\n                        best_x, best_y, best_z = x, y, z\n                        best_orientation = orientation\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_dims, truck_type, occupied_volumes):\n        potential_positions = self._generate_potential_positions(occupied_volumes)\n        for x, y, z in potential_positions:\n            if self._is_valid_placement((x, y, z), item_dims, truck_type, occupied_volumes):\n                return x, y, z\n        return None, None, None\n\n    def _generate_potential_positions(self, occupied_volumes):\n        positions = [(0.0, 0.0, 0.0)]\n        for item in occupied_volumes:\n            x, y, z = item['x'], item['y'], item['z']\n            l, w, h = item['length'], item['width'], item['height']\n            positions.extend([(x + l, y, z), (x, y + w, z), (x, y, z + h)])\n        return positions\n\n    def _calculate_dead_space(self, x, y, z, item_dims, container_dims, occupied_volumes):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        return (cl - (x + il)) * (cw - (y + iw)) * (ch - (z + ih))\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n\n        truck_index, x, y, z, orientation = self._find_best_placement(item_index, unplaced_items, trucks_in_use, truck_type)\n\n        if truck_index == len(trucks_in_use):\n            truck_index = -1\n\n        return truck_index, item_index, x, y, z, orientation",
     "objective": 23.2,
     "other_inf": null,
     "class_name": "AlgorithmFIX1"
}