[
     {
          "algorithm": "The algorithm iterates through unplaced items and available trucks, attempting to place items using a best-fit heuristic based on remaining space and item dimensions.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {The algorithm iterates through unplaced items and available trucks, attempting to place items using a best-fit heuristic based on remaining space and item dimensions.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index = -1\n        item_index = -1\n        x, y, z = 0.0, 0.0, 0.0\n        orientation = 0\n\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n        \n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items[item_index], trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        best_item_volume = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > best_item_volume:\n                    best_item_volume = volume\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, item, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0.0, 0.0, 0.0\n        best_orientation = 0\n        min_waste = float('inf')\n\n        for truck_idx, truck in enumerate(trucks_in_use):\n            x, y, z, orientation, waste = self._find_position_in_truck(item, truck, truck_type)\n            if waste < min_waste:\n                min_waste = waste\n                best_truck_index = truck_idx\n                best_x, best_y, best_z = x, y, z\n                best_orientation = orientation\n        \n        if best_truck_index == -1:\n            best_x, best_y, best_z, best_orientation, waste = self._find_position_in_new_truck(item, truck_type)\n            \n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item, truck, truck_type):\n        best_x, best_y, best_z = 0.0, 0.0, 0.0\n        best_orientation = 0\n        min_waste = float('inf')\n        \n        for orientation_index, (orientation_id, (l, w, h)) in enumerate(self._get_orientations(item)):\n          \n            potential_positions = self._generate_potential_positions(truck, truck_type, l, w, h)\n            for px, py, pz in potential_positions:\n\n                if self._is_valid_placement((px, py, pz), (l, w, h), truck_type, truck['occupied_volumes']):\n                    waste = self._calculate_waste((px, py, pz), (l, w, h), truck_type, truck['occupied_volumes'])\n                    if waste < min_waste:\n                        min_waste = waste\n                        best_x, best_y, best_z = px, py, pz\n                        best_orientation = orientation_index\n        return best_x, best_y, best_z, best_orientation, min_waste\n    \n    def _find_position_in_new_truck(self, item, truck_type):\n        best_x, best_y, best_z = 0.0, 0.0, 0.0\n        best_orientation = 0\n        min_waste = float('inf')\n        empty_truck = {'occupied_volumes': []}\n        \n        for orientation_index, (orientation_id, (l, w, h)) in enumerate(self._get_orientations(item)):\n            if self._is_valid_placement((0.0, 0.0, 0.0), (l, w, h), truck_type, empty_truck['occupied_volumes']):\n                waste = self._calculate_waste((0.0, 0.0, 0.0), (l, w, h), truck_type, empty_truck['occupied_volumes'])                \n                if waste < min_waste:\n                    min_waste = waste\n                    best_x, best_y, best_z = 0.0, 0.0, 0.0\n                    best_orientation = orientation_index\n        return best_x, best_y, best_z, best_orientation, min_waste\n          \n    def _generate_potential_positions(self, truck, truck_type, l, w, h):\n        potential_positions = []\n        occupied_volumes = truck['occupied_volumes']\n\n        if not occupied_volumes:\n            potential_positions.append((0.0, 0.0, 0.0))\n            return potential_positions       \n\n        for placed_item in occupied_volumes:\n            x = placed_item['x']\n            y = placed_item['y']\n            z = placed_item['z']            \n            length = placed_item['length']\n            width = placed_item['width']\n            height = placed_item['height']\n            \n            potential_positions.append((x + length, y, z))\n            potential_positions.append((x, y + width, z))\n            potential_positions.append((x, y, z + height))                \n        \n        potential_positions.append((0.0, 0.0, 0.0))\n        \n        return potential_positions\n    \n    def _calculate_waste(self, item_pos, item_dims, container_dims, occupied_volumes):\n        px, py, pz = item_pos\n        pl, pw, ph = item_dims\n        cl, cw, ch = container_dims\n        \n        total_container_volume = cl * cw * ch\n        \n        occupied_volume = 0.0\n        for placed_item in occupied_volumes:\n            occupied_volume += placed_item['length'] * placed_item['width'] * placed_item['height']\n        occupied_volume += pl * pw * ph\n        waste = total_container_volume - occupied_volume\n        return waste",
          "objective": 24.7,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "The algorithm prioritizes items with higher volume and tries to place them using a bottom-left-front placement strategy in existing trucks, opening a new truck only when necessary.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {The algorithm prioritizes items with higher volume and tries to place them using a bottom-left-front placement strategy in existing trucks, opening a new truck only when necessary.}\n    \n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = 0\n        max_volume = 0\n        for i, item in enumerate(unplaced_items):\n            volume = item['length'] * item['width'] * item['height']\n            if volume * item['quantity'] > max_volume:\n                max_volume = volume * item['quantity']\n                best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = 0\n        \n        current_best_score = float('inf')\n\n        for truck_index in range(len(trucks_in_use)):\n            truck = trucks_in_use[truck_index]\n            \n            x, y, z, orientation = self._find_placement_in_truck(unplaced_items, truck, truck_type, item_index)\n\n            if x is not None:\n                item = unplaced_items[item_index]\n                dims = self._get_orientations(item)[orientation][1]\n                score = x + y + z\n                if score < current_best_score:\n                    current_best_score = score\n                    best_truck_index = truck_index\n                    best_x, best_y, best_z = x, y, z\n                    best_orientation = orientation\n        \n        if best_truck_index == -1:\n            item = unplaced_items[item_index]\n            orientations = self._get_orientations(item)\n            for orientation_index, (orient, dims) in enumerate(orientations):\n                if self._is_within_container_bounds((0,0,0), dims, truck_type):\n                    return -1, 0, 0, 0, orientation_index\n        else:\n            return best_truck_index, best_x, best_y, best_z, best_orientation\n        \n        return -1, 0, 0, 0, 0\n\n    def _find_placement_in_truck(self, unplaced_items, truck, truck_type, item_index):\n        item = unplaced_items[item_index]\n        orientations = self._get_orientations(item)\n        \n        best_x, best_y, best_z = None, None, None\n        \n        for orientation_index, (orient, dims) in enumerate(orientations):\n            \n            x,y,z = self._find_bottom_left_front_position(dims, truck, truck_type)\n\n            if x is not None and y is not None and z is not None:\n\n                return x, y, z, orientation_index\n\n        return None, None, None, None\n\n    def _find_bottom_left_front_position(self, item_dims, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n        \n        length, width, height = item_dims\n\n        for z in sorted(list(set([0] + [box['z'] + box['height'] for box in occupied_volumes]))):\n            for y in sorted(list(set([0] + [box['y'] + box['width'] for box in occupied_volumes]))):\n                for x in sorted(list(set([0] + [box['x'] + box['length'] for box in occupied_volumes]))):\n\n                    if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                        return x,y,z\n        return None, None, None",
          "objective": 26.65,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "The algorithm iterates through unplaced items and their orientations, placing them into existing trucks or a new truck based on a first-fit approach.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {The algorithm iterates through unplaced items and their orientations, placing them into existing trucks or a new truck based on a first-fit approach.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index = -1\n        item_index = -1\n        x = 0.0\n        y = 0.0\n        z = 0.0\n        orientation = -1\n\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, 0.0, 0.0, 0.0, -1\n\n        item_to_place = unplaced_items[item_index]\n\n        truck_index, x, y, z, orientation = self._find_placement(item_to_place, trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                return i\n        return -1\n\n    def _find_placement(self, item_to_place, trucks_in_use, truck_type):\n        orientations = self._get_orientations(item_to_place)\n        \n        for truck_index, truck in enumerate(trucks_in_use):\n            occupied_volumes = truck['occupied_volumes']\n            x, y, z, orientation = self._find_position_in_truck(item_to_place, orientations, truck_type, occupied_volumes)\n            if orientation != -1:\n                return truck_index, x, y, z, orientation\n        \n        x, y, z, orientation = self._find_position_in_new_truck(item_to_place, orientations, truck_type)\n        return -1, x, y, z, orientation\n\n    def _find_position_in_truck(self, item_to_place, orientations, truck_type, occupied_volumes):\n        for orient_idx, dims in orientations:\n            length, width, height = dims\n            \n            x, y, z = self._find_first_fit_position(length, width, height, truck_type, occupied_volumes)\n            if x is not None:\n                return x, y, z, orient_idx\n        return None, None, None, -1\n\n    def _find_first_fit_position(self, length, width, height, container_dims, occupied_volumes):\n        cl, cw, ch = container_dims\n        \n        positions_to_check = self._generate_candidate_positions(container_dims, occupied_volumes)\n\n        for x, y, z in positions_to_check:\n            if self._is_valid_placement((x, y, z), (length, width, height), container_dims, occupied_volumes):\n                return x, y, z\n        \n        return None, None, None\n\n    def _generate_candidate_positions(self, container_dims, occupied_volumes):\n        positions = [(0.0, 0.0, 0.0)]\n        for item in occupied_volumes:\n            positions.append((item['x'] + item['length'], item['y'], item['z']))\n            positions.append((item['x'], item['y'] + item['width'], item['z']))\n            positions.append((item['x'], item['y'], item['z'] + item['height']))\n\n        return positions\n    \n    def _find_position_in_new_truck(self, item_to_place, orientations, truck_type):\n        for orient_idx, dims in orientations:\n            if self._is_valid_placement((0.0, 0.0, 0.0), dims, truck_type, []):\n                return 0.0, 0.0, 0.0, orient_idx\n        return None, None, None, -1",
          "objective": 27.3,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm prioritizes filling existing trucks with a best-fit heuristic based on remaining volume and then selects the unplaced item best fitting the available location.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes filling existing trucks with a best-fit heuristic based on remaining volume and then selects the unplaced item best fitting the available location.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = float('inf')\n\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                for truck_index, truck in enumerate(trucks_in_use):\n                    x, y, z, orientation = self._find_placement_in_truck(item_type, truck, truck_type)\n                    if x != -1:\n                        score = self._evaluate_placement(item_type, (x, y, z), orientation, truck_type, truck['occupied_volumes'])\n                        if score < best_score:\n                            best_score = score\n                            best_truck_index = truck_index\n                            best_item_index = item_index\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            best_orientation = orientation\n\n                if best_truck_index == -1:\n                    x, y, z, orientation = self._find_placement_in_new_truck(item_type, truck_type)\n                    if x != -1:\n                        score = self._evaluate_placement(item_type, (x, y, z), orientation, truck_type, [])\n                        if score < best_score:\n                            best_score = score\n                            best_truck_index = -1\n                            best_item_index = item_index\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            best_orientation = orientation\n        \n        if best_truck_index == -1 and best_item_index == -1:\n            item_index = next((i for i, item in enumerate(unplaced_items) if item['quantity'] > 0), -1)\n            if item_index != -1:\n                x, y, z, orientation = self._find_placement_in_new_truck(unplaced_items[item_index], truck_type)\n                if x != -1 :\n                   return -1, item_index, x, y, z, orientation\n        \n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_placement_in_truck(self, item_type, truck, truck_type):\n        orientations = self._get_orientations(item_type)\n        occupied_volumes = truck['occupied_volumes']\n        \n        for orientation_index, (orientation, (length, width, height)) in enumerate(orientations):\n            for x in np.arange(0, truck_type[0], 1):\n                for y in np.arange(0, truck_type[1], 1):\n                    for z in np.arange(0, truck_type[2], 1):\n                        if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                            return x, y, z, orientation_index\n        return -1, -1, -1, -1\n\n    def _find_placement_in_new_truck(self, item_type, truck_type):\n        orientations = self._get_orientations(item_type)\n        for orientation_index, (orientation, (length, width, height)) in enumerate(orientations):\n            if self._is_valid_placement((0, 0, 0), (length, width, height), truck_type, []):\n                return 0, 0, 0, orientation_index\n        return -1, -1, -1, -1\n    \n    def _evaluate_placement(self, item_type, position, orientation, container_dims, occupied_volumes):\n        score = 0\n        x, y, z = position\n        item_dims = self._get_orientations(item_type)[orientation][1]\n        length, width, height = item_dims\n\n        score = (container_dims[0] - (x + length)) + (container_dims[1] - (y + width)) + (container_dims[2] - (z + height))\n        return score\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_placement_in_truck(self, item_type, truck, truck_type):\n        orientations = self._get_orientations(item_type)\n        occupied_volumes = truck['occupied_volumes']\n        \n        for orientation_index, (orientation, (length, width, height)) in enumerate(orientations):\n            for x in np.arange(0, truck_type[0] - length + 1, 1):\n                for y in np.arange(0, truck_type[1] - width + 1, 1):\n                    for z in np.arange(0, truck_type[2] - height + 1, 1):\n                        if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                            return x, y, z, orientation_index\n        return -1, -1, -1, -1\nimport numpy as np\n\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_placement_in_truck(self, item_type, truck, truck_type):\n        orientations = self._get_orientations(item_type)\n        occupied_volumes = truck['occupied_volumes']\n        \n        for orientation_index, (orientation, (length, width, height)) in enumerate(orientations):\n            \n            max_x = truck_type[0] - length\n            max_y = truck_type[1] - width\n            max_z = truck_type[2] - height\n\n            if max_x < 0 or max_y < 0 or max_z < 0:\n               continue\n            \n            for x in np.arange(0, max_x + 1, 1):\n                for y in np.arange(0, max_y + 1, 1):\n                    for z in np.arange(0, max_z + 1, 1):\n                        if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                            return x, y, z, orientation_index\n        return -1, -1, -1, -1\nimport numpy as np\n\nclass AlgorithmFIX3(AlgorithmFIX2):\n    def _find_placement_in_truck(self, item_type, truck, truck_type):\n        orientations = self._get_orientations(item_type)\n        occupied_volumes = truck['occupied_volumes']\n        \n        for orientation_index, (orientation, (length, width, height)) in enumerate(orientations):\n            \n            max_x = truck_type[0] - length\n            max_y = truck_type[1] - width\n            max_z = truck_type[2] - height\n\n            if max_x < 0 or max_y < 0 or max_z < 0:\n               continue\n            \n            # Reduce the number of iterations by checking only a few potential positions.\n            positions = [(0, 0, 0), (max(0, int(max_x/2)), max(0, int(max_y/2)), max(0, int(max_z/2))), (max_x, max_y, max_z)]\n\n            for x, y, z in positions:\n                if x <= max_x and y <= max_y and z <= max_z:\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                        return x, y, z, orientation_index\n        return -1, -1, -1, -1",
          "objective": 42.0,
          "other_inf": null,
          "class_name": "AlgorithmFIX3"
     },
     {
          "algorithm": "Tries to place items based on a best-fit scoring system considering volume utilization and item dimensions, prioritizing existing trucks and opening new ones when necessary.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Tries to place items based on a best-fit scoring system considering volume utilization and item dimensions, prioritizing existing trucks and opening new ones when necessary.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_score = -1\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = 0\n        best_y = 0\n        best_z = 0\n        best_orientation = 0\n\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                for truck_index, truck in enumerate(trucks_in_use):\n                    x, y, z, orientation, score = self._find_placement_in_truck(item_type, truck, truck_type)\n                    if score > best_score:\n                        best_score = score\n                        best_truck_index = truck_index\n                        best_item_index = item_index\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation\n\n        if best_score == -1:\n            best_truck_index = -1\n            best_item_index = self._select_first_available_item(unplaced_items)\n            if best_item_index is not None:\n                best_x, best_y, best_z, best_orientation = self._find_placement_for_new_truck(unplaced_items[best_item_index], truck_type)\n            else:\n                return -1, -1, 0, 0, 0, 0\n        \n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_first_available_item(self, unplaced_items):\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                return item_index\n        return None\n\n    def _find_placement_in_truck(self, item_type, truck, truck_type):\n        best_score = -1\n        best_x = 0\n        best_y = 0\n        best_z = 0\n        best_orientation = 0\n\n        for orientation, (l, w, h) in self._get_orientations(item_type):\n            for x in np.arange(0, truck_type[0], 1):\n                for y in np.arange(0, truck_type[1], 1):\n                    for z in np.arange(0, truck_type[2], 1):\n                        if self._is_valid_placement((x, y, z), (l, w, h), truck_type, truck['occupied_volumes']):\n                            volume_utilization = (l * w * h) / (truck_type[0] * truck_type[1] * truck_type[2])\n                            dim_score = (1 / (abs(l - truck_type[0]) + abs(w - truck_type[1]) + abs(h - truck_type[2]) + 1))\n                            score = volume_utilization * dim_score\n                            if score > best_score:\n                                best_score = score\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation\n\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_placement_for_new_truck(self, item_type, truck_type):\n        best_orientation = 0\n        for orientation, (l, w, h) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (l, w, h), truck_type):\n                best_orientation = orientation\n                return 0, 0, 0, best_orientation\n        return 0, 0, 0, best_orientation\nclass AlgorithmFIX1(Algorithm):\n    def _find_placement_in_truck(self, item_type, truck, truck_type):\n        best_score = -1\n        best_x = 0\n        best_y = 0\n        best_z = 0\n        best_orientation = 0\n\n        max_steps = 10  # Limit the search iterations\n        step_count = 0\n\n        for orientation, (l, w, h) in self._get_orientations(item_type):\n            for x in np.arange(0, truck_type[0] - l + 1, max(1, l//2) if l>1 else 1):\n                for y in np.arange(0, truck_type[1] - w + 1, max(1, w//2) if w>1 else 1):\n                    for z in np.arange(0, truck_type[2] - h + 1,  max(1, h//2) if h>1 else 1):\n                        if self._is_valid_placement((x, y, z), (l, w, h), truck_type, truck['occupied_volumes']):\n                            volume_utilization = (l * w * h) / (truck_type[0] * truck_type[1] * truck_type[2])\n                            dim_score = (1 / (abs(l - truck_type[0]) + abs(w - truck_type[1]) + abs(h - truck_type[2]) + 1))\n                            score = volume_utilization * dim_score\n                            if score > best_score:\n                                best_score = score\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation\n                        step_count += 1\n                        if step_count > max_steps:\n                            break\n                    if step_count > max_steps:\n                        break\n                if step_count > max_steps:\n                    break\n            if step_count > max_steps:\n                break\n\n        return best_x, best_y, best_z, best_orientation, best_score",
          "objective": 42.65,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     }
]