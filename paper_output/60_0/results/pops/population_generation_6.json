[
     {
          "algorithm": "This algorithm prioritizes placing items with minimal area waste on the container's bottom surface, favoring orientations that minimize the item's height and selecting items based on a volume-to-quantity ratio.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes placing items with minimal area waste on the container's bottom surface, favoring orientations that minimize the item's height and selecting items based on a volume-to-quantity ratio.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items[item_index], trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        best_item_score = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                quantity = item['quantity']\n                score = volume / quantity if quantity > 0 else 0  # Volume-to-quantity ratio\n                if score > best_item_score:\n                    best_item_score = score\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, item, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0.0, 0.0, 0.0\n        best_orientation = 0\n        min_area_waste = float('inf')\n\n        for truck_idx, truck in enumerate(trucks_in_use):\n            x, y, z, orientation, area_waste = self._find_position_in_truck(item, truck, truck_type)\n            if area_waste < min_area_waste:\n                min_area_waste = area_waste\n                best_truck_index = truck_idx\n                best_x, best_y, best_z = x, y, z\n                best_orientation = orientation\n        \n        if best_truck_index == -1:\n            best_x, best_y, best_z, best_orientation, area_waste = self._find_position_in_new_truck(item, truck_type)\n            if best_x == None:\n              return -1, -1, 0.0, 0.0, 0.0, 0\n            best_truck_index = -1\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item, truck, truck_type):\n        best_x, best_y, best_z = 0.0, 0.0, 0.0\n        best_orientation = 0\n        min_area_waste = float('inf')\n        \n        for orientation_index, (orientation_id, (l, w, h)) in enumerate(self._get_orientations(item)):\n            potential_positions = self._generate_potential_positions(truck, truck_type, l, w, h)\n            for px, py, pz in potential_positions:\n\n                if self._is_valid_placement((px, py, pz), (l, w, h), truck_type, truck['occupied_volumes']):\n                    area_waste = self._calculate_area_waste((px, py, pz), (l, w, h), truck_type, truck['occupied_volumes'])\n                    if area_waste < min_area_waste:\n                        min_area_waste = area_waste\n                        best_x, best_y, best_z = px, py, pz\n                        best_orientation = orientation_index\n        return best_x, best_y, best_z, best_orientation, min_area_waste\n    \n    def _find_position_in_new_truck(self, item, truck_type):\n        best_x, best_y, best_z = None, None, None \n        best_orientation = 0\n        min_area_waste = float('inf')\n        empty_truck = {'occupied_volumes': []}\n        \n        for orientation_index, (orientation_id, (l, w, h)) in enumerate(self._get_orientations(item)):\n          \n            if self._is_valid_placement((0.0, 0.0, 0.0), (l, w, h), truck_type, empty_truck['occupied_volumes']):\n                area_waste = self._calculate_area_waste((0.0, 0.0, 0.0), (l, w, h), truck_type, empty_truck['occupied_volumes'])                \n                if area_waste < min_area_waste:\n                    min_area_waste = area_waste\n                    best_x, best_y, best_z = 0.0, 0.0, 0.0\n                    best_orientation = orientation_index\n        return best_x, best_y, best_z, best_orientation, min_area_waste\n          \n    def _generate_potential_positions(self, truck, truck_type, l, w, h):\n        potential_positions = []\n        occupied_volumes = truck['occupied_volumes']\n\n        if not occupied_volumes:\n            potential_positions.append((0.0, 0.0, 0.0))\n            return potential_positions       \n\n        for placed_item in occupied_volumes:\n            x = placed_item['x']\n            y = placed_item['y']\n            z = placed_item['z']            \n            length = placed_item['length']\n            width = placed_item['width']\n            height = placed_item['height']\n            \n            potential_positions.append((x + length, y, z))\n            potential_positions.append((x, y + width, z))\n            potential_positions.append((x, y, z + height))                \n        \n        potential_positions.append((0.0, 0.0, 0.0))\n        \n        return potential_positions\n\n    def _calculate_area_waste(self, item_pos, item_dims, container_dims, occupied_volumes):\n        px, py, pz = item_pos\n        pl, pw, ph = item_dims\n        cl, cw, ch = container_dims\n        \n        container_base_area = cl * cw\n        \n        occupied_base_area = 0.0\n        for placed_item in occupied_volumes:\n            occupied_base_area += placed_item['length'] * placed_item['width']\n\n        occupied_base_area += pl * pw\n        \n        area_waste = container_base_area - occupied_base_area\n        \n        height_penalty = ph * 0.1 # Penalize taller objects when minimizing base area waste\n        \n        return area_waste + height_penalty",
          "objective": 22.1,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm prioritizes items that fit snugly and reduces fragmentation by favoring placement against existing items and container walls.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes items that fit snugly and reduces fragmentation by favoring placement against existing items and container walls.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_placement = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n\n        if best_placement:\n            return best_placement['truck_index'], best_placement['item_index'], best_placement['x'], best_placement['y'], best_placement['z'], best_placement['orientation']\n        else:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_placement = None\n        best_score = -1.0\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                for truck_index, truck in enumerate(trucks_in_use):\n                    placement = self._find_placement_in_truck(item, item_index, truck, truck_index, truck_type)\n                    if placement and placement['score'] > best_score:\n                        best_score = placement['score']\n                        best_placement = placement\n\n                new_truck_placement = self._find_placement_in_new_truck(item, item_index, truck_type)\n                if new_truck_placement and new_truck_placement['score'] > best_score:\n                    best_score = new_truck_placement['score']\n                    best_placement = new_truck_placement\n\n        return best_placement\n\n    def _find_placement_in_truck(self, item, item_index, truck, truck_index, truck_type):\n        best_placement = None\n        best_score = -1.0\n\n        for orientation_index, (orientation_id, (l, w, h)) in enumerate(self._get_orientations(item)):\n            potential_positions = self._generate_potential_positions(truck, truck_type, l, w, h)\n            for px, py, pz in potential_positions:\n                if self._is_valid_placement((px, py, pz), (l, w, h), truck_type, truck['occupied_volumes']):\n                    score = self._calculate_placement_score((px, py, pz), (l, w, h), truck_type, truck['occupied_volumes'],  item['quantity'])\n                    if score > best_score:\n                        best_score = score\n                        best_placement = {\n                            'truck_index': truck_index,\n                            'item_index': item_index,\n                            'x': px,\n                            'y': py,\n                            'z': pz,\n                            'orientation': orientation_index,\n                            'score': score\n                        }\n        return best_placement\n\n    def _find_placement_in_new_truck(self, item, item_index, truck_type):\n        best_placement = None\n        best_score = -1.0\n        empty_truck = {'occupied_volumes': []}\n\n        for orientation_index, (orientation_id, (l, w, h)) in enumerate(self._get_orientations(item)):\n            if self._is_valid_placement((0.0, 0.0, 0.0), (l, w, h), truck_type, empty_truck['occupied_volumes']):\n                score = self._calculate_placement_score((0.0, 0.0, 0.0), (l, w, h), truck_type, empty_truck['occupied_volumes'], item['quantity'])\n                if score > best_score:\n                    best_score = score\n                    best_placement = {\n                        'truck_index': -1,\n                        'item_index': item_index,\n                        'x': 0.0,\n                        'y': 0.0,\n                        'z': 0.0,\n                        'orientation': orientation_index,\n                        'score': score\n                    }\n        return best_placement\n\n    def _generate_potential_positions(self, truck, truck_type, l, w, h):\n        potential_positions = []\n        occupied_volumes = truck['occupied_volumes']\n        cl, cw, ch = truck_type\n\n        if not occupied_volumes:\n            potential_positions.append((0.0, 0.0, 0.0))\n            return potential_positions\n\n        for placed_item in occupied_volumes:\n            x = placed_item['x']\n            y = placed_item['y']\n            z = placed_item['z']\n            length = placed_item['length']\n            width = placed_item['width']\n            height = placed_item['height']\n\n            new_x = x + length\n            new_y = y + width\n            new_z = z + height\n\n            if new_x + l <= cl + self.epsilon:\n                potential_positions.append((new_x, y, z))\n            if new_y + w <= cw + self.epsilon:\n                potential_positions.append((x, new_y, z))\n            if new_z + h <= ch + self.epsilon:\n                potential_positions.append((x, y, new_z))\n\n        potential_positions.append((0.0, 0.0, 0.0))\n        \n        return potential_positions\n\n    def _calculate_placement_score(self, item_pos, item_dims, container_dims, occupied_volumes, item_quantity):\n        volume_utilization = self._calculate_volume_utilization(item_dims, container_dims)\n        item_priority = item_quantity\n        adjacency_score = self._calculate_adjacency_score(item_pos, item_dims, container_dims, occupied_volumes)\n\n        score = (0.1 * volume_utilization +\n                 1.0 * item_priority +\n                 2.0 * adjacency_score)\n\n        return score\n\n    def _calculate_volume_utilization(self, item_dims, container_dims):\n        item_volume = item_dims[0] * item_dims[1] * item_dims[2]\n        container_volume = container_dims[0] * container_dims[1] * container_dims[2]\n        return item_volume / container_volume\n\n    def _calculate_adjacency_score(self, item_pos, item_dims, container_dims, occupied_volumes):\n        px, py, pz = item_pos\n        l, w, h = item_dims\n        cl, cw, ch = container_dims\n\n        adjacency = 0\n\n        if px == 0.0: adjacency += 1\n        if py == 0.0: adjacency += 1\n        if pz == 0.0: adjacency += 1\n        if px + l >= cl - self.epsilon: adjacency += 1\n        if py + w >= cw - self.epsilon: adjacency += 1\n        if pz + h >= ch - self.epsilon: adjacency += 1\n\n        for placed_item in occupied_volumes:\n            x = placed_item['x']\n            y = placed_item['y']\n            z = placed_item['z']\n            length = placed_item['length']\n            width = placed_item['width']\n            height = placed_item['height']\n\n            if abs(px + l - x) < self.epsilon: adjacency += 1\n            if abs(py + w - y) < self.epsilon: adjacency += 1\n            if abs(pz + h - z) < self.epsilon: adjacency += 1\n            if abs(x + length - px) < self.epsilon: adjacency += 1\n            if abs(y + width - py) < self.epsilon: adjacency += 1\n            if abs(z + height - pz) < self.epsilon: adjacency += 1\n\n        return adjacency",
          "objective": 22.15,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm places items preferring complete filling of trucks, prioritizing volume utilization and minimizing the number of trucks used.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm places items preferring complete filling of trucks, prioritizing volume utilization and minimizing the number of trucks used.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_placement = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n\n        if best_placement:\n            return best_placement['truck_index'], best_placement['item_index'], best_placement['x'], best_placement['y'], best_placement['z'], best_placement['orientation']\n        else:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_placement = None\n        best_score = -1.0\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                for truck_index, truck in enumerate(trucks_in_use):\n                    placement = self._find_placement_in_truck(item, item_index, truck, truck_index, truck_type)\n                    if placement and placement['score'] > best_score:\n                        best_score = placement['score']\n                        best_placement = placement\n\n                new_truck_placement = self._find_placement_in_new_truck(item, item_index, truck_type)\n                if new_truck_placement and new_truck_placement['score'] > best_score:\n                    best_score = new_truck_placement['score']\n                    best_placement = new_truck_placement\n\n        return best_placement\n\n    def _find_placement_in_truck(self, item, item_index, truck, truck_index, truck_type):\n        best_placement = None\n        best_score = -1.0\n\n        for orientation_index, (orientation_id, (l, w, h)) in enumerate(self._get_orientations(item)):\n            potential_positions = self._generate_potential_positions(truck, truck_type, l, w, h)\n            for px, py, pz in potential_positions:\n                if self._is_valid_placement((px, py, pz), (l, w, h), truck_type, truck['occupied_volumes']):\n                    score = self._calculate_placement_score((px, py, pz), (l, w, h), truck_type, truck['occupied_volumes'], item['quantity'])\n                    if score > best_score:\n                        best_score = score\n                        best_placement = {\n                            'truck_index': truck_index,\n                            'item_index': item_index,\n                            'x': px,\n                            'y': py,\n                            'z': pz,\n                            'orientation': orientation_index,\n                            'score': score\n                        }\n        return best_placement\n\n    def _find_placement_in_new_truck(self, item, item_index, truck_type):\n        best_placement = None\n        best_score = -1.0\n        empty_truck = {'occupied_volumes': []}\n\n        for orientation_index, (orientation_id, (l, w, h)) in enumerate(self._get_orientations(item)):\n            if self._is_valid_placement((0.0, 0.0, 0.0), (l, w, h), truck_type, empty_truck['occupied_volumes']):\n                score = self._calculate_placement_score((0.0, 0.0, 0.0), (l, w, h), truck_type, empty_truck['occupied_volumes'], item['quantity'])\n                if score > best_score:\n                    best_score = score\n                    best_placement = {\n                        'truck_index': -1,\n                        'item_index': item_index,\n                        'x': 0.0,\n                        'y': 0.0,\n                        'z': 0.0,\n                        'orientation': orientation_index,\n                        'score': score\n                    }\n        return best_placement\n\n    def _generate_potential_positions(self, truck, truck_type, l, w, h):\n        potential_positions = []\n        occupied_volumes = truck['occupied_volumes']\n        cl, cw, ch = truck_type\n\n        if not occupied_volumes:\n            potential_positions.append((0.0, 0.0, 0.0))\n            return potential_positions\n\n        for placed_item in occupied_volumes:\n            x = placed_item['x']\n            y = placed_item['y']\n            z = placed_item['z']\n            length = placed_item['length']\n            width = placed_item['width']\n            height = placed_item['height']\n\n            new_x = x + length\n            new_y = y + width\n            new_z = z + height\n\n            if new_x + l <= cl + self.epsilon:\n                potential_positions.append((new_x, y, z))\n            if new_y + w <= cw + self.epsilon:\n                potential_positions.append((x, new_y, z))\n            if new_z + h <= ch + self.epsilon:\n                potential_positions.append((x, y, new_z))\n\n        potential_positions.append((0.0, 0.0, 0.0))\n        \n        return potential_positions\n\n    def _calculate_placement_score(self, item_pos, item_dims, container_dims, occupied_volumes, item_quantity):\n        volume_utilization = self._calculate_volume_utilization(item_dims, container_dims)\n        item_priority = item_quantity\n        adjacency_score = self._calculate_adjacency_score(item_pos, item_dims, container_dims, occupied_volumes)\n\n        score = (1.0 * volume_utilization +\n                 0.1 * item_priority +\n                 0.2 * adjacency_score)\n\n        return score\n\n    def _calculate_volume_utilization(self, item_dims, container_dims):\n        item_volume = item_dims[0] * item_dims[1] * item_dims[2]\n        container_volume = container_dims[0] * container_dims[1] * container_dims[2]\n        return item_volume / container_volume\n\n    def _calculate_adjacency_score(self, item_pos, item_dims, container_dims, occupied_volumes):\n        px, py, pz = item_pos\n        l, w, h = item_dims\n        cl, cw, ch = container_dims\n\n        adjacency = 0\n\n        if px == 0.0: adjacency += 1\n        if py == 0.0: adjacency += 1\n        if pz == 0.0: adjacency += 1\n        if px + l >= cl - self.epsilon: adjacency += 1\n        if py + w >= cw - self.epsilon: adjacency += 1\n        if pz + h >= ch - self.epsilon: adjacency += 1\n\n        for placed_item in occupied_volumes:\n            x = placed_item['x']\n            y = placed_item['y']\n            z = placed_item['z']\n            length = placed_item['length']\n            width = placed_item['width']\n            height = placed_item['height']\n\n            if abs(px + l - x) < self.epsilon: adjacency += 1\n            if abs(py + w - y) < self.epsilon: adjacency += 1\n            if abs(pz + h - z) < self.epsilon: adjacency += 1\n            if abs(x + length - px) < self.epsilon: adjacency += 1\n            if abs(y + width - py) < self.epsilon: adjacency += 1\n            if abs(z + height - pz) < self.epsilon: adjacency += 1\n\n        return adjacency",
          "objective": 22.2,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm prioritizes filling the most occupied truck and item type, using a density score and a modified potential positions generator to minimize fragmentation.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes filling the most occupied truck and item type, using a density score and a modified potential positions generator to minimize fragmentation.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_placement = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n\n        if best_placement:\n            return best_placement['truck_index'], best_placement['item_index'], best_placement['x'], best_placement['y'], best_placement['z'], best_placement['orientation']\n        else:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_placement = None\n        best_score = -1.0  # Initialize with negative value for maximization\n\n        truck_density_scores = self._calculate_truck_density_scores(trucks_in_use, truck_type)\n\n        \n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                for truck_index, truck in enumerate(trucks_in_use):\n                    placement = self._find_placement_in_truck(item, item_index, truck, truck_index, truck_type, truck_density_scores[truck_index])\n                    if placement and placement['score'] > best_score:\n                        best_score = placement['score']\n                        best_placement = placement\n\n                new_truck_placement = self._find_placement_in_new_truck(item, item_index, truck_type)\n                if new_truck_placement and new_truck_placement['score'] > best_score:\n                    best_score = new_truck_placement['score']\n                    best_placement = new_truck_placement\n\n        return best_placement\n\n    def _find_placement_in_truck(self, item, item_index, truck, truck_index, truck_type, truck_density_score):\n        best_placement = None\n        best_score = -1.0\n\n        for orientation_index, (orientation_id, (l, w, h)) in enumerate(self._get_orientations(item)):\n            potential_positions = self._generate_potential_positions(truck, truck_type, l, w, h)\n            for px, py, pz in potential_positions:\n                if self._is_valid_placement((px, py, pz), (l, w, h), truck_type, truck['occupied_volumes']):\n                    score = self._calculate_placement_score((px, py, pz), (l, w, h), truck_type, truck['occupied_volumes'], truck_density_score, item['quantity'])\n                    if score > best_score:\n                        best_score = score\n                        best_placement = {\n                            'truck_index': truck_index,\n                            'item_index': item_index,\n                            'x': px,\n                            'y': py,\n                            'z': pz,\n                            'orientation': orientation_index,\n                            'score': score\n                        }\n        return best_placement\n\n    def _find_placement_in_new_truck(self, item, item_index, truck_type):\n        best_placement = None\n        best_score = -1.0\n        empty_truck = {'occupied_volumes': []}\n\n        for orientation_index, (orientation_id, (l, w, h)) in enumerate(self._get_orientations(item)):\n            if self._is_valid_placement((0.0, 0.0, 0.0), (l, w, h), truck_type, empty_truck['occupied_volumes']):\n                score = self._calculate_placement_score((0.0, 0.0, 0.0), (l, w, h), truck_type, empty_truck['occupied_volumes'], 0.0, item['quantity'])\n                if score > best_score:\n                    best_score = score\n                    best_placement = {\n                        'truck_index': -1,\n                        'item_index': item_index,\n                        'x': 0.0,\n                        'y': 0.0,\n                        'z': 0.0,\n                        'orientation': orientation_index,\n                        'score': score\n                    }\n        return best_placement\n\n    def _generate_potential_positions(self, truck, truck_type, l, w, h):\n        potential_positions = []\n        occupied_volumes = truck['occupied_volumes']\n\n        if not occupied_volumes:\n            potential_positions.append((0.0, 0.0, 0.0))\n            return potential_positions\n\n        for placed_item in occupied_volumes:\n            x = placed_item['x']\n            y = placed_item['y']\n            z = placed_item['z']\n            length = placed_item['length']\n            width = placed_item['width']\n            height = placed_item['height']\n\n            potential_positions.append((x + length + self.epsilon, y, z))\n            potential_positions.append((x, y + width + self.epsilon, z))\n            potential_positions.append((x, y, z + height + self.epsilon))\n\n        potential_positions.append((0.0, 0.0, 0.0)) \n\n        return potential_positions\n\n    def _calculate_placement_score(self, item_pos, item_dims, container_dims, occupied_volumes, truck_density_score, item_quantity):\n        volume_utilization = self._calculate_volume_utilization(item_dims, container_dims)\n        item_priority = item_quantity\n\n        fragments_score = self._calculate_fragments_score(item_pos, item_dims, container_dims, occupied_volumes)\n\n        score = (1.0 * truck_density_score +\n                 0.5 * volume_utilization +\n                 0.2 * item_priority -\n                 0.1 * fragments_score)\n\n        return score\n\n    def _calculate_volume_utilization(self, item_dims, container_dims):\n        item_volume = item_dims[0] * item_dims[1] * item_dims[2]\n        container_volume = container_dims[0] * container_dims[1] * container_dims[2]\n        return item_volume / container_volume\n\n    def _calculate_fragments_score(self, item_pos, item_dims, container_dims, occupied_volumes):\n        cl, cw, ch = container_dims\n        px, py, pz = item_pos\n        l, w, h = item_dims\n        \n        fragments = 0\n        \n        if px > self.epsilon: fragments += 1\n        if py > self.epsilon: fragments += 1\n        if pz > self.epsilon: fragments += 1\n        if px + l < cl - self.epsilon: fragments += 1\n        if py + w < cw - self.epsilon: fragments += 1\n        if pz + h < ch - self.epsilon: fragments += 1\n\n        return fragments\n\n    def _calculate_truck_density_scores(self, trucks_in_use, truck_type):\n        truck_density_scores = []\n        container_volume = truck_type[0] * truck_type[1] * truck_type[2]\n        \n        for truck in trucks_in_use:\n            occupied_volume = 0.0\n            for placed_item in truck['occupied_volumes']:\n                occupied_volume += placed_item['length'] * placed_item['width'] * placed_item['height']\n            \n            density_score = occupied_volume / container_volume if container_volume > 0 else 0.0\n            truck_density_scores.append(density_score)\n\n        return truck_density_scores\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _generate_potential_positions(self, truck, truck_type, l, w, h):\n        potential_positions = []\n        occupied_volumes = truck['occupied_volumes']\n        cl, cw, ch = truck_type\n\n        if not occupied_volumes:\n            potential_positions.append((0.0, 0.0, 0.0))\n            return potential_positions\n\n        for placed_item in occupied_volumes:\n            x = placed_item['x']\n            y = placed_item['y']\n            z = placed_item['z']\n            length = placed_item['length']\n            width = placed_item['width']\n            height = placed_item['height']\n\n            new_x = x + length\n            new_y = y + width\n            new_z = z + height\n\n            if new_x + l <= cl + self.epsilon:\n                potential_positions.append((new_x, y, z))\n            if new_y + w <= cw + self.epsilon:\n                potential_positions.append((x, new_y, z))\n            if new_z + h <= ch + self.epsilon:\n                potential_positions.append((x, y, new_z))\n        \n        potential_positions.append((0.0, 0.0, 0.0))\n\n        return potential_positions",
          "objective": 22.3,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     },
     {
          "algorithm": "This algorithm selects items based on a space-filling heuristic considering remaining volume and attempts to place them tightly against existing items or container boundaries to minimize wasted space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm selects items based on a space-filling heuristic considering remaining volume and attempts to place them tightly against existing items or container boundaries to minimize wasted space.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_placement = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n\n        if best_placement:\n            return best_placement['truck_index'], best_placement['item_index'], best_placement['x'], best_placement['y'], best_placement['z'], best_placement['orientation']\n        else:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_placement = None\n        best_score = -1.0\n\n        for item_index in range(len(unplaced_items)):\n            item = unplaced_items[item_index]\n            if item['quantity'] > 0:\n                for truck_index in range(len(trucks_in_use)):\n                    truck = trucks_in_use[truck_index]\n                    placement = self._evaluate_placements_in_truck(item, item_index, truck, truck_index, truck_type)\n                    if placement and placement['score'] > best_score:\n                        best_score = placement['score']\n                        best_placement = placement\n\n                new_truck_placement = self._evaluate_placement_in_new_truck(item, item_index, truck_type)\n                if new_truck_placement and new_truck_placement['score'] > best_score:\n                    best_score = new_truck_placement['score']\n                    best_placement = new_truck_placement\n\n        return best_placement\n\n    def _evaluate_placements_in_truck(self, item, item_index, truck, truck_index, truck_type):\n        best_placement = None\n        best_score = -1.0\n\n        for orientation_index, (orientation_id, (l, w, h)) in enumerate(self._get_orientations(item)):\n            potential_positions = self._generate_potential_positions(truck, truck_type, l, w, h)\n            for px, py, pz in potential_positions:\n                if self._is_valid_placement((px, py, pz), (l, w, h), truck_type, truck['occupied_volumes']):\n                    score = self._calculate_placement_score((px, py, pz), (l, w, h), truck_type, truck['occupied_volumes'])\n                    if score > best_score:\n                        best_score = score\n                        best_placement = {\n                            'truck_index': truck_index,\n                            'item_index': item_index,\n                            'x': px,\n                            'y': py,\n                            'z': pz,\n                            'orientation': orientation_index,\n                            'score': score\n                        }\n        return best_placement\n\n    def _evaluate_placement_in_new_truck(self, item, item_index, truck_type):\n        best_placement = None\n        best_score = -1.0\n        empty_truck = {'occupied_volumes': []}\n\n        for orientation_index, (orientation_id, (l, w, h)) in enumerate(self._get_orientations(item)):\n            if self._is_valid_placement((0.0, 0.0, 0.0), (l, w, h), truck_type, empty_truck['occupied_volumes']):\n                score = self._calculate_placement_score((0.0, 0.0, 0.0), (l, w, h), truck_type, empty_truck['occupied_volumes'])\n                if score > best_score:\n                    best_score = score\n                    best_placement = {\n                        'truck_index': -1,\n                        'item_index': item_index,\n                        'x': 0.0,\n                        'y': 0.0,\n                        'z': 0.0,\n                        'orientation': orientation_index,\n                        'score': score\n                    }\n        return best_placement\n\n    def _generate_potential_positions(self, truck, truck_type, l, w, h):\n        potential_positions = []\n        occupied_volumes = truck['occupied_volumes']\n        cl, cw, ch = truck_type\n\n        if not occupied_volumes:\n            potential_positions.append((0.0, 0.0, 0.0))\n            return potential_positions\n\n        for placed_item in occupied_volumes:\n            x = placed_item['x']\n            y = placed_item['y']\n            z = placed_item['z']\n            length = placed_item['length']\n            width = placed_item['width']\n            height = placed_item['height']\n\n            new_x = x + length\n            new_y = y + width\n            new_z = z + height\n\n            if new_x + l <= cl + self.epsilon:\n                potential_positions.append((new_x, y, z))\n            if new_y + w <= cw + self.epsilon:\n                potential_positions.append((x, new_y, z))\n            if new_z + h <= ch + self.epsilon:\n                potential_positions.append((x, y, new_z))\n\n        potential_positions.append((0.0, 0.0, 0.0))\n        return potential_positions\n\n    def _calculate_placement_score(self, item_pos, item_dims, container_dims, occupied_volumes):\n        volume_utilization = self._calculate_volume_utilization(item_dims, container_dims, occupied_volumes)\n        space_filling_score = self._calculate_space_filling_score(item_pos, item_dims, container_dims, occupied_volumes)\n\n        score = 0.7 * volume_utilization + 0.3 * space_filling_score\n        return score\n\n    def _calculate_volume_utilization(self, item_dims, container_dims, occupied_volumes):\n        item_volume = item_dims[0] * item_dims[1] * item_dims[2]\n        container_volume = container_dims[0] * container_dims[1] * container_dims[2]\n\n        occupied_volume = 0.0\n        for placed_item in occupied_volumes:\n            occupied_volume += placed_item['length'] * placed_item['width'] * placed_item['height']\n\n        total_volume = occupied_volume + item_volume\n        return total_volume / container_volume\n\n    def _calculate_space_filling_score(self, item_pos, item_dims, container_dims, occupied_volumes):\n        px, py, pz = item_pos\n        l, w, h = item_dims\n        cl, cw, ch = container_dims\n\n        touching_sides = 0\n\n        if px <= self.epsilon:\n            touching_sides += 1\n        if py <= self.epsilon:\n            touching_sides += 1\n        if pz <= self.epsilon:\n            touching_sides += 1\n\n        if px + l >= cl - self.epsilon:\n            touching_sides += 1\n        if py + w >= cw - self.epsilon:\n            touching_sides += 1\n        if pz + h >= ch - self.epsilon:\n            touching_sides += 1\n\n        for placed_item in occupied_volumes:\n            x_placed = placed_item['x']\n            y_placed = placed_item['y']\n            z_placed = placed_item['z']\n            l_placed = placed_item['length']\n            w_placed = placed_item['width']\n            h_placed = placed_item['height']\n\n            if abs(px + l - x_placed) <= self.epsilon and (py < y_placed + w_placed and py + w > y_placed) and (pz < z_placed + h_placed and pz + h > z_placed):\n                touching_sides += 1\n            if abs(py + w - y_placed) <= self.epsilon and (px < x_placed + l_placed and px + l > x_placed) and (pz < z_placed + h_placed and pz + h > z_placed):\n                touching_sides += 1\n            if abs(pz + h - z_placed) <= self.epsilon and (px < x_placed + l_placed and px + l > x_placed) and (py < y_placed + w_placed and py + w > y_placed):\n                touching_sides += 1\n            if abs(x_placed + l_placed - px) <= self.epsilon and (py < y_placed + w_placed and py + w > y_placed) and (pz < z_placed + h_placed and pz + h > z_placed):\n                touching_sides += 1\n            if abs(y_placed + w_placed - py) <= self.epsilon and (px < x_placed + l_placed and px + l > x_placed) and (pz < z_placed + h_placed and pz + h > z_placed):\n                touching_sides += 1\n            if abs(z_placed + h_placed - pz) <= self.epsilon and (px < x_placed + l_placed and px + l > x_placed) and (py < y_placed + w_placed and py + w > y_placed):\n                touching_sides += 1\n\n        return touching_sides / (len(occupied_volumes) + 6) if (len(occupied_volumes) + 6) > 0 else 0",
          "objective": 22.35,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]