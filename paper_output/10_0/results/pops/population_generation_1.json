[
     {
          "algorithm": "Select the item with the highest volume, iterate through orientations, find the first available position in existing trucks or a new truck using bottom-left-fill strategy.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select the item with the highest volume, iterate through orientations, find the first available position in existing trucks or a new truck using bottom-left-fill strategy.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        item_type = unplaced_items[item_index]\n\n        truck_index, x, y, z, orientation = self._find_placement(item_type, trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        max_volume = -1\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                volume = item_type['length'] * item_type['width'] * item_type['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n        return best_item_index\n\n    def _find_placement(self, item_type, trucks_in_use, truck_type):\n        for truck_index in range(len(trucks_in_use)):\n            x, y, z, orientation = self._find_position_in_truck(item_type, trucks_in_use[truck_index], truck_type)\n            if x is not None:\n                return truck_index, x, y, z, orientation\n\n        x, y, z, orientation = self._find_position_in_new_truck(item_type, truck_type)\n        return -1, x, y, z, orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n        for orientation, (length, width, height) in orientations:\n            x, y, z = self._find_bottom_left_position(length, width, height, truck_type, occupied_volumes)\n            if x is not None:\n                return x, y, z, orientation\n        return None, None, None, None\n\n    def _find_position_in_new_truck(self, item_type, truck_type):\n        orientations = self._get_orientations(item_type)\n        for orientation, (length, width, height) in orientations:\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                return 0, 0, 0, orientation\n        return None, None, None, None\n    \n    def _find_bottom_left_position(self, length, width, height, container_dims, occupied_volumes):\n        potential_positions = [(0, 0, 0)]\n        \n        for placed_item in occupied_volumes:\n            px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n            pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n            \n            potential_positions.append((px + pl, py, pz))\n            potential_positions.append((px, py + pw, pz))\n            potential_positions.append((px, py, pz + ph))\n\n        for x, y, z in sorted(potential_positions):\n            if self._is_valid_placement((x, y, z), (length, width, height), container_dims, occupied_volumes):\n                return x, y, z\n\n        return None, None, None",
          "objective": 24.7,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Select the item with the largest footprint (area) and attempts to place it using a best-fit heuristic, prioritizing existing trucks and minimizing wasted space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select the item with the largest footprint (area) and attempts to place it using a best-fit heuristic, prioritizing existing trucks and minimizing wasted space.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        item_type = unplaced_items[item_index]\n\n        truck_index, x, y, z, orientation = self._find_best_placement(item_type, trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        max_area = -1\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                area = item_type['length'] * item_type['width']\n                if area > max_area:\n                    max_area = area\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        min_waste = float('inf')\n\n        for truck_index in range(len(trucks_in_use)):\n            x, y, z, orientation, waste = self._find_placement_in_truck(item_type, trucks_in_use[truck_index], truck_type)\n            if x is not None and waste < min_waste:\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                min_waste = waste\n\n        x, y, z, orientation, waste = self._find_placement_in_new_truck(item_type, truck_type)\n        if x is not None and waste < min_waste:\n            best_truck_index = -1\n            best_x = x\n            best_y = y\n            best_z = z\n            best_orientation = orientation\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_placement_in_truck(self, item_type, truck, truck_type):\n        occupied_volumes = truck['occupied_volumes']\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        min_waste = float('inf')\n        \n        for orientation, (length, width, height) in self._get_orientations(item_type):\n            x, y, z = self._find_bottom_left_position(length, width, height, truck_type, occupied_volumes)\n            if x is not None:\n                waste = self._calculate_waste(x, y, z, length, width, height, truck_type)\n                if waste < min_waste:\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n                    min_waste = waste\n\n        if best_x is not None:\n            return best_x, best_y, best_z, best_orientation, min_waste\n        else:\n            return None, None, None, None, float('inf')\n\n    def _find_placement_in_new_truck(self, item_type, truck_type):\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        min_waste = float('inf')\n\n        for orientation, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                waste = self._calculate_waste(0, 0, 0, length, width, height, truck_type)\n                if waste < min_waste:\n                    best_x = 0\n                    best_y = 0\n                    best_z = 0\n                    best_orientation = orientation\n                    min_waste = waste\n\n        if best_x is not None:\n            return best_x, best_y, best_z, best_orientation, min_waste\n        else:\n            return None, None, None, None, float('inf')\n    \n    def _find_bottom_left_position(self, length, width, height, container_dims, occupied_volumes):\n        potential_positions = [(0, 0, 0)]\n        \n        for placed_item in occupied_volumes:\n            px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n            pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n            \n            potential_positions.append((px + pl, py, pz))\n            potential_positions.append((px, py + pw, pz))\n            potential_positions.append((px, py, pz + ph))\n\n        valid_positions = []\n        for x, y, z in sorted(potential_positions):\n            if self._is_valid_placement((x, y, z), (length, width, height), container_dims, occupied_volumes):\n                valid_positions.append((x, y, z))\n        \n        if valid_positions:\n            return valid_positions[0]\n        else:\n            return None, None, None\n    \n    def _calculate_waste(self, x, y, z, length, width, height, container_dims):\n        cl, cw, ch = container_dims\n        return (cl - (x + length)) + (cw - (y + width)) + (ch - (z + height))",
          "objective": 25.25,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Select the item with the smallest footprint area, then place it into viable candidate position that maximizes space utilization, iterating through existing trucks first.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select the item with the smallest footprint area, then place it into viable candidate position that maximizes space utilization, iterating through existing trucks first.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        item_type = unplaced_items[item_index]\n        truck_index, x, y, z, orientation = self._find_best_placement(item_type, trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n    \n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        min_area = float('inf')\n\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                area = item_type['length'] * item_type['width']\n                if area < min_area:\n                    min_area = area\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        max_space_utilization = -1\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            x, y, z, orientation, space_utilization = self._find_position_in_truck(item_type, truck, truck_type)\n            if x is not None and space_utilization > max_space_utilization:\n                max_space_utilization = space_utilization\n                best_truck_index = truck_index\n                best_x, best_y, best_z = x, y, z\n                best_orientation = orientation\n\n        x, y, z, orientation, space_utilization = self._find_position_in_new_truck(item_type, truck_type)\n        if x is not None and space_utilization > max_space_utilization:\n            best_truck_index = -1\n            best_x, best_y, best_z = x, y, z\n            best_orientation = orientation\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        occupied_volumes = truck['occupied_volumes']\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        max_space_utilization = -1\n\n        for orientation, (length, width, height) in self._get_orientations(item_type):\n            x, y, z, space_utilization = self._find_best_position_in_container((length, width, height), truck_type, occupied_volumes)\n            if x is not None and space_utilization > max_space_utilization:\n                max_space_utilization = space_utilization\n                best_x, best_y, best_z = x, y, z\n                best_orientation = orientation\n\n        if best_x is not None:\n            return best_x, best_y, best_z, best_orientation, max_space_utilization\n        else:\n            return None, None, None, None, -1\n\n    def _find_position_in_new_truck(self, item_type, truck_type):\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        max_space_utilization = -1\n\n        for orientation, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                space_utilization = self._evaluate_space_utilization((0, 0, 0), (length, width, height), truck_type, [])\n                if space_utilization > max_space_utilization:\n                    max_space_utilization = space_utilization\n                    best_x, best_y, best_z = 0, 0, 0\n                    best_orientation = orientation\n\n        if best_x is not None:\n            return best_x, best_y, best_z, best_orientation, max_space_utilization\n        else:\n            return None, None, None, None, -1\n\n    def _find_best_position_in_container(self, item_dims, container_dims, occupied_volumes):\n        best_x, best_y, best_z = None, None, None\n        max_space_utilization = -1\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        positions = self._generate_candidate_positions(container_dims, occupied_volumes)\n\n        for x, y, z in positions:\n            if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                space_utilization = self._evaluate_space_utilization((x, y, z), item_dims, container_dims, occupied_volumes)\n                if space_utilization > max_space_utilization:\n                    max_space_utilization = space_utilization\n                    best_x, best_y, best_z = x, y, z\n\n        if best_x is not None:\n            return best_x, best_y, best_z, max_space_utilization\n        else:\n            return None, None, None, -1\n\n    def _generate_candidate_positions(self, container_dims, occupied_volumes):\n        positions = [(0, 0, 0)]\n\n        for item in occupied_volumes:\n            x, y, z = item['x'], item['y'], item['z']\n            l, w, h = item['length'], item['width'], item['height']\n            positions.append((x + l, y, z))\n            positions.append((x, y + w, z))\n            positions.append((x, y, z + h))\n\n        return positions\n\n    def _evaluate_space_utilization(self, item_pos, item_dims, container_dims, occupied_volumes):\n        il, iw, ih = item_dims\n        return il * iw * ih",
          "objective": 27.05,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Select the item with the smallest footprint, iterate through orientations minimizing wasted space, and place it using bottom-left-back fill in the best-fit truck or a new truck.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select the item with the smallest footprint, iterate through orientations minimizing wasted space, and place it using bottom-left-back fill in the best-fit truck or a new truck.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        item_type = unplaced_items[item_index]\n\n        truck_index, x, y, z, orientation = self._find_best_placement(item_type, trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        min_footprint = float('inf')\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                footprint = item_type['length'] * item_type['width']\n                if footprint < min_footprint:\n                    min_footprint = footprint\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        min_wasted_space = float('inf')\n\n        for truck_index in range(len(trucks_in_use)):\n            x, y, z, orientation, wasted_space = self._find_best_position_in_truck(item_type, trucks_in_use[truck_index], truck_type)\n            if x is not None and wasted_space < min_wasted_space:\n                min_wasted_space = wasted_space\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        x, y, z, orientation, wasted_space = self._find_best_position_in_new_truck(item_type, truck_type)\n        if x is not None and wasted_space < min_wasted_space:\n                best_truck_index = -1\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item_type, truck, truck_type):\n        occupied_volumes = truck['occupied_volumes']\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        min_wasted_space = float('inf')\n\n        orientations = self._get_orientations(item_type)\n        for orientation, (length, width, height) in orientations:\n            x, y, z, wasted_space = self._find_bottom_left_back_position(length, width, height, truck_type, occupied_volumes)\n            if x is not None and wasted_space < min_wasted_space:\n                min_wasted_space = wasted_space\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        if best_x is None:\n            return None, None, None, None, float('inf')\n        return best_x, best_y, best_z, best_orientation, min_wasted_space\n\n    def _find_best_position_in_new_truck(self, item_type, truck_type):\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        min_wasted_space = float('inf')\n\n        orientations = self._get_orientations(item_type)\n        for orientation, (length, width, height) in orientations:\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                wasted_space = truck_type[0] * truck_type[1] * truck_type[2] - length * width * height\n                if wasted_space < min_wasted_space:\n                    min_wasted_space = wasted_space\n                    best_x = 0\n                    best_y = 0\n                    best_z = 0\n                    best_orientation = orientation\n\n        if best_x is None:\n            return None, None, None, None, float('inf')\n        return best_x, best_y, best_z, best_orientation, min_wasted_space\n\n    def _find_bottom_left_back_position(self, length, width, height, container_dims, occupied_volumes):\n        potential_positions = [(0, 0, 0)]\n        \n        for placed_item in occupied_volumes:\n            px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n            pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n            \n            potential_positions.append((px + pl, py, pz))\n            potential_positions.append((px, py + pw, pz))\n            potential_positions.append((px, py, pz + ph))\n\n        best_x = None\n        best_y = None\n        best_z = None\n        min_wasted_space = float('inf')\n\n        for x, y, z in sorted(potential_positions):\n            if self._is_valid_placement((x, y, z), (length, width, height), container_dims, occupied_volumes):\n                wasted_space = self._calculate_wasted_space((x, y, z), length, width, height, container_dims, occupied_volumes)\n\n                if wasted_space < min_wasted_space:\n                    min_wasted_space = wasted_space\n                    best_x = x\n                    best_y = y\n                    best_z = z\n\n        if best_x is None:\n            return None, None, None, float('inf')\n        return best_x, best_y, best_z, min_wasted_space\n    \n    def _calculate_wasted_space(self, position, length, width, height, container_dims, occupied_volumes):\n        x, y, z = position\n        container_length, container_width, container_height = container_dims\n        \n        total_wasted_space = 0\n        \n        #Wasted space above the item\n        total_wasted_space += (container_height - (z + height)) * length * width\n        \n        return total_wasted_space",
          "objective": 27.55,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects the item with the largest area (length * width), iterates through orientations, finds the best-fit position in existing trucks or a new truck using a scoring system based on remaining space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item with the largest area (length * width), iterates through orientations, finds the best-fit position in existing trucks or a new truck using a scoring system based on remaining space.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        item_type = unplaced_items[item_index]\n\n        best_truck_index, best_x, best_y, best_z, best_orientation, best_score = self._find_best_placement(item_type, trucks_in_use, truck_type)\n\n        if best_truck_index is None:\n            return None, None, None, None, None, None\n\n        return best_truck_index, item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        max_area = -1\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                area = item_type['length'] * item_type['width']\n                if area > max_area:\n                    max_area = area\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_score = -1\n\n        for truck_index in range(len(trucks_in_use)):\n            x, y, z, orientation, score = self._find_best_position_in_truck(item_type, trucks_in_use[truck_index], truck_type)\n            if x is not None and score > best_score:\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_score = score\n\n        x, y, z, orientation, score = self._find_best_position_in_new_truck(item_type, truck_type)\n        if x is not None and score > best_score:\n            best_truck_index = -1\n            best_x = x\n            best_y = y\n            best_z = z\n            best_orientation = orientation\n            best_score = score\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_best_position_in_truck(self, item_type, truck, truck_type):\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_score = -1\n\n        for orientation, (length, width, height) in orientations:\n            x, y, z, score = self._find_best_bottom_left_position(length, width, height, truck_type, occupied_volumes)\n            if x is not None and score > best_score:\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_score = score\n\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_best_position_in_new_truck(self, item_type, truck_type):\n        orientations = self._get_orientations(item_type)\n        best_orientation = None\n        best_score = -1\n        length_best = None\n        width_best = None\n        height_best = None\n\n        for orientation, (length, width, height) in orientations:\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                score = length * width * height\n                if score > best_score:\n                  best_score = score\n                  length_best = length\n                  width_best = width\n                  height_best = height\n                  best_orientation = orientation\n        if best_orientation is not None:\n          return 0, 0, 0, best_orientation, length_best*width_best*height_best\n        return None, None, None, None, -1\n    \n    def _find_best_bottom_left_position(self, length, width, height, container_dims, occupied_volumes):\n        potential_positions = [(0, 0, 0)]\n        \n        for placed_item in occupied_volumes:\n            px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n            pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n            \n            potential_positions.append((px + pl, py, pz))\n            potential_positions.append((px, py + pw, pz))\n            potential_positions.append((px, py, pz + ph))\n\n        best_x = None\n        best_y = None\n        best_z = None\n        best_score = -1\n        for x, y, z in sorted(potential_positions):\n            if self._is_valid_placement((x, y, z), (length, width, height), container_dims, occupied_volumes):\n                score = self._evaluate_placement((x, y, z), (length, width, height), container_dims, occupied_volumes)\n                if score > best_score:\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_score = score\n\n        return best_x, best_y, best_z, best_score\n\n    def _evaluate_placement(self, item_pos, item_dims, container_dims, occupied_volumes):\n        px, py, pz = item_pos\n        pl, pw, ph = item_dims\n        cl, cw, ch = container_dims\n\n        remaining_space = (cl - (px + pl)) * (cw - (py + pw)) * (ch - (pz + ph))\n        score = 1.0 / (remaining_space + 1e-9)\n        return score",
          "objective": 29.1,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]