[
     {
          "algorithm": "Select an item based on a scoring function combining volume and quantity, iterate through orientations and trucks to find the best placement based on a scoring function that considers space utilization.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select an item based on a scoring function combining volume and quantity, iterate through orientations and trucks to find the best placement based on a scoring function that considers space utilization.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        item_type = unplaced_items[item_index]\n        best_truck_index, best_x, best_y, best_z, best_orientation = self._find_best_placement(item_type, trucks_in_use, truck_type)\n\n        return best_truck_index, item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        best_score = -1\n\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                volume = item_type['length'] * item_type['width'] * item_type['height']\n                quantity = item_type['quantity']\n                score = volume * quantity  # Combine volume and quantity\n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_utilization_score = -1\n\n        for truck_index in range(len(trucks_in_use)):\n            x, y, z, orientation, utilization_score = self._find_position_in_truck(item_type, trucks_in_use[truck_index], truck_type)\n            if x is not None and utilization_score > best_utilization_score:\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_utilization_score = utilization_score\n\n        x, y, z, orientation, utilization_score = self._find_position_in_new_truck(item_type, truck_type)\n        if x is not None and utilization_score > best_utilization_score:\n            best_truck_index = -1\n            best_x = x\n            best_y = y\n            best_z = z\n            best_orientation = orientation\n            best_utilization_score = utilization_score\n        \n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_utilization_score = -1\n        \n        for orientation, (length, width, height) in orientations:\n            x, y, z = self._find_bottom_left_position(length, width, height, truck_type, occupied_volumes)\n            if x is not None:\n                utilization_score = self._evaluate_placement(x, y, z, length, width, height, truck_type, occupied_volumes)\n                if utilization_score > best_utilization_score:\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n                    best_utilization_score = utilization_score\n        return best_x, best_y, best_z, best_orientation, best_utilization_score\n\n    def _find_position_in_new_truck(self, item_type, truck_type):\n        orientations = self._get_orientations(item_type)\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_utilization_score = -1\n        \n        for orientation, (length, width, height) in orientations:\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                utilization_score = self._evaluate_placement(0, 0, 0, length, width, height, truck_type, [])\n                if utilization_score > best_utilization_score:\n                    best_x = 0\n                    best_y = 0\n                    best_z = 0\n                    best_orientation = orientation\n                    best_utilization_score = utilization_score\n        return best_x, best_y, best_z, best_orientation, best_utilization_score\n    \n    def _find_bottom_left_position(self, length, width, height, container_dims, occupied_volumes):\n        potential_positions = [(0, 0, 0)]\n        \n        for placed_item in occupied_volumes:\n            px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n            pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n            \n            potential_positions.append((px + pl, py, pz))\n            potential_positions.append((px, py + pw, pz))\n            potential_positions.append((px, py, pz + ph))\n\n        valid_positions = []\n        for x, y, z in sorted(potential_positions):\n            if self._is_valid_placement((x, y, z), (length, width, height), container_dims, occupied_volumes):\n                valid_positions.append((x, y, z))\n                \n\n        if not valid_positions:\n            return None, None, None\n        \n        return valid_positions[0]\n\n    def _evaluate_placement(self, x, y, z, length, width, height, container_dims, occupied_volumes):\n        volume = length * width * height\n        \n        cl, cw, ch = container_dims\n        \n        remaining_space = (cl - (x + length)) * cw * ch + (cw - (y + width)) * cl * ch + (ch - (z + height)) * cl * cw\n        \n        score = volume / (remaining_space + 1e-9)\n        return score",
          "objective": 22.85,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Select the item with the smallest area footprint, iterate through orientations to minimize height, find the first available position using bottom-left-back strategy in existing trucks or a new truck.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select the item with the smallest area footprint, iterate through orientations to minimize height, find the first available position using bottom-left-back strategy in existing trucks or a new truck.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        item_type = unplaced_items[item_index]\n\n        truck_index, x, y, z, orientation = self._find_placement(item_type, trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        min_area = float('inf')\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                area = item_type['length'] * item_type['width']\n                if area < min_area:\n                    min_area = area\n                    best_item_index = i\n        return best_item_index\n\n    def _find_placement(self, item_type, trucks_in_use, truck_type):\n        for truck_index in range(len(trucks_in_use)):\n            x, y, z, orientation = self._find_position_in_truck(item_type, trucks_in_use[truck_index], truck_type)\n            if x is not None:\n                return truck_index, x, y, z, orientation\n\n        x, y, z, orientation = self._find_position_in_new_truck(item_type, truck_type)\n        return -1, x, y, z, orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        occupied_volumes = truck['occupied_volumes']\n        best_orientation = None\n        best_x = None\n        best_y = None\n        best_z = None\n        min_height = float('inf')\n\n        orientations = self._get_orientations(item_type)\n        for orientation, (length, width, height) in orientations:\n            x, y, z = self._find_bottom_left_back_position(length, width, height, truck_type, occupied_volumes)\n            if x is not None:\n                if height < min_height:\n                    min_height = height\n                    best_orientation = orientation\n                    best_x = x\n                    best_y = y\n                    best_z = z\n\n        if best_x is not None:\n            return best_x, best_y, best_z, best_orientation\n        return None, None, None, None\n\n    def _find_position_in_new_truck(self, item_type, truck_type):\n        best_orientation = None\n        min_height = float('inf')\n        orientations = self._get_orientations(item_type)\n        for orientation, (length, width, height) in orientations:\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                if height < min_height:\n                    min_height = height\n                    best_orientation = orientation\n        if best_orientation is not None:\n            return 0, 0, 0, best_orientation\n        return None, None, None, None\n    \n    def _find_bottom_left_back_position(self, length, width, height, container_dims, occupied_volumes):\n        potential_positions = [(0, 0, 0)]\n        \n        for placed_item in occupied_volumes:\n            px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n            pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n            \n            potential_positions.append((px + pl, py, pz))\n            potential_positions.append((px, py + pw, pz))\n            potential_positions.append((px, py, pz + ph))\n        \n        potential_positions.sort(key=lambda pos: (pos[2], pos[1], pos[0]))\n\n        for x, y, z in potential_positions:\n            if self._is_valid_placement((x, y, z), (length, width, height), container_dims, occupied_volumes):\n                return x, y, z\n\n        return None, None, None",
          "objective": 23.6,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Select the item with the smallest area footprint, prioritize orientations with minimum height, and use bottom-left-fill, favoring positions closer to the origin.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select the item with the smallest area footprint, prioritize orientations with minimum height, and use bottom-left-fill, favoring positions closer to the origin.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        item_type = unplaced_items[item_index]\n\n        truck_index, x, y, z, orientation = self._find_placement(item_type, trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        min_area = float('inf')\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                area = item_type['length'] * item_type['width']\n                if area < min_area:\n                    min_area = area\n                    best_item_index = i\n        return best_item_index\n\n    def _find_placement(self, item_type, trucks_in_use, truck_type):\n        for truck_index in range(len(trucks_in_use)):\n            x, y, z, orientation = self._find_position_in_truck(item_type, trucks_in_use[truck_index], truck_type)\n            if x is not None:\n                return truck_index, x, y, z, orientation\n\n        x, y, z, orientation = self._find_position_in_new_truck(item_type, truck_type)\n        return -1, x, y, z, orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_best_orientations(item_type)\n        for orientation, (length, width, height) in orientations:\n            x, y, z = self._find_bottom_left_position(length, width, height, truck_type, occupied_volumes)\n            if x is not None:\n                return x, y, z, orientation\n        return None, None, None, None\n\n    def _find_position_in_new_truck(self, item_type, truck_type):\n        orientations = self._get_best_orientations(item_type)\n        for orientation, (length, width, height) in orientations:\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                return 0, 0, 0, orientation\n        return None, None, None, None\n\n    def _get_best_orientations(self, item_type):\n        L, W, H = item_type['length'], item_type['width'], item_type['height']\n        orientations = [\n            (0, (L, W, H)), (1, (L, H, W)), (2, (W, L, H)),\n            (3, (W, H, L)), (4, (H, L, W)), (5, (H, W, L))\n        ]\n        return sorted(orientations, key=lambda x: x[1][2])\n\n    def _find_bottom_left_position(self, length, width, height, container_dims, occupied_volumes):\n        potential_positions = [(0, 0, 0)]\n        \n        for placed_item in occupied_volumes:\n            px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n            pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n            \n            potential_positions.append((px + pl, py, pz))\n            potential_positions.append((px, py + pw, pz))\n            potential_positions.append((px, py, pz + ph))\n\n        def position_sort_key(pos):\n            x, y, z = pos\n            return x**2 + y**2 + z**2\n\n        for x, y, z in sorted(potential_positions, key=position_sort_key):\n            if self._is_valid_placement((x, y, z), (length, width, height), container_dims, occupied_volumes):\n                return x, y, z\n\n        return None, None, None",
          "objective": 23.65,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Iteratively place items with the largest area of their two smallest dimensions, prioritizing compact arrangements and using a skyline-based positioning strategy.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Iteratively place items with the largest area of their two smallest dimensions, prioritizing compact arrangements and using a skyline-based positioning strategy.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        item_type = unplaced_items[item_index]\n        truck_index, x, y, z, orientation = self._find_best_placement(item_type, trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        max_area = -1\n\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                dims = sorted([item_type['length'], item_type['width'], item_type['height']])\n                area = dims[0] * dims[1]\n                if area > max_area:\n                    max_area = area\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_compactness = -1\n\n        for truck_index in range(len(trucks_in_use)):\n            x, y, z, orientation, compactness = self._find_position_in_truck(item_type, trucks_in_use[truck_index], truck_type)\n            if x is not None and compactness > best_compactness:\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_compactness = compactness\n\n        x, y, z, orientation, compactness = self._find_position_in_new_truck(item_type, truck_type)\n        if x is not None and compactness > best_compactness:\n            best_truck_index = -1\n            best_x = x\n            best_y = y\n            best_z = z\n            best_orientation = orientation\n            best_compactness = compactness\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_compactness = -1\n\n        for orientation, (length, width, height) in orientations:\n            x, y, z = self._find_skyline_position(length, width, height, truck_type, occupied_volumes)\n            if x is not None:\n                compactness = self._evaluate_compactness(x, y, z, length, width, height, truck_type, occupied_volumes)\n                if compactness > best_compactness:\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n                    best_compactness = compactness\n        return best_x, best_y, best_z, best_orientation, best_compactness\n\n    def _find_position_in_new_truck(self, item_type, truck_type):\n        orientations = self._get_orientations(item_type)\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_compactness = -1\n\n        for orientation, (length, width, height) in orientations:\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                compactness = self._evaluate_compactness(0, 0, 0, length, width, height, truck_type, [])\n                if compactness > best_compactness:\n                    best_x = 0\n                    best_y = 0\n                    best_z = 0\n                    best_orientation = orientation\n                    best_compactness = compactness\n        return best_x, best_y, best_z, best_orientation, best_compactness\n\n    def _find_skyline_position(self, length, width, height, container_dims, occupied_volumes):\n        best_x, best_y, best_z = None, None, None\n\n        cl, cw, ch = container_dims\n        \n        for x in range(0, int(cl - length + 1)):\n\n            for y in range(0, int(cw - width + 1)):\n                \n                z = 0\n                max_z = 0\n\n                \n                valid_z = True\n                for placed_item in occupied_volumes:\n                  if (placed_item['x'] < x + length and placed_item['x'] + placed_item['length'] > x and\n                      placed_item['y'] < y + width and placed_item['y'] + placed_item['width'] > y):\n                    max_z = max(max_z, placed_item['z'] + placed_item['height'])\n                    \n                z = max_z\n                \n                if self._is_valid_placement((x, y, z), (length, width, height), container_dims, occupied_volumes):\n                    \n                    if best_x is None:\n                      best_x, best_y, best_z = x, y, z\n                    \n                    \n                    return x, y, z\n        return None, None, None\n\n    def _evaluate_compactness(self, x, y, z, length, width, height, container_dims, occupied_volumes):\n        cl, cw, ch = container_dims\n        placed_volume = length * width * height\n        total_volume = cl * cw * ch\n\n        return placed_volume / total_volume\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_skyline_position(self, length, width, height, container_dims, occupied_volumes):\n        best_x, best_y, best_z = None, None, None\n\n        cl, cw, ch = container_dims\n\n        for x in range(0, int(cl - length + 1)):\n            for y in range(0, int(cw - width + 1)):\n                z = 0\n                max_z = 0\n\n                for placed_item in occupied_volumes:\n                    if (placed_item['x'] < x + length and placed_item['x'] + placed_item['length'] > x and\n                        placed_item['y'] < y + width and placed_item['y'] + placed_item['width'] > y):\n                        max_z = max(max_z, placed_item['z'] + placed_item['height'])\n\n                z = max_z\n\n                if z + height <= ch and self._is_valid_placement((x, y, z), (length, width, height), container_dims, occupied_volumes):\n                    if best_x is None:\n                        best_x, best_y, best_z = x, y, z\n\n                    return x, y, z\n        return None, None, None\nimport numpy as np\n\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_skyline_position(self, length, width, height, container_dims, occupied_volumes):\n        cl, cw, ch = container_dims\n        potential_positions = []\n\n        if not occupied_volumes:\n            if self._is_valid_placement((0, 0, 0), (length, width, height), container_dims, occupied_volumes):\n                return 0, 0, 0\n            else:\n                return None, None, None\n\n        for placed_item in occupied_volumes:\n            px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n            pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n\n            potential_positions.append((px + pl, py, pz))\n            potential_positions.append((px, py + pw, pz))\n            potential_positions.append((px, py, pz + ph))\n        \n        for x, y, z in sorted(potential_positions):\n            if self._is_valid_placement((x, y, z), (length, width, height), container_dims, occupied_volumes):\n                return x, y, z\n        return None, None, None",
          "objective": 24.35,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     },
     {
          "algorithm": "Select item based on a volume-to-surface area ratio and places it in the best-fit position minimizing wasted space, prioritizing filling existing trucks up to a target utilization.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select item based on a volume-to-surface area ratio and places it in the best-fit position minimizing wasted space, prioritizing filling existing trucks up to a target utilization.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        item_type = unplaced_items[item_index]\n        best_truck_index, best_x, best_y, best_z, best_orientation = self._find_best_placement(item_type, trucks_in_use, truck_type)\n\n        return best_truck_index, item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        best_score = -1\n\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                volume = item_type['length'] * item_type['width'] * item_type['height']\n                surface_area = 2 * (item_type['length'] * item_type['width'] +\n                                     item_type['length'] * item_type['height'] +\n                                     item_type['width'] * item_type['height'])\n                if surface_area == 0:\n                    score = 0\n                else:\n                    score = volume / surface_area\n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_wasted_space = float('inf')\n        target_utilization = 0.9\n\n        for truck_index in range(len(trucks_in_use)):\n            truck = trucks_in_use[truck_index]\n            current_utilization = self._calculate_utilization(truck['occupied_volumes'], truck_type)\n            if current_utilization < target_utilization:\n                x, y, z, orientation, wasted_space = self._find_position_in_truck(item_type, truck, truck_type)\n                if x is not None and wasted_space < best_wasted_space:\n                    best_truck_index = truck_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n                    best_wasted_space = wasted_space\n\n        x, y, z, orientation, wasted_space = self._find_position_in_new_truck(item_type, truck_type)\n        if x is not None and wasted_space < best_wasted_space:\n            best_truck_index = -1\n            best_x = x\n            best_y = y\n            best_z = z\n            best_orientation = orientation\n            best_wasted_space = wasted_space\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_wasted_space = float('inf')\n\n        for orientation, (length, width, height) in orientations:\n            x, y, z = self._find_bottom_left_position(length, width, height, truck_type, occupied_volumes)\n            if x is not None:\n                wasted_space = self._evaluate_placement(x, y, z, length, width, height, truck_type, occupied_volumes)\n                if wasted_space < best_wasted_space:\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n                    best_wasted_space = wasted_space\n        return best_x, best_y, best_z, best_orientation, best_wasted_space\n\n    def _find_position_in_new_truck(self, item_type, truck_type):\n        orientations = self._get_orientations(item_type)\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_wasted_space = float('inf')\n\n        for orientation, (length, width, height) in orientations:\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                wasted_space = self._evaluate_placement(0, 0, 0, length, width, height, truck_type, [])\n                if wasted_space < best_wasted_space:\n                    best_x = 0\n                    best_y = 0\n                    best_z = 0\n                    best_orientation = orientation\n                    best_wasted_space = wasted_space\n        return best_x, best_y, best_z, best_orientation, best_wasted_space\n\n    def _find_bottom_left_position(self, length, width, height, container_dims, occupied_volumes):\n        potential_positions = [(0, 0, 0)]\n        \n        for placed_item in occupied_volumes:\n            px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n            pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n            \n            potential_positions.append((px + pl, py, pz))\n            potential_positions.append((px, py + pw, pz))\n            potential_positions.append((px, py, pz + ph))\n\n        valid_positions = []\n        for x, y, z in sorted(potential_positions):\n            if self._is_valid_placement((x, y, z), (length, width, height), container_dims, occupied_volumes):\n                valid_positions.append((x, y, z))\n                \n\n        if not valid_positions:\n            return None, None, None\n        \n        return valid_positions[0]\n\n    def _evaluate_placement(self, x, y, z, length, width, height, container_dims, occupied_volumes):\n        volume = length * width * height\n        \n        cl, cw, ch = container_dims\n        \n        wasted_space = (cl * cw * ch) - volume\n        for placed_item in occupied_volumes:\n            wasted_space -= (placed_item['length'] * placed_item['width'] * placed_item['height'])\n        return wasted_space\n\n    def _calculate_utilization(self, occupied_volumes, container_dims):\n        total_volume = 0\n        for item in occupied_volumes:\n            total_volume += item['length'] * item['width'] * item['height']\n        container_volume = container_dims[0] * container_dims[1] * container_dims[2]\n        if container_volume == 0:\n            return 0\n        return total_volume / container_volume",
          "objective": 24.45,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]