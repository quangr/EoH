[
     {
          "algorithm": "Selects the item with the largest volume ratio to the container, finds the best orientation, and places it in the best available position in an existing or new truck.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item with the largest volume ratio to the container, finds the best orientation, and places it in the best available position in an existing or new truck.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        max_volume_ratio = -1\n\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                for truck_index, truck in enumerate(trucks_in_use):\n                    x, y, z, orientation, volume_ratio = self._find_placement_in_truck(item_type, truck, truck_type)\n                    if volume_ratio > max_volume_ratio:\n                        max_volume_ratio = volume_ratio\n                        best_truck_index = truck_index\n                        best_item_index = item_index\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation\n                \n                new_truck_x, new_truck_y, new_truck_z, new_truck_orientation, new_truck_volume_ratio = self._find_placement_in_new_truck(item_type, truck_type)\n                if new_truck_volume_ratio > max_volume_ratio:\n                    max_volume_ratio = new_truck_volume_ratio\n                    best_truck_index = -1\n                    best_item_index = item_index\n                    best_x = new_truck_x\n                    best_y = new_truck_y\n                    best_z = new_truck_z\n                    best_orientation = new_truck_orientation\n        \n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_placement_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        max_volume_ratio = -1\n        \n        for orientation_index, (orientation_id, (length, width, height)) in enumerate(self._get_orientations(item_type)):\n            \n            x, y, z = self._find_position_in_truck(item_type, (length, width, height), truck, truck_type)\n            if x != -1:\n                item_volume = length * width * height\n                truck_volume = truck_type[0] * truck_type[1] * truck_type[2]\n                volume_ratio = item_volume / truck_volume\n                \n                if volume_ratio > max_volume_ratio:\n                    max_volume_ratio = volume_ratio\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation_index\n        \n        return best_x, best_y, best_z, best_orientation, max_volume_ratio\n    \n    def _find_placement_in_new_truck(self, item_type, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        max_volume_ratio = -1\n\n        for orientation_index, (orientation_id, (length, width, height)) in enumerate(self._get_orientations(item_type)):\n            \n            x, y, z = 0, 0, 0\n            if self._is_within_container_bounds((x, y, z), (length, width, height), truck_type):\n                item_volume = length * width * height\n                truck_volume = truck_type[0] * truck_type[1] * truck_type[2]\n                volume_ratio = item_volume / truck_volume\n                \n                if volume_ratio > max_volume_ratio:\n                    max_volume_ratio = volume_ratio\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation_index\n        \n        return best_x, best_y, best_z, best_orientation, max_volume_ratio\n    \n    def _find_position_in_truck(self, item_type, item_dims, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n        \n        cl, cw, ch = container_dims\n        pl, pw, ph = item_dims\n\n        for x in np.arange(0, cl, 1):\n            for y in np.arange(0, cw, 1):\n                for z in np.arange(0, ch, 1):\n                    \n                    if self._is_valid_placement((x, y, z), (pl, pw, ph), container_dims, occupied_volumes):\n                        return x, y, z\n        return -1, -1, -1\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_position_in_truck(self, item_type, item_dims, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n        \n        cl, cw, ch = container_dims\n        pl, pw, ph = item_dims\n\n        for x in np.arange(0, cl - pl + self.epsilon, 1):\n            for y in np.arange(0, cw - pw + self.epsilon, 1):\n                for z in np.arange(0, ch - ph + self.epsilon, 1):\n                    \n                    if self._is_valid_placement((x, y, z), (pl, pw, ph), container_dims, occupied_volumes):\n                        return x, y, z\n        return -1, -1, -1\nimport numpy as np\n\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_position_in_truck(self, item_type, item_dims, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n        \n        cl, cw, ch = container_dims\n        pl, pw, ph = item_dims\n\n        step_size = max(pl, pw, ph)\n        if step_size > 5:\n            step_size = 5\n        elif step_size < 1:\n            step_size = 1\n\n        for x in np.arange(0, cl - pl + self.epsilon, step_size):\n            for y in np.arange(0, cw - pw + self.epsilon, step_size):\n                for z in np.arange(0, ch - ph + self.epsilon, step_size):\n                    \n                    if self._is_valid_placement((x, y, z), (pl, pw, ph), container_dims, occupied_volumes):\n                        return x, y, z\n        return -1, -1, -1\nimport numpy as np\n\nclass AlgorithmFIX3(AlgorithmFIX2):\n    def _find_position_in_truck(self, item_type, item_dims, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n        \n        cl, cw, ch = container_dims\n        pl, pw, ph = item_dims\n\n        x_coords = [0]\n        y_coords = [0]\n        z_coords = [0]\n\n        for volume in occupied_volumes:\n            x_coords.append(volume['x'] + volume['length'])\n            y_coords.append(volume['y'] + volume['width'])\n            z_coords.append(volume['z'] + volume['height'])\n\n        x_coords = sorted(list(set(x_coords)))\n        y_coords = sorted(list(set(y_coords)))\n        z_coords = sorted(list(set(z_coords)))\n\n        for x in x_coords:\n            if x + pl > cl:\n                continue\n            for y in y_coords:\n                if y + pw > cw:\n                    continue\n                for z in z_coords:\n                    if z + ph > ch:\n                        continue\n                            \n                    if self._is_valid_placement((x, y, z), (pl, pw, ph), container_dims, occupied_volumes):\n                        return x, y, z\n        return -1, -1, -1",
          "objective": 24.7,
          "other_inf": null,
          "class_name": "AlgorithmFIX3"
     },
     {
          "algorithm": "Iterate through trucks, and if no space is found, add truck; iterate through items and orientations, and place the item that maximizes container fill.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Iterate through trucks, and if no space is found, add truck; iterate through items and orientations, and place the item that maximizes container fill.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index = -1\n        item_index = -1\n        x = 0.0\n        y = 0.0\n        z = 0.0\n        orientation = -1\n        best_fill_ratio = -1.0\n\n        for ti, truck in enumerate(trucks_in_use):\n            for ii, item_type in enumerate(unplaced_items):\n                if item_type['quantity'] > 0:\n                    for orient, dims in self._get_orientations(item_type):\n                        l, w, h = dims\n                        positions = self._find_valid_positions(truck, truck_type, l, w, h)\n                        for px, py, pz in positions:\n                            fill_ratio = self._evaluate_placement(px, py, pz, l, w, h, truck_type)\n                            if fill_ratio > best_fill_ratio:\n                                best_fill_ratio = fill_ratio\n                                truck_index = ti\n                                item_index = ii\n                                x = px\n                                y = py\n                                z = pz\n                                orientation = orient\n\n        if truck_index == -1:\n            truck_index = len(trucks_in_use)\n            for ii, item_type in enumerate(unplaced_items):\n                if item_type['quantity'] > 0:\n                    for orient, dims in self._get_orientations(item_type):\n                        l, w, h = dims\n                        fill_ratio = self._evaluate_placement(0, 0, 0, l, w, h, truck_type)\n                        if fill_ratio > best_fill_ratio:\n                            best_fill_ratio = fill_ratio\n                            truck_index = -1\n                            item_index = ii\n                            x = 0.0\n                            y = 0.0\n                            z = 0.0\n                            orientation = orient\n        \n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_valid_positions(self, truck, truck_type, l, w, h):\n        container_length, container_width, container_height = truck_type\n        occupied_volumes = truck['occupied_volumes']\n        positions = []\n        \n        if not occupied_volumes:\n            return [(0.0, 0.0, 0.0)]\n\n        # Find smallest x, y, z\n        for item in occupied_volumes:\n            new_x = item['x'] + item['length']\n            new_y = item['y'] + item['width']\n            new_z = item['z'] + item['height']\n\n            if new_x >=0.0 - self.epsilon and new_x + l <= container_length + self.epsilon: \n                if self._is_valid_placement((new_x, item['y'], item['z']), (l,w,h), truck_type, occupied_volumes):\n                    positions.append((new_x, item['y'], item['z']))\n            \n            if new_y >= 0.0 - self.epsilon and new_y + w <= container_width + self.epsilon:\n                if self._is_valid_placement((item['x'], new_y, item['z']), (l,w,h), truck_type, occupied_volumes):\n                    positions.append((item['x'], new_y, item['z']))\n\n            if new_z >= 0.0 - self.epsilon and new_z + h <= container_height + self.epsilon:\n                if self._is_valid_placement((item['x'], item['y'], new_z), (l,w,h), truck_type, occupied_volumes):\n                    positions.append((item['x'], item['y'], new_z))\n        \n        positions.append((0.0, 0.0, 0.0))\n\n        valid_positions = []\n        for px, py, pz in positions:\n            if self._is_valid_placement((px, py, pz), (l,w,h), truck_type, occupied_volumes):\n                valid_positions.append((px, py, pz))\n        return valid_positions\n\n    def _evaluate_placement(self, x, y, z, l, w, h, truck_type):\n        container_length, container_width, container_height = truck_type\n        volume_item = l * w * h\n        volume_container = container_length * container_width * container_height\n        return volume_item / volume_container\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_valid_positions(self, truck, truck_type, l, w, h):\n        container_length, container_width, container_height = truck_type\n        occupied_volumes = truck['occupied_volumes']\n        positions = []\n\n        if not occupied_volumes:\n            return [(0.0, 0.0, 0.0)]\n\n        valid_positions = set()\n\n        for item in occupied_volumes:\n            new_x = item['x'] + item['length']\n            new_y = item['y'] + item['width']\n            new_z = item['z'] + item['height']\n\n            if new_x >= 0.0 - self.epsilon and new_x + l <= container_length + self.epsilon:\n                if self._is_valid_placement((new_x, item['y'], item['z']), (l, w, h), truck_type, occupied_volumes):\n                    valid_positions.add((new_x, item['y'], item['z']))\n\n            if new_y >= 0.0 - self.epsilon and new_y + w <= container_width + self.epsilon:\n                if self._is_valid_placement((item['x'], new_y, item['z']), (l, w, h), truck_type, occupied_volumes):\n                    valid_positions.add((item['x'], new_y, item['z']))\n\n            if new_z >= 0.0 - self.epsilon and new_z + h <= container_height + self.epsilon:\n                if self._is_valid_placement((item['x'], item['y'], new_z), (l, w, h), truck_type, occupied_volumes):\n                    valid_positions.add((item['x'], item['y'], new_z))\n\n        if self._is_valid_placement((0.0, 0.0, 0.0), (l,w,h), truck_type, occupied_volumes):\n            valid_positions.add((0.0, 0.0, 0.0))\n\n        return list(valid_positions)\nimport numpy as np\n\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index = -1\n        item_index = -1\n        x = 0.0\n        y = 0.0\n        z = 0.0\n        orientation = -1\n        best_fill_ratio = -1.0\n\n        for ti, truck in enumerate(trucks_in_use):\n            for ii, item_type in enumerate(unplaced_items):\n                if item_type['quantity'] > 0:\n                    for orient, dims in self._get_orientations(item_type):\n                        l, w, h = dims\n                        positions = self._find_valid_positions(truck, truck_type, l, w, h)\n                        for px, py, pz in positions:\n                            if self._is_within_container_bounds((px, py, pz), (l, w, h), truck_type):\n                                fill_ratio = self._evaluate_placement(px, py, pz, l, w, h, truck_type)\n                                if fill_ratio > best_fill_ratio:\n                                    best_fill_ratio = fill_ratio\n                                    truck_index = ti\n                                    item_index = ii\n                                    x = px\n                                    y = py\n                                    z = pz\n                                    orientation = orient\n\n        if truck_index == -1:\n            truck_index = len(trucks_in_use)\n            for ii, item_type in enumerate(unplaced_items):\n                if item_type['quantity'] > 0:\n                    for orient, dims in self._get_orientations(item_type):\n                        l, w, h = dims\n                        if self._is_within_container_bounds((0.0, 0.0, 0.0), (l, w, h), truck_type):\n                            fill_ratio = self._evaluate_placement(0, 0, 0, l, w, h, truck_type)\n                            if fill_ratio > best_fill_ratio:\n                                best_fill_ratio = fill_ratio\n                                truck_index = -1\n                                item_index = ii\n                                x = 0.0\n                                y = 0.0\n                                z = 0.0\n                                orientation = orient\n\n        return truck_index, item_index, x, y, z, orientation",
          "objective": 24.75,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     },
     {
          "algorithm": "Chooses the item with the largest volume and attempts to place it using a bottom-left-fill heuristic, selecting the placement that minimizes wasted space in the truck.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Chooses the item with the largest volume and attempts to place it using a bottom-left-fill heuristic, selecting the placement that minimizes wasted space in the truck.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index = -1\n        item_index = -1\n        x, y, z = 0, 0, 0\n        orientation = 0\n\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, 0, 0, 0, 0\n\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items[item_index], trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n        return best_item_index\n    \n    def _find_best_placement(self, item, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = 0\n        min_waste = float('inf')\n\n        for truck_index in range(len(trucks_in_use) + 1):\n            if truck_index == len(trucks_in_use):\n                occupied_volumes = []\n            else:\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n            \n            for orientation, dims in self._get_orientations(item):\n                length, width, height = dims\n                \n                possible_positions = self._get_possible_positions(truck_type, occupied_volumes, length, width, height)\n                \n                for x, y, z in possible_positions:\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                        waste = self._calculate_waste(truck_type, occupied_volumes, (x, y, z), (length, width, height))\n                        \n                        if waste < min_waste:\n                            min_waste = waste\n                            best_truck_index = truck_index\n                            best_x, best_y, best_z = x, y, z\n                            best_orientation = orientation\n        \n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _get_possible_positions(self, container_dims, occupied_volumes, item_length, item_width, item_height):\n        positions = set()\n        positions.add((0, 0, 0))\n\n        for placed_item in occupied_volumes:\n            positions.add((placed_item['x'] + placed_item['length'], placed_item['y'], placed_item['z']))\n            positions.add((placed_item['x'], placed_item['y'] + placed_item['width'], placed_item['z']))\n            positions.add((placed_item['x'], placed_item['y'], placed_item['z'] + placed_item['height']))\n\n        valid_positions = []\n        for x, y, z in positions:\n             if x + item_length <= container_dims[0] and y + item_width <= container_dims[1] and z + item_height <= container_dims[2]: \n                valid_positions.append((x,y,z))\n\n        return valid_positions\n    \n    def _calculate_waste(self, container_dims, occupied_volumes, item_pos, item_dims):\n        container_volume = container_dims[0] * container_dims[1] * container_dims[2]\n        occupied_volume = 0\n        for placed_item in occupied_volumes:\n            occupied_volume += placed_item['length'] * placed_item['width'] * placed_item['height']\n        \n        occupied_volume += item_dims[0] * item_dims[1] * item_dims[2]\n\n        return container_volume - occupied_volume\nclass AlgorithmFIX1(Algorithm):\n    def _find_best_placement(self, item, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = 0\n        min_waste = float('inf')\n\n        for truck_index in range(len(trucks_in_use) + 1):\n            if truck_index == len(trucks_in_use):\n                occupied_volumes = []\n            else:\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n            \n            for orientation, dims in self._get_orientations(item):\n                length, width, height = dims\n                \n                possible_positions = self._get_possible_positions(truck_type, occupied_volumes, length, width, height)\n                \n                for x, y, z in possible_positions:\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                        waste = self._calculate_waste(truck_type, occupied_volumes, (x, y, z), (length, width, height))\n                        \n                        if waste < min_waste:\n                            min_waste = waste\n                            best_truck_index = truck_index\n                            best_x, best_y, best_z = x, y, z\n                            best_orientation = orientation\n        \n        if best_truck_index == len(trucks_in_use):\n            best_truck_index = -1\n        \n        return best_truck_index, best_x, best_y, best_z, best_orientation",
          "objective": 25.0,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     },
     {
          "algorithm": "Greedily places the item with the most remaining quantity into the lowest available corner of the most promising truck, considering all orientations and adding a new truck if necessary.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Greedily places the item with the most remaining quantity into the lowest available corner of the most promising truck, considering all orientations and adding a new truck if necessary.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index = -1\n        item_index = -1\n        x, y, z = 0.0, 0.0, 0.0\n        orientation = 0\n\n        best_item_index = self._select_item(unplaced_items)\n\n        if best_item_index is not None:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._find_best_placement(\n                unplaced_items[best_item_index], trucks_in_use, truck_type\n            )\n\n            if best_truck_index == -1:\n                truck_index = -1\n                item_index = best_item_index\n                x, y, z = best_x, best_y, best_z\n                orientation = best_orientation\n            else:\n                truck_index = best_truck_index\n                item_index = best_item_index\n                x, y, z = best_x, best_y, best_z\n                orientation = best_orientation\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        max_quantity = -1\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > max_quantity:\n                max_quantity = item['quantity']\n                best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, item_to_place, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0.0, 0.0, 0.0\n        best_orientation = 0\n        min_z = float('inf')\n\n        for truck_index in range(len(trucks_in_use)):\n            occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n            for orientation, dims in self._get_orientations(item_to_place):\n                l, w, h = dims\n                x, y, z = self._find_bottom_left_back_position(truck_type, dims, occupied_volumes)\n                \n                if self._is_valid_placement((x, y, z), (l, w, h), truck_type, occupied_volumes) and z < min_z :\n                    best_truck_index = truck_index\n                    best_x, best_y, best_z = x, y, z\n                    best_orientation = orientation\n                    min_z = z\n\n        if best_truck_index == -1:\n            for orientation, dims in self._get_orientations(item_to_place):\n                l, w, h = dims\n                \n                if self._is_within_container_bounds((0.0, 0.0, 0.0), (l, w, h), truck_type) :\n                    best_truck_index = -1\n                    best_x, best_y, best_z = 0.0, 0.0, 0.0\n                    best_orientation = orientation\n                    break\n                \n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_bottom_left_back_position(self, container_dims, item_dims, occupied_volumes):\n            \n        cl, cw, ch = container_dims\n        l, w, h = item_dims\n        \n        x, y, z = 0.0, 0.0, 0.0\n        \n        placed = False\n        \n        \n        x_positions = [0.0]\n        y_positions = [0.0]\n        z_positions = [0.0]\n        for placed_item in occupied_volumes:\n            x_positions.append(placed_item['x'] + placed_item['length'])\n            y_positions.append(placed_item['y'] + placed_item['width'])\n            z_positions.append(placed_item['z'] + placed_item['height'])\n            x_positions.append(placed_item['x'])\n            y_positions.append(placed_item['y'])\n            z_positions.append(placed_item['z'])\n            \n        x_positions = sorted(list(set(x_positions)))\n        y_positions = sorted(list(set(y_positions)))\n        z_positions = sorted(list(set(z_positions)))\n        \n        for z_pos in z_positions:\n            for y_pos in y_positions:\n                for x_pos in x_positions:\n                    \n                    if x_pos + l <= cl and y_pos + w <= cw and z_pos + h <= ch:\n                        valid_placement = True\n                        for placed_item in occupied_volumes:\n                            placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                            placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n\n                            if self._check_overlap_3d((x_pos,y_pos,z_pos), item_dims, placed_item_pos, placed_item_dims) :\n                                valid_placement = False\n                                break\n                        if valid_placement:\n                            x, y, z = x_pos, y_pos, z_pos\n                            placed = True\n                            return x,y,z\n        \n        return 0.0, 0.0, 0.0",
          "objective": 25.5,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Iterate through unplaced items, try all orientations and positions in existing trucks, if no placement is found, create a new truck.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Iterate through unplaced items, try all orientations and positions in existing trucks, if no placement is found, create a new truck.}\n    \n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0: \n                for truck_index, truck in enumerate(trucks_in_use):\n                    x, y, z, orientation = self._find_position_in_truck(item_type, truck, truck_type)\n                    if x != -1:\n                        return truck_index, item_index, x, y, z, orientation\n                \n                #Try placing into a new truck\n                x, y, z, orientation = self._try_new_truck(item_type, truck_type)\n                if x != -1:\n                     return -1, item_index, x, y, z, orientation\n                \n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n                \n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n        \n        for orientation_index, (orientation, dims) in enumerate(orientations):\n            l, w, h = dims\n            \n            #Simple strategy, try to place at origin\n            if self._is_valid_placement((0,0,0), (l,w,h), truck_type, occupied_volumes):\n                return 0, 0, 0, orientation_index\n\n            #Try placing adjacent to existing items\n            for placed_item in occupied_volumes:\n              adjacent_positions = self._generate_adjacent_positions(placed_item, item_type, orientation)\n              for pos in adjacent_positions:\n                    if self._is_valid_placement(pos, (l,w,h), truck_type, occupied_volumes):\n                       return pos[0], pos[1], pos[2], orientation_index\n            \n        \n        return -1, -1, -1, -1\n    \n    def _try_new_truck(self, item_type, truck_type):\n        orientations = self._get_orientations(item_type)\n        for orientation_index, (orientation, dims) in enumerate(orientations):\n            l, w, h = dims\n            if self._is_valid_placement((0,0,0), (l,w,h), truck_type, []):\n                return 0, 0, 0, orientation_index\n        return -1, -1, -1, -1\n\n    def _generate_adjacent_positions(self, placed_item, item_type, orientation):\n           \n        px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n        pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n        L, W, H = item_type['length'], item_type['width'], item_type['height']\n        \n        if orientation == 0:\n            l, w, h = L, W, H\n        elif orientation == 1:\n            l, w, h = L, H, W\n        elif orientation == 2:\n            l, w, h = W, L, H\n        elif orientation == 3:\n            l, w, h = W, H, L\n        elif orientation == 4:\n            l, w, h = H, L, W\n        else:\n            l, w, h = H, W, L\n            \n        positions = []\n        positions.append((px + pl, py, pz))\n        positions.append((px, py + pw, pz))\n        positions.append((px, py, pz + ph))\n        return positions",
          "objective": 27.3,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]