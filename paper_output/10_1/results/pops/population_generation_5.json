[
     {
          "algorithm": "Selects the item with the largest volume and places it using a bottom-left-back heuristic, prioritizing positions that minimize the increase in total z-coordinate of occupied space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item with the largest volume and places it using a bottom-left-back heuristic, prioritizing positions that minimize the increase in total z-coordinate of occupied space.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = 0\n        min_z_increase = float('inf')\n\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, 0, 0, 0, 0\n\n        item = unplaced_items[item_index]\n\n        for truck_index in range(len(trucks_in_use) + 1):\n            if truck_index == len(trucks_in_use):\n                occupied_volumes = []\n            else:\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n            for orientation, dims in self._get_orientations(item):\n                length, width, height = dims\n\n                possible_positions = self._get_possible_positions(truck_type, occupied_volumes, length, width, height)\n\n                for x, y, z in possible_positions:\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                        z_increase = self._calculate_z_increase(occupied_volumes, (x, y, z), (length, width, height))\n\n                        if z_increase < min_z_increase:\n                            min_z_increase = z_increase\n                            best_truck_index = truck_index\n                            best_item_index = item_index\n                            best_x, best_y, best_z = x, y, z\n                            best_orientation = orientation\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = 0\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n        return best_item_index\n\n    def _get_possible_positions(self, container_dims, occupied_volumes, item_length, item_width, item_height):\n        positions = set()\n        positions.add((0, 0, 0))\n\n        for placed_item in occupied_volumes:\n            positions.add((placed_item['x'] + placed_item['length'], placed_item['y'], placed_item['z']))\n            positions.add((placed_item['x'], placed_item['y'] + placed_item['width'], placed_item['z']))\n            positions.add((placed_item['x'], placed_item['y'], placed_item['z'] + placed_item['height']))\n\n        valid_positions = []\n        for x, y, z in positions:\n             if x + item_length <= container_dims[0] and y + item_width <= container_dims[1] and z + item_height <= container_dims[2]:\n                valid_positions.append((x,y,z))\n\n        return valid_positions\n\n    def _calculate_z_increase(self, occupied_volumes, item_pos, item_dims):\n        x, y, z = item_pos\n        l, w, h = item_dims\n        max_z = 0\n\n        for placed_item in occupied_volumes:\n            max_z = max(max_z, placed_item['z'] + placed_item['height'])\n\n        return max(0, z + h - max_z)\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = 0\n        min_z_increase = float('inf')\n\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, 0, 0, 0, 0\n\n        item = unplaced_items[item_index]\n\n        for truck_index in range(len(trucks_in_use) + 1):\n            if truck_index == len(trucks_in_use):\n                occupied_volumes = []\n            else:\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n            for orientation, dims in self._get_orientations(item):\n                length, width, height = dims\n\n                possible_positions = self._get_possible_positions(truck_type, occupied_volumes, length, width, height)\n\n                for x, y, z in possible_positions:\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                        z_increase = self._calculate_z_increase(occupied_volumes, (x, y, z), (length, width, height))\n\n                        if z_increase < min_z_increase:\n                            min_z_increase = z_increase\n                            best_truck_index = truck_index\n                            best_item_index = item_index\n                            best_x, best_y, best_z = x, y, z\n                            best_orientation = orientation\n\n        \n        if best_truck_index == len(trucks_in_use):\n            best_truck_index = -1\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation",
          "objective": 22.05,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     },
     {
          "algorithm": "Prioritizes items with a larger volume for placement, aiming to fill the truck with fewer, larger items before smaller ones and selects the placement that minimizes wasted space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Prioritizes items with a larger volume for placement, aiming to fill the truck with fewer, larger items before smaller ones and selects the placement that minimizes wasted space.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = 0\n        min_waste = float('inf')\n\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, 0, 0, 0, 0\n\n        item = unplaced_items[item_index]\n\n        for truck_index in range(len(trucks_in_use) + 1):\n            if truck_index == len(trucks_in_use):\n                occupied_volumes = []\n            else:\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n            for orientation, dims in self._get_orientations(item):\n                length, width, height = dims\n\n                possible_positions = self._get_possible_positions(truck_type, occupied_volumes, length, width, height)\n\n                for x, y, z in possible_positions:\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                        waste = self._calculate_base_waste(truck_type, occupied_volumes, (x, y, z), (length, width, height))\n\n                        if waste < min_waste:\n                            min_waste = waste\n                            best_truck_index = truck_index\n                            best_item_index = item_index\n                            best_x, best_y, best_z = x, y, z\n                            best_orientation = orientation\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n        return best_item_index\n\n    def _get_possible_positions(self, container_dims, occupied_volumes, item_length, item_width, item_height):\n        positions = set()\n        positions.add((0, 0, 0))\n\n        for placed_item in occupied_volumes:\n            positions.add((placed_item['x'] + placed_item['length'], placed_item['y'], placed_item['z']))\n            positions.add((placed_item['x'], placed_item['y'] + placed_item['width'], placed_item['z']))\n            positions.add((placed_item['x'], placed_item['y'], placed_item['z'] + placed_item['height']))\n\n        valid_positions = []\n        for x, y, z in positions:\n             if x + item_length <= container_dims[0] and y + item_width <= container_dims[1] and z + item_height <= container_dims[2]:\n                valid_positions.append((x,y,z))\n\n        return valid_positions\n\n    def _calculate_base_waste(self, container_dims, occupied_volumes, item_pos, item_dims):\n        container_area = container_dims[0] * container_dims[1]\n        base_area = 0\n        for placed_item in occupied_volumes:\n            base_area += placed_item['length'] * placed_item['width']\n\n        base_area += item_dims[0] * item_dims[1]\n        return container_area - base_area\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = 0\n        min_waste = float('inf')\n\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, 0, 0, 0, 0\n\n        item = unplaced_items[item_index]\n\n        for truck_index in range(len(trucks_in_use) + 1):\n            if truck_index == len(trucks_in_use):\n                occupied_volumes = []\n            else:\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n            for orientation, dims in self._get_orientations(item):\n                length, width, height = dims\n\n                possible_positions = self._get_possible_positions(truck_type, occupied_volumes, length, width, height)\n\n                for x, y, z in possible_positions:\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                        waste = self._calculate_base_waste(truck_type, occupied_volumes, (x, y, z), (length, width, height))\n\n                        if waste < min_waste:\n                            min_waste = waste\n                            best_truck_index = truck_index\n                            best_item_index = item_index\n                            best_x, best_y, best_z = x, y, z\n                            best_orientation = orientation\n\n        if best_truck_index == len(trucks_in_use):\n            best_truck_index = -1\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation",
          "objective": 22.4,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     },
     {
          "algorithm": "Chooses the item with the smallest area and attempts to place it using a bottom-left-fill heuristic, selecting the placement that minimizes wasted space on the base of the truck.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Chooses the item with the smallest area and attempts to place it using a bottom-left-fill heuristic, selecting the placement that minimizes wasted space on the base of the truck.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = 0\n        min_waste = float('inf')\n\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, 0, 0, 0, 0\n\n        item = unplaced_items[item_index]\n\n        for truck_index in range(len(trucks_in_use) + 1):\n            if truck_index == len(trucks_in_use):\n                occupied_volumes = []\n            else:\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n            for orientation, dims in self._get_orientations(item):\n                length, width, height = dims\n\n                possible_positions = self._get_possible_positions(truck_type, occupied_volumes, length, width, height)\n\n                for x, y, z in possible_positions:\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                        waste = self._calculate_base_waste(truck_type, occupied_volumes, (x, y, z), (length, width, height))\n\n                        if waste < min_waste:\n                            min_waste = waste\n                            best_truck_index = truck_index\n                            best_item_index = item_index\n                            best_x, best_y, best_z = x, y, z\n                            best_orientation = orientation\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        min_area = float('inf')\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                area = item['length'] * item['width']\n                if area < min_area:\n                    min_area = area\n                    best_item_index = i\n        return best_item_index\n\n    def _get_possible_positions(self, container_dims, occupied_volumes, item_length, item_width, item_height):\n        positions = set()\n        positions.add((0, 0, 0))\n\n        for placed_item in occupied_volumes:\n            positions.add((placed_item['x'] + placed_item['length'], placed_item['y'], placed_item['z']))\n            positions.add((placed_item['x'], placed_item['y'] + placed_item['width'], placed_item['z']))\n            positions.add((placed_item['x'], placed_item['y'], placed_item['z'] + placed_item['height']))\n\n        valid_positions = []\n        for x, y, z in positions:\n             if x + item_length <= container_dims[0] and y + item_width <= container_dims[1] and z + item_height <= container_dims[2]:\n                valid_positions.append((x,y,z))\n\n        return valid_positions\n\n    def _calculate_base_waste(self, container_dims, occupied_volumes, item_pos, item_dims):\n        container_area = container_dims[0] * container_dims[1]\n        base_area = 0\n        for placed_item in occupied_volumes:\n            base_area += placed_item['length'] * placed_item['width']\n\n        base_area += item_dims[0] * item_dims[1]\n        return container_area - base_area\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = 0\n        min_waste = float('inf')\n\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, 0, 0, 0, 0\n\n        item = unplaced_items[item_index]\n\n        for truck_index in range(len(trucks_in_use) + 1):\n            if truck_index == len(trucks_in_use):\n                occupied_volumes = []\n            else:\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n            for orientation, dims in self._get_orientations(item):\n                length, width, height = dims\n\n                possible_positions = self._get_possible_positions(truck_type, occupied_volumes, length, width, height)\n\n                for x, y, z in possible_positions:\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                        waste = self._calculate_base_waste(truck_type, occupied_volumes, (x, y, z), (length, width, height))\n\n                        if waste < min_waste:\n                            min_waste = waste\n                            best_truck_index = truck_index\n                            best_item_index = item_index\n                            best_x, best_y, best_z = x, y, z\n                            best_orientation = orientation\n\n        if best_truck_index == len(trucks_in_use):\n            best_truck_index = -1\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation",
          "objective": 24.05,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     },
     {
          "algorithm": "Prioritizes item placement based on a combined score favoring higher space utilization and lower remaining quantity, adjusting weighting factors for space utilization and quantity.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Prioritizes item placement based on a combined score favoring higher space utilization and lower remaining quantity, adjusting weighting factors for space utilization and quantity.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = 0.0\n        best_y = 0.0\n        best_z = 0.0\n        best_orientation = 0\n        best_fit_score = -1\n\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                for truck_index, truck in enumerate(trucks_in_use):\n                    x, y, z, orientation, fit_score = self._find_best_position_in_truck(item_index, item_type, truck, truck_type)\n                    if fit_score > best_fit_score:\n                        best_truck_index = truck_index\n                        best_item_index = item_index\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation\n                        best_fit_score = fit_score\n\n                new_truck_x, new_truck_y, new_truck_z, new_truck_orientation, new_truck_fit_score = self._find_best_position_in_new_truck(item_index, item_type, truck_type)\n                if new_truck_fit_score > best_fit_score:\n                    best_truck_index = -1\n                    best_item_index = item_index\n                    best_x = new_truck_x\n                    best_y = new_truck_y\n                    best_z = new_truck_z\n                    best_orientation = new_truck_orientation\n                    best_fit_score = new_truck_fit_score\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item_index, item_type, truck, truck_type):\n        best_x = 0.0\n        best_y = 0.0\n        best_z = 0.0\n        best_orientation = 0\n        best_fit_score = -1\n\n        for orientation_index, (orientation_id, (length, width, height)) in enumerate(self._get_orientations(item_type)):\n            x, y, z = self._find_position_in_truck(item_type, (length, width, height), truck, truck_type)\n\n            if x != -1:\n                fit_score = self._evaluate_fit(item_index, item_type, (length, width, height), truck_type, truck, x, y, z)\n                if fit_score > best_fit_score:\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation_index\n                    best_fit_score = fit_score\n\n        return best_x, best_y, best_z, best_orientation, best_fit_score\n\n    def _find_best_position_in_new_truck(self, item_index, item_type, truck_type):\n        best_x = 0.0\n        best_y = 0.0\n        best_z = 0.0\n        best_orientation = 0\n        best_fit_score = -1\n\n        for orientation_index, (orientation_id, (length, width, height)) in enumerate(self._get_orientations(item_type)):\n            if self._is_within_container_bounds((0.0, 0.0, 0.0), (length, width, height), truck_type):\n                fit_score = self._evaluate_fit(item_index, item_type, (length, width, height), truck_type, None, 0.0, 0.0, 0.0)\n                if fit_score > best_fit_score:\n                    best_x = 0.0\n                    best_y = 0.0\n                    best_z = 0.0\n                    best_orientation = orientation_index\n                    best_fit_score = fit_score\n\n        return best_x, best_y, best_z, best_orientation, best_fit_score\n\n    def _find_position_in_truck(self, item_type, item_dims, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n        cl, cw, ch = container_dims\n        pl, pw, ph = item_dims\n\n        x_coords = [0.0]\n        y_coords = [0.0]\n        z_coords = [0.0]\n\n        for volume in occupied_volumes:\n            x_coords.append(volume['x'] + volume['length'])\n            y_coords.append(volume['y'] + volume['width'])\n            z_coords.append(volume['z'] + volume['height'])\n\n        x_coords = sorted(list(set(x_coords)))\n        y_coords = sorted(list(set(y_coords)))\n        z_coords = sorted(list(set(z_coords)))\n\n        for z in z_coords:\n            if z + ph > ch:\n                continue\n            for y in y_coords:\n                if y + pw > cw:\n                    continue\n                for x in x_coords:\n                    if x + pl > cl:\n                        continue\n                    if self._is_valid_placement((x, y, z), (pl, pw, ph), container_dims, occupied_volumes):\n                        return x, y, z\n\n        return -1, -1, -1\n\n    def _evaluate_fit(self, item_index, item_type, item_dims, truck_type, truck, x, y, z):\n        volume_utilization = item_dims[0] * item_dims[1] * item_dims[2] / (truck_type[0] * truck_type[1] * truck_type[2])\n        quantity_score = item_type['quantity']\n\n        if truck is not None :\n                space_utilization = self._calculate_space_utilization(truck_type, truck['occupied_volumes'], item_dims, x, y, z)\n                return volume_utilization + quantity_score*0.001 + space_utilization*0.5\n        else:\n            return volume_utilization + quantity_score*0.001\n\n    def _calculate_space_utilization(self, truck_type, occupied_volumes, item_dims, x, y, z):\n\n        cl, cw, ch = truck_type\n\n        remaining_space = cl*cw*ch\n        for volume in occupied_volumes:\n            remaining_space -= volume['length'] * volume['width'] * volume['height']\n\n        remaining_space -= item_dims[0] * item_dims[1] * item_dims[2]\n\n        return 1 - remaining_space/(cl*cw*ch)",
          "objective": 24.35,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Iterates through unplaced items, prioritizing by volume and quantity, and places them in the best available truck or a new truck based on a scoring function that considers space utilization and item count.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Iterates through unplaced items, prioritizing by volume and quantity, and places them in the best available truck or a new truck based on a scoring function that considers space utilization and item count.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = 0.0\n        best_y = 0.0\n        best_z = 0.0\n        best_orientation = 0\n        best_score = -1.0\n\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] <= 0:\n                continue\n\n            for truck_index, truck in enumerate(trucks_in_use):\n                x, y, z, orientation, score = self._find_best_position_for_item_in_truck(item_type, truck, truck_type)\n                if score > best_score:\n                    best_score = score\n                    best_truck_index = truck_index\n                    best_item_index = item_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n\n            new_truck_x, new_truck_y, new_truck_z, new_truck_orientation, new_truck_score = self._find_best_position_in_new_truck(item_type, truck_type)\n            if new_truck_score > best_score:\n                best_score = new_truck_score\n                best_truck_index = -1\n                best_item_index = item_index\n                best_x = new_truck_x\n                best_y = new_truck_y\n                best_z = new_truck_z\n                best_orientation = new_truck_orientation\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_for_item_in_truck(self, item_type, truck, truck_type):\n        best_x = 0.0\n        best_y = 0.0\n        best_z = 0.0\n        best_orientation = 0\n        best_score = -1.0\n\n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item_type)):\n            x, y, z = self._find_first_valid_position(item_dims, truck, truck_type)\n            if x != -1:\n                score = self._evaluate_placement(item_type, item_dims, (x, y, z), truck, truck_type)\n                if score > best_score:\n                    best_score = score\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_best_position_in_new_truck(self, item_type, truck_type):\n        best_x = 0.0\n        best_y = 0.0\n        best_z = 0.0\n        best_orientation = 0\n        best_score = -1.0\n        \n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item_type)):\n            if self._is_within_container_bounds((0.0, 0.0, 0.0), item_dims, truck_type):\n                score = self._evaluate_placement(item_type, item_dims, (0.0,0.0,0.0), None, truck_type)\n                if score > best_score:\n                    best_score = score\n                    best_x = 0.0\n                    best_y = 0.0\n                    best_z = 0.0\n                    best_orientation = orientation_index\n        return best_x, best_y, best_z, best_orientation, best_score\n    \n    def _find_first_valid_position(self, item_dims, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n\n        x_coords = [0.0]\n        y_coords = [0.0]\n        z_coords = [0.0]\n\n        for volume in occupied_volumes:\n            x_coords.append(volume['x'] + volume['length'])\n            y_coords.append(volume['y'] + volume['width'])\n            z_coords.append(volume['z'] + volume['height'])\n\n        x_coords = sorted(list(set(x_coords)))\n        y_coords = sorted(list(set(y_coords)))\n        z_coords = sorted(list(set(z_coords)))\n\n        item_length, item_width, item_height = item_dims\n        for z in z_coords:\n            if z + item_height > container_dims[2]:\n                continue\n            for y in y_coords:\n                if y + item_width > container_dims[1]:\n                    continue\n                for x in x_coords:\n                    if x + item_length > container_dims[0]:\n                        continue\n                    if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                        return x, y, z\n        return -1, -1, -1\n\n    def _evaluate_placement(self, item_type, item_dims, position, truck, truck_type):\n        volume = item_dims[0] * item_dims[1] * item_dims[2]\n        volume_utilization = volume / (truck_type[0] * truck_type[1] * truck_type[2])\n        quantity_score = item_type['quantity']\n\n        if truck is not None:\n            space_utilization = self._calculate_space_utilization(truck_type, truck['occupied_volumes'], item_dims)\n            return 0.5 * volume_utilization + 0.1 * quantity_score + 0.4 * space_utilization\n        else:\n            return 0.5 * volume_utilization + 0.1 * quantity_score\n\n    def _calculate_space_utilization(self, truck_type, occupied_volumes, item_dims):\n        truck_volume = truck_type[0] * truck_type[1] * truck_type[2]\n        used_volume = sum(v['length'] * v['width'] * v['height'] for v in occupied_volumes)\n        item_volume = item_dims[0] * item_dims[1] * item_dims[2]\n        return (used_volume + item_volume) / truck_volume",
          "objective": 24.4,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]