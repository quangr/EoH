{
     "algorithm": "Prioritize items based on volume, then select the best placement utilizing a limited, distributed search space, minimizing wasted space, and favoring placement in existing trucks.",
     "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Prioritize items based on volume, then select the best placement utilizing a limited, distributed search space, minimizing wasted space, and favoring placement in existing trucks.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_best_placement(\n            unplaced_items[item_index], trucks_in_use, truck_type\n        )\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        best_volume = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > best_volume:\n                    best_volume = volume\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_wasted_space = float('inf')\n\n        truck_index = 0\n        while truck_index <= len(trucks_in_use):\n            if truck_index < len(trucks_in_use):\n                truck = trucks_in_use[truck_index]\n                occupied_volumes = truck['occupied_volumes']\n            else:\n                occupied_volumes = []\n\n            for orientation_index, dims in self._get_orientations(item_type):\n                x, y, z = self._find_valid_position(dims, truck_type, occupied_volumes)\n\n                if x is not None:\n                    wasted_space = self._evaluate_wasted_space(dims, truck_type, occupied_volumes, (x, y, z))\n                    if wasted_space < best_wasted_space:\n                        best_wasted_space = wasted_space\n                        best_truck_index = truck_index if truck_index < len(trucks_in_use) else -1\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n\n            truck_index += 1\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_valid_position(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = container_dims\n        il, iw, ih = item_dims\n\n        num_x_steps = 3\n        num_y_steps = 3\n        num_z_steps = 3\n\n        x_step_size = (l - il) / (num_x_steps - 1) if num_x_steps > 1 else 0\n        y_step_size = (w - iw) / (num_y_steps - 1) if num_y_steps > 1 else 0\n        z_step_size = (h - ih) / (num_z_steps - 1) if num_z_steps > 1 else 0\n\n        for i in range(num_x_steps):\n            for j in range(num_y_steps):\n                for k in range(num_z_steps):\n                    x = round(i * x_step_size, 6)\n                    y = round(j * y_step_size, 6)\n                    z = round(k * z_step_size, 6)\n\n                    if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                        return x, y, z\n\n        return None, None, None\n\n    def _evaluate_wasted_space(self, item_dims, container_dims, occupied_volumes, item_position):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        x, y, z = item_position\n\n        wasted_space = 0\n\n        wasted_space += x * cw * ch\n        wasted_space += y * cl * ch\n        wasted_space += z * cl * cw\n        wasted_space += (cl - (x + il)) * cw * ch\n        wasted_space += (cw - (y + iw)) * cl * ch\n        wasted_space += (ch - (z + ih)) * cl * cw\n\n        return wasted_space\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_valid_position(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = container_dims\n        il, iw, ih = item_dims\n\n        potential_positions = []\n\n        if not occupied_volumes:\n            if self._is_valid_placement((0, 0, 0), item_dims, container_dims, occupied_volumes):\n                return 0, 0, 0\n            else:\n                return None, None, None\n\n        for item in occupied_volumes:\n            x = item['x'] + item['length']\n            y = item['y']\n            z = item['z']\n            potential_positions.append((x, y, z))\n\n            x = item['x']\n            y = item['y'] + item['width']\n            z = item['z']\n            potential_positions.append((x, y, z))\n\n            x = item['x']\n            y = item['y']\n            z = item['z'] + item['height']\n            potential_positions.append((x, y, z))\n\n        for x, y, z in potential_positions:\n            if (x >= 0 and y >= 0 and z >= 0 and x + il <= l + self.epsilon and y + iw <= w + self.epsilon and z + ih <= h + self.epsilon):\n                if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                    return x, y, z\n\n        return None, None, None",
     "objective": 24.2,
     "other_inf": null,
     "class_name": "AlgorithmFIX1"
}