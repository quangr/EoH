{
     "algorithm": "Select item based on a score considering volume utilization and quantity, find the best placement in the first available truck using bottom-left-fill approach, favoring lower z coordinate and smaller wasted space.",
     "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select item based on a score considering volume utilization and quantity, find the best placement in the first available truck using bottom-left-fill approach, favoring lower z coordinate and smaller wasted space.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items, truck_type)\n\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_best_placement(\n            unplaced_items[item_index], trucks_in_use, truck_type\n        )\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items, truck_type):\n        best_item_index = None\n        best_score = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                score = volume * (1 + np.log(item['quantity']))\n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_wasted_space = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            occupied_volumes = truck['occupied_volumes']\n\n            x, y, z, orientation_index, wasted_space = self._find_valid_position_in_truck(item_type, truck_type, occupied_volumes)\n            \n            if x is not None and wasted_space < best_wasted_space:\n                best_wasted_space = wasted_space\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation_index\n        \n        if best_truck_index is None:\n            x, y, z, orientation_index, wasted_space = self._find_valid_position_in_truck(item_type, truck_type, [])\n            if x is not None:\n                best_truck_index = -1\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation_index\n        \n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_valid_position_in_truck(self, item_type, container_dims, occupied_volumes):\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_wasted_space = float('inf')\n\n        for orientation_index, dims in self._get_orientations(item_type):\n            cl, cw, ch = container_dims\n            il, iw, ih = dims\n            \n            potential_positions = self._generate_potential_positions(container_dims, dims, occupied_volumes)\n\n            for x, y, z in potential_positions:                \n                if self._is_valid_placement((x, y, z), dims, container_dims, occupied_volumes):\n                    wasted_space = self._evaluate_wasted_space(dims, container_dims, occupied_volumes, (x, y, z))\n                    if wasted_space < best_wasted_space:\n                        best_wasted_space = wasted_space\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation, best_wasted_space\n                    \n    def _generate_potential_positions(self, container_dims, item_dims, occupied_volumes):\n        positions = set()\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n\n        if not occupied_volumes:\n            positions.add((0, 0, 0))\n            return [(0,0,0)]\n\n        for item in occupied_volumes:\n            # Bottom-Left-Fill Approach\n\n            x = item['x'] + item['length']\n            y = item['y']\n            z = item['z']\n            positions.add((x, y, z))\n\n            x = item['x']\n            y = item['y'] + item['width']\n            z = item['z']\n            positions.add((x, y, z))\n\n            x = item['x']\n            y = item['y']\n            z = item['z'] + item['height']\n            positions.add((x, y, z))\n\n        valid_positions = []\n        for x, y, z in positions:\n            if (x >= 0 and y >= 0 and z >= 0 and x + il <= cl + self.epsilon and y + iw <= cw + self.epsilon and z + ih <= ch + self.epsilon):\n                valid_positions.append((x,y,z))\n        \n        valid_positions.sort(key=lambda p: (p[2], (p[0]**2 + p[1]**2)**0.5))\n        \n        return valid_positions\n\n    def _evaluate_wasted_space(self, item_dims, container_dims, occupied_volumes, item_position):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        x, y, z = item_position\n\n        wasted_space = 0\n\n        wasted_space += x * cw * ch\n        wasted_space += y * cl * ch\n        wasted_space += z * cl * cw\n        wasted_space += (cl - (x + il)) * cw * ch\n        wasted_space += (cw - (y + iw)) * cl * ch\n        wasted_space += (ch - (z + ih)) * cl * cw\n\n        return wasted_space",
     "objective": 22.4,
     "other_inf": null,
     "class_name": "Algorithm"
}