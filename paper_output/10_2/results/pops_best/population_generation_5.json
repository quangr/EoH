{
     "algorithm": "Iteratively select an item type based on a combined score of quantity and volume, then find the best placement (truck and orientation) based on a greedy heuristic maximizing the smallest remaining space after placement.",
     "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Iteratively select an item type based on a combined score of quantity and volume, then find the best placement (truck and orientation) based on a greedy heuristic maximizing the smallest remaining space after placement.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_best_placement(\n            unplaced_items[item_index], trucks_in_use, truck_type\n        )\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        best_score = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                score = (item['quantity'] ** 0.5) * volume  # Combine quantity and volume\n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_remaining_space = float('inf')\n\n        for truck_index in range(len(trucks_in_use)):\n            truck = trucks_in_use[truck_index]\n            occupied_volumes = truck['occupied_volumes']\n\n            for orientation_index, dims in self._get_orientations(item_type):\n                x, y, z = self._find_valid_position(dims, truck_type, occupied_volumes)\n\n                if x is not None:\n                    remaining_space = self._evaluate_remaining_space(dims, truck_type, occupied_volumes, (x, y, z))\n                    if remaining_space < best_remaining_space:\n                        best_remaining_space = remaining_space\n                        best_truck_index = truck_index\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n\n        # Check if it's better to open a new truck\n        for orientation_index, dims in self._get_orientations(item_type):\n            x, y, z = self._find_valid_position(dims, truck_type, [])\n            if x is not None:\n                remaining_space = self._evaluate_remaining_space(dims, truck_type, [], (x, y, z))\n                if remaining_space < best_remaining_space:\n                    best_truck_index = -1\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation_index\n                    best_remaining_space = remaining_space\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_valid_position(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = container_dims\n        il, iw, ih = item_dims\n\n        for x in np.arange(0, l - il + self.epsilon, il / 2 if il > 0 else 1):\n            for y in np.arange(0, w - iw + self.epsilon, iw / 2 if iw > 0 else 1):\n                for z in np.arange(0, h - ih + self.epsilon, ih / 2 if ih > 0 else 1):\n                    x = round(x, 6)\n                    y = round(y, 6)\n                    z = round(z, 6)\n                    if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                        return x, y, z\n        return None, None, None\n\n    def _evaluate_remaining_space(self, item_dims, container_dims, occupied_volumes, item_position):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        x, y, z = item_position\n\n        total_volume = cl * cw * ch\n        occupied_volume = 0.0\n        new_item = {'x': x, 'y': y, 'z': z, 'length': il, 'width': iw, 'height': ih}\n        all_volumes = occupied_volumes + [new_item]\n\n        for item in all_volumes:\n            occupied_volume += item['length'] * item['width'] * item['height']\n        \n        return total_volume - occupied_volume\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_valid_position(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = container_dims\n        il, iw, ih = item_dims\n\n        num_x_steps = min(10, int((l - il) / (il / 2 if il > 0 else 1)) + 1)\n        num_y_steps = min(10, int((w - iw) / (iw / 2 if iw > 0 else 1)) + 1)\n        num_z_steps = min(10, int((h - ih) / (ih / 2 if ih > 0 else 1)) + 1)\n\n        x_step_size = (l - il) / (num_x_steps - 1) if num_x_steps > 1 else 0\n        y_step_size = (w - iw) / (num_y_steps - 1) if num_y_steps > 1 else 0\n        z_step_size = (h - ih) / (num_z_steps - 1) if num_z_steps > 1 else 0\n\n        for i in range(num_x_steps):\n            for j in range(num_y_steps):\n                for k in range(num_z_steps):\n                    x = round(i * x_step_size, 6)\n                    y = round(j * y_step_size, 6)\n                    z = round(k * z_step_size, 6)\n                    \n                    if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                        return x, y, z\n        return None, None, None\nimport numpy as np\n\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_valid_position(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = container_dims\n        il, iw, ih = item_dims\n\n        potential_positions = []\n\n        if not occupied_volumes:\n            if self._is_valid_placement((0, 0, 0), item_dims, container_dims, occupied_volumes):\n                return 0, 0, 0\n            else:\n                return None, None, None\n\n        for item in occupied_volumes:\n            # Add positions adjacent to existing items\n            x = item['x'] + item['length']\n            y = item['y']\n            z = item['z']\n            potential_positions.append((x, y, z))\n\n            x = item['x']\n            y = item['y'] + item['width']\n            z = item['z']\n            potential_positions.append((x, y, z))\n\n            x = item['x']\n            y = item['y']\n            z = item['z'] + item['height']\n            potential_positions.append((x, y, z))\n            \n        \n        for x, y, z in potential_positions:\n            if (x >= 0 and y >= 0 and z >= 0 and x + il <= l and y + iw <= w and z + ih <= h):\n                if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                        return x, y, z\n\n        return None, None, None",
     "objective": 24.65,
     "other_inf": null,
     "class_name": "AlgorithmFIX2"
}