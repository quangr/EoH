[
     {
          "algorithm": "Selects items based on remaining quantity and volume, tries orientations, places if valid, else repeats with next best item/orientation and opens new trucks when necessary.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects items based on remaining quantity and volume, tries orientations, places if valid, else repeats with next best item/orientation and opens new trucks when necessary.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index = -1\n        item_index = -1\n        x = 0\n        y = 0\n        z = 0\n        orientation = 0\n\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, 0, 0, 0, 0\n\n        best_truck_index, best_x, best_y, best_z, best_orientation = self._find_best_placement(\n            unplaced_items[item_index], trucks_in_use, truck_type\n        )\n\n        if best_truck_index == -1:\n            truck_index = -1\n            x = 0\n            y = 0\n            z = 0\n            orientation = best_orientation\n        else:\n            truck_index = best_truck_index\n            x = best_x\n            y = best_y\n            z = best_z\n            orientation = best_orientation\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        best_score = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                score = item['quantity'] * volume\n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x = 0\n        best_y = 0\n        best_z = 0\n        best_orientation = 0\n        best_volume_utilization = -1\n\n        for truck_index in range(len(trucks_in_use)):\n            occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n            for orientation, dims in self._get_orientations(item_type):\n                length, width, height = dims\n\n                potential_positions = self._generate_potential_positions(truck_type, length, width, height, occupied_volumes)\n                for x, y, z in potential_positions:\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                        volume_utilization = length * width * height\n                        if volume_utilization > best_volume_utilization:\n                            best_volume_utilization = volume_utilization\n                            best_truck_index = truck_index\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            best_orientation = orientation\n\n        if best_truck_index == -1:\n            for orientation, dims in self._get_orientations(item_type):\n                length, width, height = dims\n                if self._is_valid_placement((0, 0, 0), (length, width, height), truck_type, []):\n                    best_truck_index = -1\n                    best_x = 0\n                    best_y = 0\n                    best_z = 0\n                    best_orientation = orientation\n                    break\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _generate_potential_positions(self, container_dims, length, width, height, occupied_volumes):\n        potential_positions = []\n        if not occupied_volumes:\n            return [(0,0,0)]\n        \n        for item in occupied_volumes:\n            x = item['x'] + item['length']\n            y = item['y']\n            z = item['z']\n            potential_positions.append((x, y, z))\n            \n            x = item['x']\n            y = item['y'] + item['width']\n            z = item['z']\n            potential_positions.append((x, y, z))\n            \n            x = item['x']\n            y = item['y']\n            z = item['z'] + item['height']\n            potential_positions.append((x, y, z))\n\n        return potential_positions",
          "objective": 24.7,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects the item type with the highest remaining quantity, then places it using a bottom-left-back heuristic, opening a new truck if necessary.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item type with the highest remaining quantity, then places it using a bottom-left-back heuristic, opening a new truck if necessary.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        \n        best_item_index = self._select_item(unplaced_items)\n        if best_item_index == -1:\n            return -1, -1, -1, -1, -1, -1\n                \n        best_truck_index, best_x, best_y, best_z, best_orientation = self._find_placement_in_existing_trucks(unplaced_items, trucks_in_use, truck_type, best_item_index)\n\n        if best_truck_index == -2:\n            best_truck_index = -1\n            best_x, best_y, best_z, best_orientation = self._find_placement_in_new_truck(unplaced_items, truck_type, best_item_index)\n                \n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n    \n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_quantity = -1\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > max_quantity:\n                max_quantity = item['quantity']\n                best_item_index = i\n        return best_item_index\n\n    def _find_placement_in_existing_trucks(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        item_to_place = unplaced_items[item_index]\n        best_truck_index = -2\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n\n        for truck_index, truck in enumerate(trucks_in_use):            \n            x, y, z, orientation = self._find_best_fit_position(item_to_place, truck, truck_type) \n\n            if x != -1:\n                return truck_index, x, y, z, orientation\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n    \n    def _find_placement_in_new_truck(self, unplaced_items,truck_type,item_index):\n        item_to_place = unplaced_items[item_index]\n        orientations = self._get_orientations(item_to_place)\n        \n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        \n        for orientation_index, dims in orientations:\n            if self._is_within_container_bounds((0, 0, 0), dims, truck_type):\n                best_x = 0\n                best_y = 0\n                best_z = 0\n                best_orientation = orientation_index\n                break\n        return best_x,best_y,best_z,best_orientation\n    \n\n    def _find_best_fit_position(self, item_to_place, truck, truck_type):\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item_to_place)\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        \n        for orientation_index, dims in orientations:\n            \n            x,y,z = self._bottom_left_back_heuristic(dims,truck_type,occupied_volumes)\n            if x != -1:\n                return x,y,z,orientation_index\n\n        return best_x, best_y, best_z, best_orientation\n                \n    def _bottom_left_back_heuristic(self, item_dims, container_dims, occupied_volumes):\n        available_positions = []\n        if not occupied_volumes:\n            if self._is_within_container_bounds((0,0,0),item_dims,container_dims):\n              return 0,0,0\n            else:\n              return -1,-1,-1\n        \n        for item in occupied_volumes:\n          x_coord = item['x'] + item['length']\n          y_coord = item['y'] + item['width']\n          z_coord = item['z'] + item['height']\n          available_positions.append((x_coord, item['y'], item['z']))\n          available_positions.append((item['x'], y_coord, item['z']))\n          available_positions.append((item['x'], item['y'], z_coord))\n\n        \n        # Add (0,0,0) if the truck is empty\n        if not occupied_volumes:\n            available_positions.append((0, 0, 0))\n            \n        for pos in available_positions:\n            if self._is_valid_placement(pos, item_dims, container_dims, occupied_volumes):\n              return pos\n            \n        \n        return -1,-1,-1",
          "objective": 25.05,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Iterate through items and orientations, find the best available position in existing trucks or create a new one based on a heuristic score considering space utilization.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Iterate through items and orientations, find the best available position in existing trucks or create a new one based on a heuristic score considering space utilization.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        best_truck_index, best_x, best_y, best_z, best_orientation, best_score = self._find_best_placement(\n            unplaced_items[item_index], trucks_in_use, truck_type\n        )\n\n        if best_truck_index == -1:\n            x, y, z = best_x, best_y, best_z\n        else:\n            x, y, z = best_x, best_y, best_z\n            \n        return best_truck_index, item_index, x, y, z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        # Prioritize items with smaller dimensions or higher quantities\n        item_scores = []\n        for i, item in enumerate(unplaced_items):\n            item_scores.append((item['length'] * item['width'] * item['height']) / item['quantity'])\n        \n        if not item_scores:\n            return None\n        \n        return np.argmin(item_scores)\n        \n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_score = float('inf')\n        \n        for orientation_index, dims in self._get_orientations(item_type):\n            \n            # Check existing trucks\n            for truck_index, truck in enumerate(trucks_in_use):\n                x, y, z = self._find_position_in_truck(item_type, dims, truck_type, truck['occupied_volumes'])\n                \n                if x is not None:\n                    score = self._evaluate_placement(dims, truck_type, truck['occupied_volumes'])\n                    if score < best_score:\n                        best_truck_index = truck_index\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n                        best_score = score\n                        \n            # Check new truck\n            x, y, z = self._find_position_in_truck(item_type, dims, truck_type, [])\n            if x is not None:\n                score = self._evaluate_placement(dims, truck_type, [])\n                \n                if score < best_score:\n                  \n                    best_truck_index = -1\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation_index\n                    best_score = score\n                    \n        return best_truck_index, best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_position_in_truck(self, item_type, item_dims, container_dims, occupied_volumes):\n        l, w, h = container_dims\n        il, iw, ih = item_dims\n        \n        # Try bottom-left-front corner first\n        x = 0.0\n        y = 0.0\n        z = 0.0\n        \n        if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n            return x, y, z\n        \n\n        # Try fitting next to existing items (but only if there are existing items)\n        if occupied_volumes:\n            # Check top of each volume\n            for volume in occupied_volumes:\n                new_x = volume['x']\n                new_y = volume['y']\n                new_z = volume['z'] + volume['height']\n                if self._is_valid_placement((new_x, new_y, new_z), item_dims, container_dims, occupied_volumes):\n                    return new_x, new_y, new_z\n\n            # Check right of each volume\n            for volume in occupied_volumes:\n                new_x = volume['x'] + volume['length']\n                new_y = volume['y']\n                new_z = volume['z']\n                if self._is_valid_placement((new_x, new_y, new_z), item_dims, container_dims, occupied_volumes):\n                    return new_x, new_y, new_z\n                \n            # Check front of each volume\n            for volume in occupied_volumes:\n                new_x = volume['x']\n                new_y = volume['y'] + volume['width']\n                new_z = volume['z']\n                if self._is_valid_placement((new_x, new_y, new_z), item_dims, container_dims, occupied_volumes):\n                    return new_x, new_y, new_z\n\n        return None, None, None\n    \n    def _evaluate_placement(self, item_dims, container_dims, occupied_volumes):\n        # Heuristic: Minimize wasted space.\n\n        total_volume = container_dims[0] * container_dims[1] * container_dims[2]\n        occupied_volume = 0.0\n\n        for item in occupied_volumes:\n            occupied_volume += item['length'] * item['width'] * item['height']\n\n        new_item_volume = item_dims[0] * item_dims[1] * item_dims[2]\n        \n        return (total_volume - (occupied_volume + new_item_volume)) / total_volume  # Empty space percentage\nclass AlgorithmFIX1(Algorithm):\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        best_truck_index, best_x, best_y, best_z, best_orientation, best_score = self._find_best_placement(\n            unplaced_items[item_index], trucks_in_use, truck_type\n        )\n\n        if best_truck_index == -1:\n            x, y, z = best_x, best_y, best_z\n        else:\n            x, y, z = best_x, best_y, best_z\n        \n        if best_truck_index is not None:\n          best_truck_index = int(best_truck_index)\n        if item_index is not None:\n          item_index = int(item_index)\n        if best_orientation is not None:\n          best_orientation = int(best_orientation)\n            \n        return best_truck_index, item_index, x, y, z, best_orientation\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _select_item(self, unplaced_items):\n        # Prioritize items with smaller dimensions or higher quantities\n        item_scores = []\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                item_scores.append((item['length'] * item['width'] * item['height']) / item['quantity'])\n            else:\n                item_scores.append(float('inf'))\n\n        \n        if not item_scores:\n            return None\n        \n        return np.argmin(item_scores)",
          "objective": 26.15,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     },
     {
          "algorithm": "Iteratively select items with the largest volume, try all orientations, and place them in the best available position within an existing or new container.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Iteratively select items with the largest volume, try all orientations, and place them in the best available position within an existing or new container.}\n    \n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        max_volume = -1\n\n        item_index = self._select_item_to_place(unplaced_items)\n        if item_index == -1:\n            return -1, -1, -1, -1, -1, -1\n\n        item_type = unplaced_items[item_index]\n\n        for truck_index in range(-1, len(trucks_in_use)):\n            if truck_index == -1:\n                occupied_volumes = []\n            else:\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n            for orientation, item_dims in self._get_orientations(item_type):\n                x, y, z = self._find_position_for_item(item_dims, truck_type, occupied_volumes)\n                if x != -1:\n                  if item_type['length'] * item_type['width'] * item_type['height'] > max_volume:\n                    max_volume = item_type['length'] * item_type['width'] * item_type['height']\n                    best_truck_index = truck_index\n                    best_item_index = item_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item_to_place(self, unplaced_items):\n        max_volume = -1\n        selected_index = -1\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                volume = item_type['length'] * item_type['width'] * item_type['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    selected_index = i\n        return selected_index\n\n    def _find_position_for_item(self, item_dims, container_dims, occupied_volumes):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        \n        x_coords = [0.0]\n        y_coords = [0.0]\n        z_coords = [0.0]\n        \n        for placed_item in occupied_volumes:\n            x_coords.append(placed_item['x'] + placed_item['length'])\n            y_coords.append(placed_item['y'] + placed_item['width'])\n            z_coords.append(placed_item['z'] + placed_item['height'])\n\n        x_coords = sorted(list(set(x_coords)))\n        y_coords = sorted(list(set(y_coords)))\n        z_coords = sorted(list(set(z_coords)))\n\n        for x in x_coords:\n            for y in y_coords:\n                for z in z_coords:\n                  if self._is_valid_placement((x,y,z), item_dims, container_dims, occupied_volumes):\n                    return x, y, z\n        return -1, -1, -1",
          "objective": 101.5,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]