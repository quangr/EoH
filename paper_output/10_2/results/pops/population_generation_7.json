[
     {
          "algorithm": "Select item based on a score considering volume utilization and quantity, find the best placement in the first available truck using bottom-left-fill approach, favoring lower z coordinate and smaller wasted space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select item based on a score considering volume utilization and quantity, find the best placement in the first available truck using bottom-left-fill approach, favoring lower z coordinate and smaller wasted space.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items, truck_type)\n\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_best_placement(\n            unplaced_items[item_index], trucks_in_use, truck_type\n        )\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items, truck_type):\n        best_item_index = None\n        best_score = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                score = volume * (1 + np.log(item['quantity']))\n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_wasted_space = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            occupied_volumes = truck['occupied_volumes']\n\n            x, y, z, orientation_index, wasted_space = self._find_valid_position_in_truck(item_type, truck_type, occupied_volumes)\n            \n            if x is not None and wasted_space < best_wasted_space:\n                best_wasted_space = wasted_space\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation_index\n        \n        if best_truck_index is None:\n            x, y, z, orientation_index, wasted_space = self._find_valid_position_in_truck(item_type, truck_type, [])\n            if x is not None:\n                best_truck_index = -1\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation_index\n        \n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_valid_position_in_truck(self, item_type, container_dims, occupied_volumes):\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_wasted_space = float('inf')\n\n        for orientation_index, dims in self._get_orientations(item_type):\n            cl, cw, ch = container_dims\n            il, iw, ih = dims\n            \n            potential_positions = self._generate_potential_positions(container_dims, dims, occupied_volumes)\n\n            for x, y, z in potential_positions:                \n                if self._is_valid_placement((x, y, z), dims, container_dims, occupied_volumes):\n                    wasted_space = self._evaluate_wasted_space(dims, container_dims, occupied_volumes, (x, y, z))\n                    if wasted_space < best_wasted_space:\n                        best_wasted_space = wasted_space\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation, best_wasted_space\n                    \n    def _generate_potential_positions(self, container_dims, item_dims, occupied_volumes):\n        positions = set()\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n\n        if not occupied_volumes:\n            positions.add((0, 0, 0))\n            return [(0,0,0)]\n\n        for item in occupied_volumes:\n            # Bottom-Left-Fill Approach\n\n            x = item['x'] + item['length']\n            y = item['y']\n            z = item['z']\n            positions.add((x, y, z))\n\n            x = item['x']\n            y = item['y'] + item['width']\n            z = item['z']\n            positions.add((x, y, z))\n\n            x = item['x']\n            y = item['y']\n            z = item['z'] + item['height']\n            positions.add((x, y, z))\n\n        valid_positions = []\n        for x, y, z in positions:\n            if (x >= 0 and y >= 0 and z >= 0 and x + il <= cl + self.epsilon and y + iw <= cw + self.epsilon and z + ih <= ch + self.epsilon):\n                valid_positions.append((x,y,z))\n        \n        valid_positions.sort(key=lambda p: (p[2], (p[0]**2 + p[1]**2)**0.5))\n        \n        return valid_positions\n\n    def _evaluate_wasted_space(self, item_dims, container_dims, occupied_volumes, item_position):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        x, y, z = item_position\n\n        wasted_space = 0\n\n        wasted_space += x * cw * ch\n        wasted_space += y * cl * ch\n        wasted_space += z * cl * cw\n        wasted_space += (cl - (x + il)) * cw * ch\n        wasted_space += (cw - (y + iw)) * cl * ch\n        wasted_space += (ch - (z + ih)) * cl * cw\n\n        return wasted_space",
          "objective": 22.4,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Select item based on volume utilization and a dampened quantity score, then place it in the best position based on a fitted regression model predicted from features extracted from the placement.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select item based on volume utilization and a dampened quantity score, then place it in the best position based on a fitted regression model predicted from features extracted from the placement.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items, truck_type)\n\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_best_placement(\n            unplaced_items[item_index], trucks_in_use, truck_type\n        )\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items, truck_type):\n        best_item_index = None\n        best_score = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                score = volume * (item['quantity']**0.5)\n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_placement_score = float('inf') \n\n        for truck_index, truck in enumerate(trucks_in_use):\n            occupied_volumes = truck['occupied_volumes']\n\n            x, y, z, orientation_index, placement_score = self._evaluate_potential_placements(item_type, truck_type, occupied_volumes)\n            \n            if x is not None and placement_score < best_placement_score:\n                best_placement_score = placement_score\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation_index\n        \n        if best_truck_index is None:\n            x, y, z, orientation_index, placement_score = self._evaluate_potential_placements(item_type, truck_type, [])\n            if x is not None:\n                best_truck_index = -1\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation_index\n        \n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _evaluate_potential_placements(self, item_type, container_dims, occupied_volumes):\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_placement_score = float('inf')\n        \n        for orientation_index, dims in self._get_orientations(item_type):\n            cl, cw, ch = container_dims\n            il, iw, ih = dims\n            \n            potential_positions = self._generate_potential_positions(container_dims, dims, occupied_volumes)\n\n            for x, y, z in potential_positions:                \n                if self._is_valid_placement((x, y, z), dims, container_dims, occupied_volumes):\n                    placement_score = self._predict_placement_score(dims, container_dims, occupied_volumes, (x, y, z))\n                    if placement_score < best_placement_score:\n                        best_placement_score = placement_score\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation, best_placement_score\n    \n    def _generate_potential_positions(self, container_dims, item_dims, occupied_volumes):\n        positions = set()\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n\n        if not occupied_volumes:\n            positions.add((0, 0, 0))\n            return [(0,0,0)]\n\n        for item in occupied_volumes:\n\n            x = item['x'] + item['length']\n            y = item['y']\n            z = item['z']\n            positions.add((x, y, z))\n\n            x = item['x']\n            y = item['y'] + item['width']\n            z = item['z']\n            positions.add((x, y, z))\n\n            x = item['x']\n            y = item['y']\n            z = item['z'] + item['height']\n            positions.add((x, y, z))\n\n        valid_positions = []\n        for x, y, z in positions:\n            if (x >= 0 and y >= 0 and z >= 0 and x + il <= cl + self.epsilon and y + iw <= cw + self.epsilon and z + ih <= ch + self.epsilon):\n                valid_positions.append((x,y,z))\n        \n        valid_positions.sort(key=lambda p: (p[2], (p[0]**2 + p[1]**2)**0.5))\n        \n        return valid_positions\n    \n    def _predict_placement_score(self, item_dims, container_dims, occupied_volumes, item_position):\n\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        x, y, z = item_position\n\n        features = [x / cl, y / cw, z / ch, il / cl, iw / cw, ih / ch]\n        \n        weights = [0.1, 0.1, 0.2, 0.2, 0.1, 0.3]\n        \n        bias = 0.05\n        \n        predicted_score = sum(w * f for w, f in zip(weights, features)) + bias\n\n        return predicted_score",
          "objective": 23.45,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Select item with largest remaining quantity; try placing in existing trucks, then in a new truck, minimizing wasted space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select item with largest remaining quantity; try placing in existing trucks, then in a new truck, minimizing wasted space.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_best_placement(\n            unplaced_items[item_index], trucks_in_use, truck_type\n        )\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        best_quantity = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                if item['quantity'] > best_quantity:\n                    best_quantity = item['quantity']\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_wasted_space = float('inf')\n\n        for truck_index in range(len(trucks_in_use) + 1):\n            if truck_index < len(trucks_in_use):\n                truck = trucks_in_use[truck_index]\n                occupied_volumes = truck['occupied_volumes']\n            else:\n                occupied_volumes = []\n\n            for orientation_index, dims in self._get_orientations(item_type):\n                x, y, z = self._find_valid_position(dims, truck_type, occupied_volumes)\n\n                if x is not None:\n                    wasted_space = self._evaluate_wasted_space(dims, truck_type, occupied_volumes, (x, y, z))\n                    if wasted_space < best_wasted_space:\n                        best_wasted_space = wasted_space\n                        best_truck_index = truck_index if truck_index < len(trucks_in_use) else -1\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_valid_position(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = container_dims\n        il, iw, ih = item_dims\n\n        for x in [0.0]:\n            for y in [0.0]:\n                for z in [0.0]:\n                    if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                        return x, y, z\n        \n        if occupied_volumes:\n            for item in occupied_volumes:\n                possible_positions = [\n                    (item['x'] + item['length'], item['y'], item['z']),\n                    (item['x'], item['y'] + item['width'], item['z']),\n                    (item['x'], item['y'], item['z'] + item['height'])\n                ]\n                \n                for x, y, z in possible_positions:\n                    if  (0 <= x <= l and 0 <= y <= w and 0 <= z <= h and\n                         0 <= x + il <= l and 0 <= y + iw <= w and 0 <= z + ih <= h):\n                        if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                            return x, y, z\n\n        return None, None, None\n\n    def _evaluate_wasted_space(self, item_dims, container_dims, occupied_volumes, item_position):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        x, y, z = item_position\n\n        wasted_space = 0\n\n        wasted_space += x * cw * ch\n        wasted_space += y * cl * ch\n        wasted_space += z * cl * cw\n        wasted_space += (cl - (x + il)) * cw * ch\n        wasted_space += (cw - (y + iw)) * cl * ch\n        wasted_space += (ch - (z + ih)) * cl * cw\n\n        return wasted_space",
          "objective": 23.95,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Prioritize items based on volume, then select the best placement utilizing a limited, distributed search space, minimizing wasted space, and favoring placement in existing trucks.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Prioritize items based on volume, then select the best placement utilizing a limited, distributed search space, minimizing wasted space, and favoring placement in existing trucks.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_best_placement(\n            unplaced_items[item_index], trucks_in_use, truck_type\n        )\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        best_volume = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > best_volume:\n                    best_volume = volume\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_wasted_space = float('inf')\n\n        truck_index = 0\n        while truck_index <= len(trucks_in_use):\n            if truck_index < len(trucks_in_use):\n                truck = trucks_in_use[truck_index]\n                occupied_volumes = truck['occupied_volumes']\n            else:\n                occupied_volumes = []\n\n            for orientation_index, dims in self._get_orientations(item_type):\n                x, y, z = self._find_valid_position(dims, truck_type, occupied_volumes)\n\n                if x is not None:\n                    wasted_space = self._evaluate_wasted_space(dims, truck_type, occupied_volumes, (x, y, z))\n                    if wasted_space < best_wasted_space:\n                        best_wasted_space = wasted_space\n                        best_truck_index = truck_index if truck_index < len(trucks_in_use) else -1\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n\n            truck_index += 1\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_valid_position(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = container_dims\n        il, iw, ih = item_dims\n\n        num_x_steps = 3\n        num_y_steps = 3\n        num_z_steps = 3\n\n        x_step_size = (l - il) / (num_x_steps - 1) if num_x_steps > 1 else 0\n        y_step_size = (w - iw) / (num_y_steps - 1) if num_y_steps > 1 else 0\n        z_step_size = (h - ih) / (num_z_steps - 1) if num_z_steps > 1 else 0\n\n        for i in range(num_x_steps):\n            for j in range(num_y_steps):\n                for k in range(num_z_steps):\n                    x = round(i * x_step_size, 6)\n                    y = round(j * y_step_size, 6)\n                    z = round(k * z_step_size, 6)\n\n                    if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                        return x, y, z\n\n        return None, None, None\n\n    def _evaluate_wasted_space(self, item_dims, container_dims, occupied_volumes, item_position):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        x, y, z = item_position\n\n        wasted_space = 0\n\n        wasted_space += x * cw * ch\n        wasted_space += y * cl * ch\n        wasted_space += z * cl * cw\n        wasted_space += (cl - (x + il)) * cw * ch\n        wasted_space += (cw - (y + iw)) * cl * ch\n        wasted_space += (ch - (z + ih)) * cl * cw\n\n        return wasted_space\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_valid_position(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = container_dims\n        il, iw, ih = item_dims\n\n        potential_positions = []\n\n        if not occupied_volumes:\n            if self._is_valid_placement((0, 0, 0), item_dims, container_dims, occupied_volumes):\n                return 0, 0, 0\n            else:\n                return None, None, None\n\n        for item in occupied_volumes:\n            x = item['x'] + item['length']\n            y = item['y']\n            z = item['z']\n            potential_positions.append((x, y, z))\n\n            x = item['x']\n            y = item['y'] + item['width']\n            z = item['z']\n            potential_positions.append((x, y, z))\n\n            x = item['x']\n            y = item['y']\n            z = item['z'] + item['height']\n            potential_positions.append((x, y, z))\n\n        for x, y, z in potential_positions:\n            if (x >= 0 and y >= 0 and z >= 0 and x + il <= l + self.epsilon and y + iw <= w + self.epsilon and z + ih <= h + self.epsilon):\n                if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                    return x, y, z\n\n        return None, None, None",
          "objective": 24.2,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     },
     {
          "algorithm": "Prioritize packing item types with the largest footprint (area) on the base of the container, select the best orientation and position based on minimizing wasted space around the item.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Prioritize packing item types with the largest footprint (area) on the base of the container, select the best orientation and position based on minimizing wasted space around the item.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_best_placement(\n            unplaced_items[item_index], trucks_in_use, truck_type\n        )\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        best_footprint = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                footprint = item['length'] * item['width']\n                if footprint > best_footprint:\n                    best_footprint = footprint\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_wasted_space = float('inf')\n\n        for truck_index in range(len(trucks_in_use)):\n            truck = trucks_in_use[truck_index]\n            occupied_volumes = truck['occupied_volumes']\n\n            for orientation_index, dims in self._get_orientations(item_type):\n                x, y, z = self._find_valid_position(dims, truck_type, occupied_volumes)\n\n                if x is not None:\n                    wasted_space = self._evaluate_wasted_space(dims, truck_type, occupied_volumes, (x, y, z))\n                    if wasted_space < best_wasted_space:\n                        best_wasted_space = wasted_space\n                        best_truck_index = truck_index\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n\n        for orientation_index, dims in self._get_orientations(item_type):\n            x, y, z = self._find_valid_position(dims, truck_type, [])\n\n            if x is not None:\n                wasted_space = self._evaluate_wasted_space(dims, truck_type, [], (x, y, z))\n                if wasted_space < best_wasted_space:\n                    best_wasted_space = wasted_space\n                    best_truck_index = -1\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation_index\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_valid_position(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = container_dims\n        il, iw, ih = item_dims\n\n        for x in np.arange(0, l - il + self.epsilon, min(il, iw, ih) / 2 if min(il, iw, ih) > 0 else 1 ):\n            for y in np.arange(0, w - iw + self.epsilon, min(il, iw, ih) / 2 if min(il, iw, ih) > 0 else 1 ):\n                for z in np.arange(0, h - ih + self.epsilon, min(il, iw, ih) / 2 if min(il, iw, ih) > 0 else 1 ):\n                    x = round(x, 6)\n                    y = round(y, 6)\n                    z = round(z, 6)\n                    if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                        return x, y, z\n\n        return None, None, None\n\n    def _evaluate_wasted_space(self, item_dims, container_dims, occupied_volumes, item_position):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        x, y, z = item_position\n\n        wasted_space = 0\n\n        wasted_space += x * cw * ch\n        wasted_space += y * cl * ch\n        wasted_space += z * cl * cw\n        wasted_space += (cl - (x + il)) * cw * ch\n        wasted_space += (cw - (y + iw)) * cl * ch\n        wasted_space += (ch - (z + ih)) * cl * cw\n\n        return wasted_space\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_valid_position(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = container_dims\n        il, iw, ih = item_dims\n\n        num_x_steps = min(5, int((l - il) / (il / 2 if il > 0 else 1)) + 1)\n        num_y_steps = min(5, int((w - iw) / (iw / 2 if iw > 0 else 1)) + 1)\n        num_z_steps = min(5, int((h - ih) / (ih / 2 if ih > 0 else 1)) + 1)\n\n        x_step_size = (l - il) / (num_x_steps - 1) if num_x_steps > 1 else 0\n        y_step_size = (w - iw) / (num_y_steps - 1) if num_y_steps > 1 else 0\n        z_step_size = (h - ih) / (num_z_steps - 1) if num_z_steps > 1 else 0\n\n        for i in range(num_x_steps):\n            for j in range(num_y_steps):\n                for k in range(num_z_steps):\n                    x = round(i * x_step_size, 6)\n                    y = round(j * y_step_size, 6)\n                    z = round(k * z_step_size, 6)\n                    \n                    if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                        return x, y, z\n\n        return None, None, None\nimport numpy as np\n\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_valid_position(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = container_dims\n        il, iw, ih = item_dims\n\n        potential_positions = []\n\n        if not occupied_volumes:\n            if self._is_valid_placement((0, 0, 0), item_dims, container_dims, occupied_volumes):\n                return 0, 0, 0\n            else:\n                return None, None, None\n\n        for item in occupied_volumes:\n            x = item['x'] + item['length']\n            y = item['y']\n            z = item['z']\n            potential_positions.append((x, y, z))\n\n            x = item['x']\n            y = item['y'] + item['width']\n            z = item['z']\n            potential_positions.append((x, y, z))\n\n            x = item['x']\n            y = item['y']\n            z = item['z'] + item['height']\n            potential_positions.append((x, y, z))\n        \n        for x, y, z in potential_positions:\n            if (x >= 0 and y >= 0 and z >= 0 and x + il <= l + self.epsilon and y + iw <= w + self.epsilon and z + ih <= h + self.epsilon):\n                if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                    return x, y, z\n\n        return None, None, None",
          "objective": 24.45,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     }
]