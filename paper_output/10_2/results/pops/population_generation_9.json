[
     {
          "algorithm": "Select item based on a score considering volume utilization and quantity, find the best placement in the first available truck using bottom-left-fill approach, favoring lower z coordinate and smaller wasted space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select item based on a score considering volume utilization and quantity, find the best placement in the first available truck using bottom-left-fill approach, favoring lower z coordinate and smaller wasted space.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items, truck_type)\n\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_best_placement(\n            unplaced_items[item_index], trucks_in_use, truck_type\n        )\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items, truck_type):\n        best_item_index = None\n        best_score = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                score = volume * (1 + np.log(item['quantity']))\n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_wasted_space = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            occupied_volumes = truck['occupied_volumes']\n\n            x, y, z, orientation_index, wasted_space = self._find_valid_position_in_truck(item_type, truck_type, occupied_volumes)\n            \n            if x is not None and wasted_space < best_wasted_space:\n                best_wasted_space = wasted_space\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation_index\n        \n        if best_truck_index is None:\n            x, y, z, orientation_index, wasted_space = self._find_valid_position_in_truck(item_type, truck_type, [])\n            if x is not None:\n                best_truck_index = -1\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation_index\n        \n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_valid_position_in_truck(self, item_type, container_dims, occupied_volumes):\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_wasted_space = float('inf')\n\n        for orientation_index, dims in self._get_orientations(item_type):\n            cl, cw, ch = container_dims\n            il, iw, ih = dims\n            \n            potential_positions = self._generate_potential_positions(container_dims, dims, occupied_volumes)\n\n            for x, y, z in potential_positions:                \n                if self._is_valid_placement((x, y, z), dims, container_dims, occupied_volumes):\n                    wasted_space = self._evaluate_wasted_space(dims, container_dims, occupied_volumes, (x, y, z))\n                    if wasted_space < best_wasted_space:\n                        best_wasted_space = wasted_space\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation, best_wasted_space\n                    \n    def _generate_potential_positions(self, container_dims, item_dims, occupied_volumes):\n        positions = set()\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n\n        if not occupied_volumes:\n            positions.add((0, 0, 0))\n            return [(0,0,0)]\n\n        for item in occupied_volumes:\n            # Bottom-Left-Fill Approach\n\n            x = item['x'] + item['length']\n            y = item['y']\n            z = item['z']\n            positions.add((x, y, z))\n\n            x = item['x']\n            y = item['y'] + item['width']\n            z = item['z']\n            positions.add((x, y, z))\n\n            x = item['x']\n            y = item['y']\n            z = item['z'] + item['height']\n            positions.add((x, y, z))\n\n        valid_positions = []\n        for x, y, z in positions:\n            if (x >= 0 and y >= 0 and z >= 0 and x + il <= cl + self.epsilon and y + iw <= cw + self.epsilon and z + ih <= ch + self.epsilon):\n                valid_positions.append((x,y,z))\n        \n        valid_positions.sort(key=lambda p: (p[2], (p[0]**2 + p[1]**2)**0.5))\n        \n        return valid_positions\n\n    def _evaluate_wasted_space(self, item_dims, container_dims, occupied_volumes, item_position):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        x, y, z = item_position\n\n        wasted_space = 0\n\n        wasted_space += x * cw * ch\n        wasted_space += y * cl * ch\n        wasted_space += z * cl * cw\n        wasted_space += (cl - (x + il)) * cw * ch\n        wasted_space += (cw - (y + iw)) * cl * ch\n        wasted_space += (ch - (z + ih)) * cl * cw\n\n        return wasted_space",
          "objective": 22.4,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Iteratively place items based on a volume-decreasing order, selecting the best valid placement in existing trucks or a new truck using a scoring system that prioritizes lower positions and minimizes wasted space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Iteratively place items based on a volume-decreasing order, selecting the best valid placement in existing trucks or a new truck using a scoring system that prioritizes lower positions and minimizes wasted space.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item_to_place(unplaced_items)\n\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_best_truck_and_position(\n            unplaced_items[item_index], trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item_to_place(self, unplaced_items):\n        available_items = [(i, item) for i, item in enumerate(unplaced_items) if item['quantity'] > 0]\n        if not available_items:\n            return None\n        \n        return max(available_items, key=lambda x: x[1]['length'] * x[1]['width'] * x[1]['height'])[0]\n\n    def _find_best_truck_and_position(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_placement_score = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            x, y, z, orientation, score = self._find_best_position_in_truck(\n                item_type, truck_type, truck['occupied_volumes'])\n            if score < best_placement_score:\n                best_placement_score = score\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n        \n        if best_truck_index is None:\n            x, y, z, orientation, score = self._find_best_position_in_truck(item_type, truck_type, [])\n            if x is not None:\n                best_truck_index = -1\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n        \n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item_type, container_dims, occupied_volumes):\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_score = float('inf')\n\n        for orientation_index, dims in self._get_orientations(item_type):\n            possible_positions = self._generate_candidate_positions(container_dims, dims, occupied_volumes)\n            for x, y, z in possible_positions:\n                if self._is_valid_placement((x, y, z), dims, container_dims, occupied_volumes):\n                    score = self._evaluate_placement((x, y, z), dims, container_dims)\n                    if score < best_score:\n                        best_score = score\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n        return best_x, best_y, best_z, best_orientation, best_score\n    \n    def _generate_candidate_positions(self, container_dims, item_dims, occupied_volumes):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        positions = set()\n\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        for item in occupied_volumes:\n            x = item['x'] + item['length']\n            y = item['y']\n            z = item['z']\n            positions.add((x, y, z))\n\n            x = item['x']\n            y = item['y'] + item['width']\n            z = item['z']\n            positions.add((x, y, z))\n\n            x = item['x']\n            y = item['y']\n            z = item['z'] + item['height']\n            positions.add((x, y, z))\n\n        valid_positions = []\n        for x, y, z in positions:\n            if (x >= 0 - self.epsilon and y >= 0 - self.epsilon and z >= 0 - self.epsilon and\n                    x + il <= cl + self.epsilon and y + iw <= cw + self.epsilon and z + ih <= ch + self.epsilon):\n                valid_positions.append((x, y, z))\n\n        valid_positions = sorted(list(valid_positions), key=lambda p: (p[2], p[1], p[0]))\n        return valid_positions\n\n    def _evaluate_placement(self, position, item_dims, container_dims):\n        x, y, z = position\n        l, w, h = item_dims\n        cl, cw, ch = container_dims\n        \n        score = (z * cl * cw) + (y * cl * ch) + (x * cw * ch)\n        score += ((cl - (x + l)) * (cw * ch * 0.1))\n        score += ((cw - (y + w)) * (cl * ch * 0.1))\n        score += ((ch - (z + h)) * (cl * cw * 0.1))\n\n        return score",
          "objective": 22.9,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Iteratively select items based on a volume-weighted remaining quantity, then places items in the best available position, prioritizing lower Z values, then X and Y, minimizing wasted space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Iteratively select items based on a volume-weighted remaining quantity, then places items in the best available position, prioritizing lower Z values, then X and Y, minimizing wasted space.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items, truck_type)\n\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_best_placement(\n            unplaced_items[item_index], trucks_in_use, truck_type\n        )\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items, truck_type):\n        best_item_index = None\n        best_score = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                score = volume * item['quantity']\n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_placement_score = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            occupied_volumes = truck['occupied_volumes']\n\n            x, y, z, orientation_index, placement_score = self._evaluate_potential_placements(item_type, truck_type, occupied_volumes)\n            \n            if x is not None and placement_score < best_placement_score:\n                best_placement_score = placement_score\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation_index\n        \n        if best_truck_index is None:\n            x, y, z, orientation_index, placement_score = self._evaluate_potential_placements(item_type, truck_type, [])\n            if x is not None:\n                best_truck_index = -1\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation_index\n        \n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _evaluate_potential_placements(self, item_type, container_dims, occupied_volumes):\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_placement_score = float('inf')\n        \n        for orientation_index, dims in self._get_orientations(item_type):\n            cl, cw, ch = container_dims\n            il, iw, ih = dims\n            \n            potential_positions = self._generate_potential_positions(container_dims, dims, occupied_volumes)\n\n            for x, y, z in potential_positions:                \n                if self._is_valid_placement((x, y, z), dims, container_dims, occupied_volumes):\n                    placement_score = self._predict_placement_score(dims, container_dims, occupied_volumes, (x, y, z))\n                    if placement_score < best_placement_score:\n                        best_placement_score = placement_score\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation, best_placement_score\n    \n    def _generate_potential_positions(self, container_dims, item_dims, occupied_volumes):\n        positions = set()\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        for item in occupied_volumes:\n            x = item['x'] + item['length']\n            y = item['y']\n            z = item['z']\n            positions.add((x, y, z))\n\n            x = item['x']\n            y = item['y'] + item['width']\n            z = item['z']\n            positions.add((x, y, z))\n\n            x = item['x']\n            y = item['y']\n            z = item['z'] + item['height']\n            positions.add((x, y, z))\n        \n        valid_positions = []\n        for x, y, z in positions:\n            if (x >= 0 and y >= 0 and z >= 0 and x + il <= cl + self.epsilon and y + iw <= cw + self.epsilon and z + ih <= ch + self.epsilon):\n                valid_positions.append((x,y,z))\n        \n        valid_positions.sort(key=lambda p: (p[2], p[0], p[1]))\n        \n        return valid_positions\n    \n    def _predict_placement_score(self, item_dims, container_dims, occupied_volumes, item_position):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        x, y, z = item_position\n\n        remaining_length = cl - (x + il)\n        remaining_width = cw - (y + iw)\n        remaining_height = ch - (z + ih)\n\n        remaining_volume = remaining_length * remaining_width * remaining_height\n\n        normalized_remaining_volume = remaining_volume / (cl * cw * ch) if (cl * cw * ch) > 0 else 0\n\n        placement_score = normalized_remaining_volume\n        return placement_score",
          "objective": 23.1,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Select item based on a quantity-weighted volume, scaled by a density factor, and place based on minimizing wasted space around the item.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select item based on a quantity-weighted volume, scaled by a density factor, and place based on minimizing wasted space around the item.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items, truck_type)\n\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_best_placement(\n            unplaced_items[item_index], trucks_in_use, truck_type\n        )\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items, truck_type):\n        best_item_index = None\n        best_score = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                density = item['quantity'] / volume if volume > 0 else 0\n                score = volume * item['quantity'] * (density**0.2)  # Adjusted scaling\n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_placement_score = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            occupied_volumes = truck['occupied_volumes']\n\n            x, y, z, orientation_index, placement_score = self._evaluate_potential_placements(item_type, truck_type, occupied_volumes)\n            \n            if x is not None and placement_score < best_placement_score:\n                best_placement_score = placement_score\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation_index\n        \n        if best_truck_index is None:\n            x, y, z, orientation_index, placement_score = self._evaluate_potential_placements(item_type, truck_type, [])\n            if x is not None:\n                best_truck_index = -1\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation_index\n        \n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _evaluate_potential_placements(self, item_type, container_dims, occupied_volumes):\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_placement_score = float('inf')\n        \n        for orientation_index, dims in self._get_orientations(item_type):\n            cl, cw, ch = container_dims\n            il, iw, ih = dims\n            \n            potential_positions = self._generate_potential_positions(container_dims, dims, occupied_volumes)\n\n            for x, y, z in potential_positions:                \n                if self._is_valid_placement((x, y, z), dims, container_dims, occupied_volumes):\n                    placement_score = self._predict_placement_score(dims, container_dims, occupied_volumes, (x, y, z))\n                    if placement_score < best_placement_score:\n                        best_placement_score = placement_score\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation, best_placement_score\n    \n    def _generate_potential_positions(self, container_dims, item_dims, occupied_volumes):\n        positions = set()\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        for item in occupied_volumes:\n\n            x = item['x'] + item['length']\n            y = item['y']\n            z = item['z']\n            positions.add((x, y, z))\n\n            x = item['x']\n            y = item['y'] + item['width']\n            z = item['z']\n            positions.add((x, y, z))\n\n            x = item['x']\n            y = item['y']\n            z = item['z'] + item['height']\n            positions.add((x, y, z))\n\n        valid_positions = []\n        for x, y, z in positions:\n            if (x >= 0 and y >= 0 and z >= 0 and x + il <= cl + self.epsilon and y + iw <= cw + self.epsilon and z + ih <= ch + self.epsilon):\n                valid_positions.append((x,y,z))\n        \n        valid_positions.sort(key=lambda p: (p[2], (p[0]**2 + p[1]**2)**0.5))\n        \n        return valid_positions\n    \n    def _predict_placement_score(self, item_dims, container_dims, occupied_volumes, item_position):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        x, y, z = item_position\n\n        # Calculate remaining space in each dimension\n        remaining_length = cl - (x + il)\n        remaining_width = cw - (y + iw)\n        remaining_height = ch - (z + ih)\n\n        # Calculate the volume of remaining space\n        remaining_volume = remaining_length * remaining_width * remaining_height\n\n        # Normalize remaining space by container volume\n        normalized_remaining_volume = remaining_volume / (cl * cw * ch) if (cl * cw * ch) > 0 else 0\n\n        # The goal is to minimize the remaining space\n        placement_score = normalized_remaining_volume\n        return placement_score",
          "objective": 23.2,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Select item based on a score considering area utilization and quantity, find the best placement in the first available truck using bottom-left-fill approach, prioritizing maximal z coordinate and smaller wasted space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select item based on a score considering area utilization and quantity, find the best placement in the first available truck using bottom-left-fill approach, prioritizing maximal z coordinate and smaller wasted space.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items, truck_type)\n\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_best_placement(\n            unplaced_items[item_index], trucks_in_use, truck_type\n        )\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items, truck_type):\n        best_item_index = None\n        best_score = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                area = item['length'] * item['width']\n                score = area * (1 + np.log(item['quantity']))\n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_wasted_space = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            occupied_volumes = truck['occupied_volumes']\n\n            x, y, z, orientation_index, wasted_space = self._find_valid_position_in_truck(item_type, truck_type, occupied_volumes)\n            \n            if x is not None and wasted_space < best_wasted_space:\n                best_wasted_space = wasted_space\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation_index\n        \n        if best_truck_index is None:\n            x, y, z, orientation_index, wasted_space = self._find_valid_position_in_truck(item_type, truck_type, [])\n            if x is not None:\n                best_truck_index = -1\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation_index\n        \n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_valid_position_in_truck(self, item_type, container_dims, occupied_volumes):\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_wasted_space = float('inf')\n\n        for orientation_index, dims in self._get_orientations(item_type):\n            cl, cw, ch = container_dims\n            il, iw, ih = dims\n            \n            potential_positions = self._generate_potential_positions(container_dims, dims, occupied_volumes)\n\n            for x, y, z in potential_positions:                \n                if self._is_valid_placement((x, y, z), dims, container_dims, occupied_volumes):\n                    wasted_space = self._evaluate_wasted_space(dims, container_dims, occupied_volumes, (x, y, z))\n                    if wasted_space < best_wasted_space:\n                        best_wasted_space = wasted_space\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation, best_wasted_space\n                    \n    def _generate_potential_positions(self, container_dims, item_dims, occupied_volumes):\n        positions = set()\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n\n        if not occupied_volumes:\n            positions.add((0, 0, 0))\n            return [(0,0,0)]\n\n        for item in occupied_volumes:\n\n            x = item['x'] + item['length']\n            y = item['y']\n            z = item['z']\n            positions.add((x, y, z))\n\n            x = item['x']\n            y = item['y'] + item['width']\n            z = item['z']\n            positions.add((x, y, z))\n\n            x = item['x']\n            y = item['y']\n            z = item['z'] + item['height']\n            positions.add((x, y, z))\n\n        valid_positions = []\n        for x, y, z in positions:\n            if (x >= 0 and y >= 0 and z >= 0 and x + il <= cl + self.epsilon and y + iw <= cw + self.epsilon and z + ih <= ch + self.epsilon):\n                valid_positions.append((x,y,z))\n        \n        valid_positions.sort(key=lambda p: (-p[2], (p[0]**2 + p[1]**2)**0.5))\n        \n        return valid_positions\n\n    def _evaluate_wasted_space(self, item_dims, container_dims, occupied_volumes, item_position):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        x, y, z = item_position\n\n        wasted_space = 0\n\n        wasted_space += x * cw * ch\n        wasted_space += y * cl * ch\n        wasted_space += z * cl * cw\n        wasted_space += (cl - (x + il)) * cw * ch\n        wasted_space += (cw - (y + iw)) * cl * ch\n        wasted_space += (ch - (z + ih)) * cl * cw\n\n        return wasted_space",
          "objective": 23.35,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]