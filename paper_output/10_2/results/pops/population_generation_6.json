[
     {
          "algorithm": "Prioritize items based on volume, then select the best placement utilizing a limited, distributed search space, minimizing wasted space, and favoring placement in existing trucks.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Prioritize items based on volume, then select the best placement utilizing a limited, distributed search space, minimizing wasted space, and favoring placement in existing trucks.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_best_placement(\n            unplaced_items[item_index], trucks_in_use, truck_type\n        )\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        best_volume = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > best_volume:\n                    best_volume = volume\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_wasted_space = float('inf')\n\n        truck_index = 0\n        while truck_index <= len(trucks_in_use):\n            if truck_index < len(trucks_in_use):\n                truck = trucks_in_use[truck_index]\n                occupied_volumes = truck['occupied_volumes']\n            else:\n                occupied_volumes = []\n\n            for orientation_index, dims in self._get_orientations(item_type):\n                x, y, z = self._find_valid_position(dims, truck_type, occupied_volumes)\n\n                if x is not None:\n                    wasted_space = self._evaluate_wasted_space(dims, truck_type, occupied_volumes, (x, y, z))\n                    if wasted_space < best_wasted_space:\n                        best_wasted_space = wasted_space\n                        best_truck_index = truck_index if truck_index < len(trucks_in_use) else -1\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n\n            truck_index += 1\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_valid_position(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = container_dims\n        il, iw, ih = item_dims\n\n        num_x_steps = 3\n        num_y_steps = 3\n        num_z_steps = 3\n\n        x_step_size = (l - il) / (num_x_steps - 1) if num_x_steps > 1 else 0\n        y_step_size = (w - iw) / (num_y_steps - 1) if num_y_steps > 1 else 0\n        z_step_size = (h - ih) / (num_z_steps - 1) if num_z_steps > 1 else 0\n\n        for i in range(num_x_steps):\n            for j in range(num_y_steps):\n                for k in range(num_z_steps):\n                    x = round(i * x_step_size, 6)\n                    y = round(j * y_step_size, 6)\n                    z = round(k * z_step_size, 6)\n\n                    if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                        return x, y, z\n\n        return None, None, None\n\n    def _evaluate_wasted_space(self, item_dims, container_dims, occupied_volumes, item_position):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        x, y, z = item_position\n\n        wasted_space = 0\n\n        wasted_space += x * cw * ch\n        wasted_space += y * cl * ch\n        wasted_space += z * cl * cw\n        wasted_space += (cl - (x + il)) * cw * ch\n        wasted_space += (cw - (y + iw)) * cl * ch\n        wasted_space += (ch - (z + ih)) * cl * cw\n\n        return wasted_space\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_valid_position(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = container_dims\n        il, iw, ih = item_dims\n\n        potential_positions = []\n\n        if not occupied_volumes:\n            if self._is_valid_placement((0, 0, 0), item_dims, container_dims, occupied_volumes):\n                return 0, 0, 0\n            else:\n                return None, None, None\n\n        for item in occupied_volumes:\n            x = item['x'] + item['length']\n            y = item['y']\n            z = item['z']\n            potential_positions.append((x, y, z))\n\n            x = item['x']\n            y = item['y'] + item['width']\n            z = item['z']\n            potential_positions.append((x, y, z))\n\n            x = item['x']\n            y = item['y']\n            z = item['z'] + item['height']\n            potential_positions.append((x, y, z))\n\n        for x, y, z in potential_positions:\n            if (x >= 0 and y >= 0 and z >= 0 and x + il <= l + self.epsilon and y + iw <= w + self.epsilon and z + ih <= h + self.epsilon):\n                if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                    return x, y, z\n\n        return None, None, None",
          "objective": 24.2,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     },
     {
          "algorithm": "Prioritize packing item types with the largest footprint (area) on the base of the container, select the best orientation and position based on minimizing wasted space around the item.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Prioritize packing item types with the largest footprint (area) on the base of the container, select the best orientation and position based on minimizing wasted space around the item.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_best_placement(\n            unplaced_items[item_index], trucks_in_use, truck_type\n        )\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        best_footprint = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                footprint = item['length'] * item['width']\n                if footprint > best_footprint:\n                    best_footprint = footprint\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_wasted_space = float('inf')\n\n        for truck_index in range(len(trucks_in_use)):\n            truck = trucks_in_use[truck_index]\n            occupied_volumes = truck['occupied_volumes']\n\n            for orientation_index, dims in self._get_orientations(item_type):\n                x, y, z = self._find_valid_position(dims, truck_type, occupied_volumes)\n\n                if x is not None:\n                    wasted_space = self._evaluate_wasted_space(dims, truck_type, occupied_volumes, (x, y, z))\n                    if wasted_space < best_wasted_space:\n                        best_wasted_space = wasted_space\n                        best_truck_index = truck_index\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n\n        for orientation_index, dims in self._get_orientations(item_type):\n            x, y, z = self._find_valid_position(dims, truck_type, [])\n\n            if x is not None:\n                wasted_space = self._evaluate_wasted_space(dims, truck_type, [], (x, y, z))\n                if wasted_space < best_wasted_space:\n                    best_wasted_space = wasted_space\n                    best_truck_index = -1\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation_index\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_valid_position(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = container_dims\n        il, iw, ih = item_dims\n\n        for x in np.arange(0, l - il + self.epsilon, min(il, iw, ih) / 2 if min(il, iw, ih) > 0 else 1 ):\n            for y in np.arange(0, w - iw + self.epsilon, min(il, iw, ih) / 2 if min(il, iw, ih) > 0 else 1 ):\n                for z in np.arange(0, h - ih + self.epsilon, min(il, iw, ih) / 2 if min(il, iw, ih) > 0 else 1 ):\n                    x = round(x, 6)\n                    y = round(y, 6)\n                    z = round(z, 6)\n                    if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                        return x, y, z\n\n        return None, None, None\n\n    def _evaluate_wasted_space(self, item_dims, container_dims, occupied_volumes, item_position):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        x, y, z = item_position\n\n        wasted_space = 0\n\n        wasted_space += x * cw * ch\n        wasted_space += y * cl * ch\n        wasted_space += z * cl * cw\n        wasted_space += (cl - (x + il)) * cw * ch\n        wasted_space += (cw - (y + iw)) * cl * ch\n        wasted_space += (ch - (z + ih)) * cl * cw\n\n        return wasted_space\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_valid_position(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = container_dims\n        il, iw, ih = item_dims\n\n        num_x_steps = min(5, int((l - il) / (il / 2 if il > 0 else 1)) + 1)\n        num_y_steps = min(5, int((w - iw) / (iw / 2 if iw > 0 else 1)) + 1)\n        num_z_steps = min(5, int((h - ih) / (ih / 2 if ih > 0 else 1)) + 1)\n\n        x_step_size = (l - il) / (num_x_steps - 1) if num_x_steps > 1 else 0\n        y_step_size = (w - iw) / (num_y_steps - 1) if num_y_steps > 1 else 0\n        z_step_size = (h - ih) / (num_z_steps - 1) if num_z_steps > 1 else 0\n\n        for i in range(num_x_steps):\n            for j in range(num_y_steps):\n                for k in range(num_z_steps):\n                    x = round(i * x_step_size, 6)\n                    y = round(j * y_step_size, 6)\n                    z = round(k * z_step_size, 6)\n                    \n                    if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                        return x, y, z\n\n        return None, None, None\nimport numpy as np\n\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_valid_position(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = container_dims\n        il, iw, ih = item_dims\n\n        potential_positions = []\n\n        if not occupied_volumes:\n            if self._is_valid_placement((0, 0, 0), item_dims, container_dims, occupied_volumes):\n                return 0, 0, 0\n            else:\n                return None, None, None\n\n        for item in occupied_volumes:\n            x = item['x'] + item['length']\n            y = item['y']\n            z = item['z']\n            potential_positions.append((x, y, z))\n\n            x = item['x']\n            y = item['y'] + item['width']\n            z = item['z']\n            potential_positions.append((x, y, z))\n\n            x = item['x']\n            y = item['y']\n            z = item['z'] + item['height']\n            potential_positions.append((x, y, z))\n        \n        for x, y, z in potential_positions:\n            if (x >= 0 and y >= 0 and z >= 0 and x + il <= l + self.epsilon and y + iw <= w + self.epsilon and z + ih <= h + self.epsilon):\n                if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                    return x, y, z\n\n        return None, None, None",
          "objective": 24.45,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     },
     {
          "algorithm": "Iteratively select an item type based on a combined score of quantity and volume, then find the best placement (truck and orientation) based on a greedy heuristic maximizing the smallest remaining space after placement.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Iteratively select an item type based on a combined score of quantity and volume, then find the best placement (truck and orientation) based on a greedy heuristic maximizing the smallest remaining space after placement.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_best_placement(\n            unplaced_items[item_index], trucks_in_use, truck_type\n        )\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        best_score = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                score = (item['quantity'] ** 0.5) * volume  # Combine quantity and volume\n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_remaining_space = float('inf')\n\n        for truck_index in range(len(trucks_in_use)):\n            truck = trucks_in_use[truck_index]\n            occupied_volumes = truck['occupied_volumes']\n\n            for orientation_index, dims in self._get_orientations(item_type):\n                x, y, z = self._find_valid_position(dims, truck_type, occupied_volumes)\n\n                if x is not None:\n                    remaining_space = self._evaluate_remaining_space(dims, truck_type, occupied_volumes, (x, y, z))\n                    if remaining_space < best_remaining_space:\n                        best_remaining_space = remaining_space\n                        best_truck_index = truck_index\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n\n        # Check if it's better to open a new truck\n        for orientation_index, dims in self._get_orientations(item_type):\n            x, y, z = self._find_valid_position(dims, truck_type, [])\n            if x is not None:\n                remaining_space = self._evaluate_remaining_space(dims, truck_type, [], (x, y, z))\n                if remaining_space < best_remaining_space:\n                    best_truck_index = -1\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation_index\n                    best_remaining_space = remaining_space\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_valid_position(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = container_dims\n        il, iw, ih = item_dims\n\n        for x in np.arange(0, l - il + self.epsilon, il / 2 if il > 0 else 1):\n            for y in np.arange(0, w - iw + self.epsilon, iw / 2 if iw > 0 else 1):\n                for z in np.arange(0, h - ih + self.epsilon, ih / 2 if ih > 0 else 1):\n                    x = round(x, 6)\n                    y = round(y, 6)\n                    z = round(z, 6)\n                    if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                        return x, y, z\n        return None, None, None\n\n    def _evaluate_remaining_space(self, item_dims, container_dims, occupied_volumes, item_position):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        x, y, z = item_position\n\n        total_volume = cl * cw * ch\n        occupied_volume = 0.0\n        new_item = {'x': x, 'y': y, 'z': z, 'length': il, 'width': iw, 'height': ih}\n        all_volumes = occupied_volumes + [new_item]\n\n        for item in all_volumes:\n            occupied_volume += item['length'] * item['width'] * item['height']\n        \n        return total_volume - occupied_volume\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_valid_position(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = container_dims\n        il, iw, ih = item_dims\n\n        num_x_steps = min(10, int((l - il) / (il / 2 if il > 0 else 1)) + 1)\n        num_y_steps = min(10, int((w - iw) / (iw / 2 if iw > 0 else 1)) + 1)\n        num_z_steps = min(10, int((h - ih) / (ih / 2 if ih > 0 else 1)) + 1)\n\n        x_step_size = (l - il) / (num_x_steps - 1) if num_x_steps > 1 else 0\n        y_step_size = (w - iw) / (num_y_steps - 1) if num_y_steps > 1 else 0\n        z_step_size = (h - ih) / (num_z_steps - 1) if num_z_steps > 1 else 0\n\n        for i in range(num_x_steps):\n            for j in range(num_y_steps):\n                for k in range(num_z_steps):\n                    x = round(i * x_step_size, 6)\n                    y = round(j * y_step_size, 6)\n                    z = round(k * z_step_size, 6)\n                    \n                    if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                        return x, y, z\n        return None, None, None\nimport numpy as np\n\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_valid_position(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = container_dims\n        il, iw, ih = item_dims\n\n        potential_positions = []\n\n        if not occupied_volumes:\n            if self._is_valid_placement((0, 0, 0), item_dims, container_dims, occupied_volumes):\n                return 0, 0, 0\n            else:\n                return None, None, None\n\n        for item in occupied_volumes:\n            # Add positions adjacent to existing items\n            x = item['x'] + item['length']\n            y = item['y']\n            z = item['z']\n            potential_positions.append((x, y, z))\n\n            x = item['x']\n            y = item['y'] + item['width']\n            z = item['z']\n            potential_positions.append((x, y, z))\n\n            x = item['x']\n            y = item['y']\n            z = item['z'] + item['height']\n            potential_positions.append((x, y, z))\n            \n        \n        for x, y, z in potential_positions:\n            if (x >= 0 and y >= 0 and z >= 0 and x + il <= l and y + iw <= w and z + ih <= h):\n                if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                        return x, y, z\n\n        return None, None, None",
          "objective": 24.65,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     },
     {
          "algorithm": "Selects items based on remaining quantity and volume, tries orientations, places if valid, else repeats with next best item/orientation and opens new trucks when necessary.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects items based on remaining quantity and volume, tries orientations, places if valid, else repeats with next best item/orientation and opens new trucks when necessary.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index = -1\n        item_index = -1\n        x = 0\n        y = 0\n        z = 0\n        orientation = 0\n\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, 0, 0, 0, 0\n\n        best_truck_index, best_x, best_y, best_z, best_orientation = self._find_best_placement(\n            unplaced_items[item_index], trucks_in_use, truck_type\n        )\n\n        if best_truck_index == -1:\n            truck_index = -1\n            x = 0\n            y = 0\n            z = 0\n            orientation = best_orientation\n        else:\n            truck_index = best_truck_index\n            x = best_x\n            y = best_y\n            z = best_z\n            orientation = best_orientation\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        best_score = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                score = item['quantity'] * volume\n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x = 0\n        best_y = 0\n        best_z = 0\n        best_orientation = 0\n        best_volume_utilization = -1\n\n        for truck_index in range(len(trucks_in_use)):\n            occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n            for orientation, dims in self._get_orientations(item_type):\n                length, width, height = dims\n\n                potential_positions = self._generate_potential_positions(truck_type, length, width, height, occupied_volumes)\n                for x, y, z in potential_positions:\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                        volume_utilization = length * width * height\n                        if volume_utilization > best_volume_utilization:\n                            best_volume_utilization = volume_utilization\n                            best_truck_index = truck_index\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            best_orientation = orientation\n\n        if best_truck_index == -1:\n            for orientation, dims in self._get_orientations(item_type):\n                length, width, height = dims\n                if self._is_valid_placement((0, 0, 0), (length, width, height), truck_type, []):\n                    best_truck_index = -1\n                    best_x = 0\n                    best_y = 0\n                    best_z = 0\n                    best_orientation = orientation\n                    break\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _generate_potential_positions(self, container_dims, length, width, height, occupied_volumes):\n        potential_positions = []\n        if not occupied_volumes:\n            return [(0,0,0)]\n        \n        for item in occupied_volumes:\n            x = item['x'] + item['length']\n            y = item['y']\n            z = item['z']\n            potential_positions.append((x, y, z))\n            \n            x = item['x']\n            y = item['y'] + item['width']\n            z = item['z']\n            potential_positions.append((x, y, z))\n            \n            x = item['x']\n            y = item['y']\n            z = item['z'] + item['height']\n            potential_positions.append((x, y, z))\n\n        return potential_positions",
          "objective": 24.7,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Iteratively select the largest remaining item, place it in the best-fit location considering both existing trucks and the possibility of starting a new truck, prioritizing compact arrangements.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Iteratively select the largest remaining item, place it in the best-fit location considering both existing trucks and the possibility of starting a new truck, prioritizing compact arrangements.}\n\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        best_truck_index, placement_details = self._find_best_placement(unplaced_items[item_index], trucks_in_use, truck_type)\n\n        if best_truck_index == -1:\n            x, y, z, orientation = placement_details\n        else:\n            x, y, z, orientation = placement_details\n\n        if best_truck_index is not None:\n          best_truck_index = int(best_truck_index)\n        if item_index is not None:\n          item_index = int(item_index)\n        if orientation is not None:\n          orientation = int(orientation)\n            \n        return best_truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        item_volumes = [(i, item['length'] * item['width'] * item['height']) for i, item in enumerate(unplaced_items) if item['quantity'] > 0]\n        if not item_volumes:\n            return None\n        return max(item_volumes, key=lambda x: x[1])[0]\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_placement = None\n        best_volume_utilization = -1.0\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            placement_details = self._find_placement_in_truck(item_type, truck_type, truck['occupied_volumes'])\n            if placement_details:\n                x, y, z, orientation, dims = placement_details\n                volume_utilization = self._calculate_volume_utilization(truck_type, truck['occupied_volumes'], dims)\n\n                if volume_utilization > best_volume_utilization:\n                    best_truck_index = truck_index\n                    best_placement = (x, y, z, orientation)\n                    best_volume_utilization = volume_utilization\n        \n        new_truck_placement = self._find_placement_in_truck(item_type, truck_type, [])\n        if new_truck_placement:\n            x, y, z, orientation, dims = new_truck_placement\n            volume_utilization = self._calculate_volume_utilization(truck_type, [], dims)\n            if volume_utilization > best_volume_utilization:\n                best_truck_index = -1\n                best_placement = (x, y, z, orientation)\n                best_volume_utilization = volume_utilization\n\n        return best_truck_index, best_placement\n\n    def _find_placement_in_truck(self, item_type, container_dims, occupied_volumes):\n        for orientation_index, item_dims in self._get_orientations(item_type):\n            \n            # Try bottom-left-front corner\n            x, y, z = 0.0, 0.0, 0.0\n            if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                return x, y, z, orientation_index, item_dims\n            \n            # Try fitting next to existing items\n            for volume in occupied_volumes:\n                # Check top\n                new_x, new_y, new_z = volume['x'], volume['y'], volume['z'] + volume['height']\n                if self._is_valid_placement((new_x, new_y, new_z), item_dims, container_dims, occupied_volumes):\n                    return new_x, new_y, new_z, orientation_index, item_dims\n\n                # Check right\n                new_x, new_y, new_z = volume['x'] + volume['length'], volume['y'], volume['z']\n                if self._is_valid_placement((new_x, new_y, new_z), item_dims, container_dims, occupied_volumes):\n                    return new_x, new_y, new_z, orientation_index, item_dims\n\n                # Check front\n                new_x, new_y, new_z = volume['x'], volume['y'] + volume['width'], volume['z']\n                if self._is_valid_placement((new_x, new_y, new_z), item_dims, container_dims, occupied_volumes):\n                    return new_x, new_y, new_z, orientation_index, item_dims\n\n        return None\n\n    def _calculate_volume_utilization(self, container_dims, occupied_volumes, item_dims):\n        container_volume = container_dims[0] * container_dims[1] * container_dims[2]\n        occupied_volume = sum(item['length'] * item['width'] * item['height'] for item in occupied_volumes)\n        item_volume = item_dims[0] * item_dims[1] * item_dims[2]\n        return (occupied_volume + item_volume) / container_volume",
          "objective": 24.75,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]