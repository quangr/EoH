[
     {
          "algorithm": "Selects the item type with the largest volume and places it in the truck and orientation that minimizes height, prioritizing lower Z positions.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item type with the largest volume and places it in the truck and orientation that minimizes height, prioritizing lower Z positions.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items[item_index], trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                volume = item_type['length'] * item_type['width'] * item_type['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = 0\n        min_height = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            for orientation, dims in self._get_orientations(item_type):\n                positions = self._get_potential_positions(dims, truck_type, truck['occupied_volumes'])\n                for x, y, z in positions:\n                    if self._is_valid_placement((x, y, z), dims, truck_type, truck['occupied_volumes']):\n                        height = z + dims[2] \n                        if height < min_height:\n                            min_height = height\n                            best_truck_index = truck_index\n                            best_x, best_y, best_z = x, y, z\n                            best_orientation = orientation\n\n        if best_truck_index == -1:\n            \n            best_x, best_y, best_z = 0, 0, 0\n            min_height = float('inf')\n            for orientation, dims in self._get_orientations(item_type):\n                if self._is_valid_placement((0, 0, 0), dims, truck_type, []):\n                    height = dims[2]\n                    if height < min_height:\n                        min_height = height\n                        best_x, best_y, best_z = 0, 0, 0\n                        best_orientation = orientation\n                        best_truck_index = -1\n                    \n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _get_potential_positions(self, item_dims, container_dims, occupied_volumes):\n        positions = []\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        for placed_item in occupied_volumes:\n            x = placed_item['x'] + placed_item['length']\n            y = placed_item['y']\n            z = placed_item['z']\n            if x + item_dims[0] <= container_dims[0] and self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                positions.append((x, y, z))\n\n            x = placed_item['x']\n            y = placed_item['y'] + placed_item['width']\n            z = placed_item['z']\n            if y + item_dims[1] <= container_dims[1] and self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                positions.append((x, y, z))\n            \n            x = placed_item['x']\n            y = placed_item['y']\n            z = placed_item['z'] + placed_item['height']\n            if z + item_dims[2] <= container_dims[2] and self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                positions.append((x, y, z))\n        \n        return positions",
          "objective": 22.1,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Iteratively selects the item with the largest volume, finds the best orientation and position with minimum wasted space, and places it in the best-fit container.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Iteratively selects the item with the largest volume, finds the best orientation and position with minimum wasted space, and places it in the best-fit container.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index = -1\n        item_index = -1\n        x = 0.0\n        y = 0.0\n        z = 0.0\n        orientation = 0\n\n        best_item_index = self._select_item(unplaced_items)\n\n        if best_item_index == -1:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n            \n        best_truck_index, best_orientation, best_position = self._find_best_placement(\n            unplaced_items[best_item_index], trucks_in_use, truck_type\n        )\n        \n        item_index = best_item_index\n        if best_truck_index == -1:\n            truck_index = -1\n            orientation = best_orientation\n            x, y, z = best_position\n        else:\n            truck_index = best_truck_index\n            orientation = best_orientation\n            x, y, z = best_position\n            \n        return truck_index, item_index, x, y, z, orientation    \n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_orientation = -1\n        best_position = (0.0, 0.0, 0.0)\n        min_waste = float('inf')\n\n        for truck_index in range(-1, len(trucks_in_use)):\n            if truck_index == -1:\n                occupied_volumes = []\n            else:\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n            for orientation, dims in self._get_orientations(item_type):\n                length, width, height = dims\n                \n                positions = self._find_valid_positions(dims, truck_type, occupied_volumes)\n                \n                for pos in positions:\n                    if self._is_valid_placement(pos, dims, truck_type, occupied_volumes):\n                        waste = self._calculate_waste(pos, dims, truck_type, occupied_volumes)\n                        if waste < min_waste:\n                            min_waste = waste\n                            best_truck_index = truck_index\n                            best_orientation = orientation\n                            best_position = pos\n\n        return best_truck_index, best_orientation, best_position\n    \n    def _find_valid_positions(self, item_dims, container_dims, occupied_volumes):\n        valid_positions = []\n        if not occupied_volumes:\n            return [(0.0, 0.0, 0.0)]\n            \n        for item in occupied_volumes:\n            x = item['x'] + item['length']\n            y = item['y'] + item['width']\n            z = item['z'] + item['height']\n\n            valid_positions.append((x, item['y'], item['z']))\n            valid_positions.append((item['x'], y, item['z']))\n            valid_positions.append((item['x'], item['y'], z))\n            \n        return valid_positions\n        \n    def _calculate_waste(self, item_pos, item_dims, container_dims, occupied_volumes):\n        total_volume = container_dims[0] * container_dims[1] * container_dims[2]\n        occupied_volume = 0\n        \n        item_volume = item_dims[0] * item_dims[1] * item_dims[2]\n        occupied_volume += item_volume\n\n        for item in occupied_volumes:\n            occupied_volume += item['length'] * item['width'] * item['height']\n            \n        return total_volume - occupied_volume",
          "objective": 24.7,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects the item type with the largest remaining quantity and places it in the truck and orientation that minimizes the wasted space, considering a limited number of potential placement positions.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item type with the largest remaining quantity and places it in the truck and orientation that minimizes the wasted space, considering a limited number of potential placement positions.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items[item_index], trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_quantity = -1\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                if item_type['quantity'] > max_quantity:\n                    max_quantity = item_type['quantity']\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = 0\n        min_wasted_space = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            for orientation, dims in self._get_orientations(item_type):\n                positions = self._get_potential_positions(dims, truck_type, truck['occupied_volumes'])\n                for x, y, z in positions:\n                    if self._is_valid_placement((x, y, z), dims, truck_type, truck['occupied_volumes']):\n                        wasted_space = self._calculate_wasted_space((x, y, z), dims, truck_type, truck['occupied_volumes'])\n                        if wasted_space < min_wasted_space:\n                            min_wasted_space = wasted_space\n                            best_truck_index = truck_index\n                            best_x, best_y, best_z = x, y, z\n                            best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_truck_index = -1\n            best_x, best_y, best_z = 0, 0, 0\n            min_wasted_space = float('inf')\n            for orientation, dims in self._get_orientations(item_type):\n                if self._is_valid_placement((0, 0, 0), dims, truck_type, []):\n                    wasted_space = truck_type[0] * truck_type[1] * truck_type[2] - dims[0] * dims[1] * dims[2]\n                    if wasted_space < min_wasted_space:\n                        min_wasted_space = wasted_space\n                        best_x, best_y, best_z = 0, 0, 0\n                        best_orientation = orientation\n                    break\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _get_potential_positions(self, item_dims, container_dims, occupied_volumes):\n        positions = []\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        for placed_item in occupied_volumes:\n            x = placed_item['x'] + placed_item['length']\n            y = placed_item['y']\n            z = placed_item['z']\n            if x + item_dims[0] <= container_dims[0] and self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                positions.append((x, y, z))\n\n            x = placed_item['x']\n            y = placed_item['y'] + placed_item['width']\n            z = placed_item['z']\n            if y + item_dims[1] <= container_dims[1] and self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                positions.append((x, y, z))\n            \n            x = placed_item['x']\n            y = placed_item['y']\n            z = placed_item['z'] + placed_item['height']\n            if z + item_dims[2] <= container_dims[2] and self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                positions.append((x, y, z))\n        \n        return positions\n\n    def _calculate_wasted_space(self, item_pos, item_dims, container_dims, occupied_volumes):\n        total_volume = container_dims[0] * container_dims[1] * container_dims[2]\n        occupied_volume = 0\n        for placed_item in occupied_volumes:\n            occupied_volume += placed_item['length'] * placed_item['width'] * placed_item['height']\n        occupied_volume += item_dims[0] * item_dims[1] * item_dims[2]\n        return total_volume - occupied_volume",
          "objective": 25.05,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects the item type with the largest volume, then tries to place it in the fullest truck using the orientation that best fills the remaining space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item type with the largest volume, then tries to place it in the fullest truck using the orientation that best fills the remaining space.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items[item_index], trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                volume = item_type['length'] * item_type['width'] * item_type['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = 0\n        max_filled_space = -1\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            for orientation, dims in self._get_orientations(item_type):\n                x, y, z = self._find_position_in_truck(dims, truck_type, truck['occupied_volumes'])\n                if self._is_valid_placement((x, y, z), dims, truck_type, truck['occupied_volumes']):\n                    filled_space = self._calculate_filled_space(dims, truck['occupied_volumes'], (x,y,z))\n                    if filled_space > max_filled_space:\n                        max_filled_space = filled_space\n                        best_truck_index = truck_index\n                        best_x, best_y, best_z = x, y, z\n                        best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_truck_index = -1\n            best_x, best_y, best_z = 0, 0, 0\n            max_filled_space = -1\n\n            for orientation, dims in self._get_orientations(item_type):\n                if self._is_valid_placement((0, 0, 0), dims, truck_type, []):\n                    filled_space = dims[0] * dims[1] * dims[2]\n                    if filled_space > max_filled_space:\n                        max_filled_space = filled_space\n                        best_x, best_y, best_z = 0, 0, 0\n                        best_orientation = orientation\n                    break\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_dims, container_dims, occupied_volumes):\n        x, y, z = 0, 0, 0\n\n        while x + item_dims[0] <= container_dims[0] + self.epsilon:\n            y = 0\n            while y + item_dims[1] <= container_dims[1] + self.epsilon:\n                z = 0\n                while z + item_dims[2] <= container_dims[2] + self.epsilon:\n                    is_valid = True\n                    for placed_item in occupied_volumes:\n                        placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                        placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                        if self._check_overlap_3d((x, y, z), item_dims, placed_item_pos, placed_item_dims):\n                            is_valid = False\n                            break\n                    if is_valid:\n                        return x, y, z\n                    z += 1\n                y += 1\n            x += 1\n\n        return float('inf'), float('inf'), float('inf')\n\n    def _calculate_filled_space(self, item_dims, occupied_volumes,item_pos):\n        filled_space = item_dims[0] * item_dims[1] * item_dims[2]\n        return filled_space\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_position_in_truck(self, item_dims, container_dims, occupied_volumes):\n        x, y, z = 0, 0, 0\n        max_iters = 1000\n\n        iters = 0\n        while x + item_dims[0] <= container_dims[0] + self.epsilon:\n            y = 0\n            while y + item_dims[1] <= container_dims[1] + self.epsilon:\n                z = 0\n                while z + item_dims[2] <= container_dims[2] + self.epsilon:\n                    is_valid = True\n                    for placed_item in occupied_volumes:\n                        placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                        placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                        if self._check_overlap_3d((x, y, z), item_dims, placed_item_pos, placed_item_dims):\n                            is_valid = False\n                            break\n                    if is_valid:\n                        return x, y, z\n                    z += 0.5\n                    iters += 1\n                    if iters > max_iters:\n                        return float('inf'), float('inf'), float('inf')\n                y += 0.5\n            x += 0.5\n\n        return float('inf'), float('inf'), float('inf')\nimport numpy as np\n\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_position_in_truck(self, item_dims, container_dims, occupied_volumes):\n        x, y, z = 0, 0, 0\n        max_iters = 500\n        \n        iters = 0\n        while x + item_dims[0] <= container_dims[0] + self.epsilon:\n            y = 0\n            while y + item_dims[1] <= container_dims[1] + self.epsilon:\n                z = 0\n                while z + item_dims[2] <= container_dims[2] + self.epsilon:\n                    is_valid = True\n                    for placed_item in occupied_volumes:\n                        placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                        placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                        if self._check_overlap_3d((x, y, z), item_dims, placed_item_pos, placed_item_dims):\n                            is_valid = False\n                            break\n                    if is_valid:\n                        return x, y, z\n                    z += max(1, item_dims[2]/2)\n                    iters += 1\n                    if iters > max_iters:\n                        return float('inf'), float('inf'), float('inf')\n                y += max(1, item_dims[1]/2)\n            x += max(1, item_dims[0]/2)\n\n        return float('inf'), float('inf'), float('inf')",
          "objective": 26.35,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     },
     {
          "algorithm": "Selects the item type with the smallest remaining quantity, finds the best orientation and position based on minimizing wasted space, and places it; if no placement is found, selects a new truck.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item type with the smallest remaining quantity, finds the best orientation and position based on minimizing wasted space, and places it; if no placement is found, selects a new truck.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_item_index = self._select_item(unplaced_items)\n\n        if best_item_index == -1:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n        best_truck_index, best_orientation, best_position = self._find_best_placement(\n            unplaced_items[best_item_index], trucks_in_use, truck_type\n        )\n\n        if best_truck_index == -1:\n            best_truck_index = len(trucks_in_use)\n            return best_truck_index, best_item_index, best_position[0], best_position[1], best_position[2], best_orientation\n        else:\n            return best_truck_index, best_item_index, best_position[0], best_position[1], best_position[2], best_orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        min_quantity = float('inf')\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                if item['quantity'] < min_quantity:\n                    min_quantity = item['quantity']\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_orientation = -1\n        best_position = (0.0, 0.0, 0.0)\n        min_waste = float('inf')\n\n        for truck_index in range(-1, len(trucks_in_use)):\n            if truck_index == -1:\n                occupied_volumes = []\n            else:\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n            for orientation, dims in self._get_orientations(item_type):\n                length, width, height = dims\n\n                positions = self._find_valid_positions(dims, truck_type, occupied_volumes)\n\n                for pos in positions:\n                    if self._is_valid_placement(pos, dims, truck_type, occupied_volumes):\n                        waste = self._calculate_waste(pos, dims, truck_type, occupied_volumes)\n                        if waste < min_waste:\n                            min_waste = waste\n                            best_truck_index = truck_index\n                            best_orientation = orientation\n                            best_position = pos\n\n        return best_truck_index, best_orientation, best_position\n\n    def _find_valid_positions(self, item_dims, container_dims, occupied_volumes):\n        valid_positions = []\n        container_length, container_width, container_height = container_dims\n        if not occupied_volumes:\n            return [(0.0, 0.0, 0.0)]\n\n        for item in occupied_volumes:\n             #next to item on x axis\n            x = item['x'] + item['length']\n            if x + item_dims[0] <= container_length:\n                valid_positions.append((x, item['y'], item['z']))\n\n            #next to item on y axis\n            y = item['y'] + item['width']\n            if y + item_dims[1] <= container_width:\n                valid_positions.append((item['x'], y, item['z']))\n\n            #next to item on z axis\n            z = item['z'] + item['height']\n            if z + item_dims[2] <= container_height:\n                valid_positions.append((item['x'], item['y'], z))\n        return valid_positions\n\n    def _calculate_waste(self, item_pos, item_dims, container_dims, occupied_volumes):\n        total_volume = container_dims[0] * container_dims[1] * container_dims[2]\n        occupied_volume = 0\n\n        item_volume = item_dims[0] * item_dims[1] * item_dims[2]\n        occupied_volume += item_volume\n\n        for item in occupied_volumes:\n            occupied_volume += item['length'] * item['width'] * item['height']\n\n        return total_volume - occupied_volume\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_item_index = self._select_item(unplaced_items)\n\n        if best_item_index == -1:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n        best_truck_index, best_orientation, best_position = self._find_best_placement(\n            unplaced_items[best_item_index], trucks_in_use, truck_type\n        )\n\n        if best_truck_index == -1:\n            if len(trucks_in_use) > 0 :\n                return len(trucks_in_use), best_item_index, best_position[0], best_position[1], best_position[2], best_orientation\n\n            else:\n                return  -1, best_item_index, best_position[0], best_position[1], best_position[2], best_orientation\n        else:\n            return best_truck_index, best_item_index, best_position[0], best_position[1], best_position[2], best_orientation\nimport numpy as np\n\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_item_index = self._select_item(unplaced_items)\n\n        if best_item_index == -1:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n        best_truck_index, best_orientation, best_position = self._find_best_placement(\n            unplaced_items[best_item_index], trucks_in_use, truck_type\n        )\n\n        if best_truck_index == -1:\n            \n            return  -1, best_item_index, best_position[0], best_position[1], best_position[2], best_orientation\n        else:\n            return best_truck_index, best_item_index, best_position[0], best_position[1], best_position[2], best_orientation",
          "objective": 26.5,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     }
]