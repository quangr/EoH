[
     {
          "algorithm": "Selects the item type with the largest volume and places it in the truck and orientation that minimizes height, prioritizing lower Z positions.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item type with the largest volume and places it in the truck and orientation that minimizes height, prioritizing lower Z positions.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items[item_index], trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                volume = item_type['length'] * item_type['width'] * item_type['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = 0\n        min_height = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            for orientation, dims in self._get_orientations(item_type):\n                positions = self._get_potential_positions(dims, truck_type, truck['occupied_volumes'])\n                for x, y, z in positions:\n                    if self._is_valid_placement((x, y, z), dims, truck_type, truck['occupied_volumes']):\n                        height = z + dims[2] \n                        if height < min_height:\n                            min_height = height\n                            best_truck_index = truck_index\n                            best_x, best_y, best_z = x, y, z\n                            best_orientation = orientation\n\n        if best_truck_index == -1:\n            \n            best_x, best_y, best_z = 0, 0, 0\n            min_height = float('inf')\n            for orientation, dims in self._get_orientations(item_type):\n                if self._is_valid_placement((0, 0, 0), dims, truck_type, []):\n                    height = dims[2]\n                    if height < min_height:\n                        min_height = height\n                        best_x, best_y, best_z = 0, 0, 0\n                        best_orientation = orientation\n                        best_truck_index = -1\n                    \n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _get_potential_positions(self, item_dims, container_dims, occupied_volumes):\n        positions = []\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        for placed_item in occupied_volumes:\n            x = placed_item['x'] + placed_item['length']\n            y = placed_item['y']\n            z = placed_item['z']\n            if x + item_dims[0] <= container_dims[0] and self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                positions.append((x, y, z))\n\n            x = placed_item['x']\n            y = placed_item['y'] + placed_item['width']\n            z = placed_item['z']\n            if y + item_dims[1] <= container_dims[1] and self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                positions.append((x, y, z))\n            \n            x = placed_item['x']\n            y = placed_item['y']\n            z = placed_item['z'] + placed_item['height']\n            if z + item_dims[2] <= container_dims[2] and self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                positions.append((x, y, z))\n        \n        return positions",
          "objective": 22.1,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects an item focusing on maximizing the occupied surface area on the bottom of the truck, giving priority to items that fit well within the available space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects an item focusing on maximizing the occupied surface area on the bottom of the truck, giving priority to items that fit well within the available space.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items, trucks_in_use, truck_type)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items[item_index], trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_item_index = -1\n        best_score = -1\n\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                available_space = self._calculate_available_space(trucks_in_use, truck_type)\n                volume = item_type['length'] * item_type['width'] * item_type['height']\n                fit_score = self._calculate_fit_score(item_type,truck_type)\n                quantity = item_type['quantity']\n                score = fit_score + quantity\n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n        return best_item_index\n\n    def _calculate_available_space(self, trucks_in_use, truck_type):\n        total_occupied_volume = 0\n        for truck in trucks_in_use:\n            for item in truck['occupied_volumes']:\n                total_occupied_volume += item['length'] * item['width'] * item['height']\n        return truck_type[0] * truck_type[1] * truck_type[2] - total_occupied_volume\n\n    def _calculate_fit_score(self, item_type,truck_type):\n        L, W, H = item_type['length'], item_type['width'], item_type['height']\n        \n        orientations = self._get_orientations(item_type)\n        best_area = -1\n        for orientation, dims in orientations:\n            if dims[0] <= truck_type[0] and dims[1] <= truck_type[1] and dims[2] <= truck_type[2]:\n                area = dims[0] * dims[1]\n                if area > best_area:\n                    best_area = area\n\n        return best_area\n    \n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = 0\n        best_area = -1\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            for orientation, dims in self._get_orientations(item_type):\n                positions = self._get_potential_positions(dims, truck_type, truck['occupied_volumes'])\n                for x, y, z in positions:\n                    if self._is_valid_placement((x, y, z), dims, truck_type, truck['occupied_volumes']):\n                        area = dims[0] * dims[1]\n\n                        if area > best_area :\n                            best_area = area\n                            best_truck_index = truck_index\n                            best_x, best_y, best_z = x, y, z\n                            best_orientation = orientation\n        \n        if best_truck_index == -1:\n            best_area = -1\n            for orientation, dims in self._get_orientations(item_type):\n                if self._is_valid_placement((0, 0, 0), dims, truck_type, []):\n                     area = dims[0] * dims[1]\n                     if area > best_area:\n                        best_area = area\n                        best_x, best_y, best_z = 0, 0, 0\n                        best_orientation = orientation\n                        best_truck_index = -1\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _get_potential_positions(self, item_dims, container_dims, occupied_volumes):\n        positions = []\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        potential_positions = []\n        for placed_item in occupied_volumes:\n            x = placed_item['x'] + placed_item['length']\n            y = placed_item['y']\n            z = placed_item['z']\n            potential_positions.append((x, y, z))\n\n            x = placed_item['x']\n            y = placed_item['y'] + placed_item['width']\n            z = placed_item['z']\n            potential_positions.append((x, y, z))\n\n            x = placed_item['x']\n            y = placed_item['y']\n            z = placed_item['z'] + placed_item['height']\n            potential_positions.append((x, y, z))\n        \n        for x,y,z in potential_positions:\n            if x + item_dims[0] <= container_dims[0] and y + item_dims[1] <= container_dims[1] and z + item_dims[2] <= container_dims[2]:\n                 positions.append((x,y,z))\n\n        valid_positions = []\n        for x, y, z in positions:\n            if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes) :\n                valid_positions.append((x,y,z))\n\n        return valid_positions",
          "objective": 22.4,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects an item based on a score of volume and quantity, then places it into the best position considering potential positions and height minimization.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects an item based on a score of volume and quantity, then places it into the best position considering potential positions and height minimization.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items[item_index], trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        best_score = -1\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                volume = item_type['length'] * item_type['width'] * item_type['height']\n                quantity = item_type['quantity']\n                score = volume * quantity \n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = 0\n        min_height = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            for orientation, dims in self._get_orientations(item_type):\n                positions = self._get_potential_positions(dims, truck_type, truck['occupied_volumes'])\n                for x, y, z in positions:\n                    if self._is_valid_placement((x, y, z), dims, truck_type, truck['occupied_volumes']):\n                        height = z + dims[2]\n                        if height < min_height:\n                            min_height = height\n                            best_truck_index = truck_index\n                            best_x, best_y, best_z = x, y, z\n                            best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_x, best_y, best_z = 0, 0, 0\n            min_height = float('inf')\n            for orientation, dims in self._get_orientations(item_type):\n                if self._is_valid_placement((0, 0, 0), dims, truck_type, []):\n                    height = dims[2]\n                    if height < min_height:\n                        min_height = height\n                        best_x, best_y, best_z = 0, 0, 0\n                        best_orientation = orientation\n                        best_truck_index = -1\n        \n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _get_potential_positions(self, item_dims, container_dims, occupied_volumes):\n        positions = []\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        potential_positions = []\n        for placed_item in occupied_volumes:\n            x = placed_item['x'] + placed_item['length']\n            y = placed_item['y']\n            z = placed_item['z']\n            potential_positions.append((x, y, z))\n\n            x = placed_item['x']\n            y = placed_item['y'] + placed_item['width']\n            z = placed_item['z']\n            potential_positions.append((x, y, z))\n\n            x = placed_item['x']\n            y = placed_item['y']\n            z = placed_item['z'] + placed_item['height']\n            potential_positions.append((x, y, z))\n        \n        for x,y,z in potential_positions:\n            if x + item_dims[0] <= container_dims[0] and y + item_dims[1] <= container_dims[1] and z + item_dims[2] <= container_dims[2]:\n                 positions.append((x,y,z))\n\n        valid_positions = []\n        for x, y, z in positions:\n            if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes) :\n                valid_positions.append((x,y,z))\n\n        return valid_positions",
          "objective": 22.5,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects the item type with the largest remaining quantity and places it in the bin and orientation that best utilizes available space, prioritizing lower Z values.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item type with the largest remaining quantity and places it in the bin and orientation that best utilizes available space, prioritizing lower Z values.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items[item_index], trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_quantity = -1\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                if item_type['quantity'] > max_quantity:\n                    max_quantity = item_type['quantity']\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = 0\n        best_volume_utilization = -1\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            for orientation, dims in self._get_orientations(item_type):\n                positions = self._get_potential_positions(dims, truck_type, truck['occupied_volumes'])\n                for x, y, z in positions:\n                    if self._is_valid_placement((x, y, z), dims, truck_type, truck['occupied_volumes']):\n                        volume_utilization = self._evaluate_placement((x, y, z), dims, truck_type, truck['occupied_volumes'])\n                        if volume_utilization > best_volume_utilization:\n                            best_volume_utilization = volume_utilization\n                            best_truck_index = truck_index\n                            best_x, best_y, best_z = x, y, z\n                            best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_volume_utilization = -1\n            for orientation, dims in self._get_orientations(item_type):\n                if self._is_valid_placement((0, 0, 0), dims, truck_type, []):\n                    volume_utilization = self._evaluate_placement((0, 0, 0), dims, truck_type, [])\n                    if volume_utilization > best_volume_utilization:\n                        best_volume_utilization = volume_utilization\n                        best_x, best_y, best_z = 0, 0, 0\n                        best_orientation = orientation\n                        best_truck_index = -1\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _get_potential_positions(self, item_dims, container_dims, occupied_volumes):\n        positions = []\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        occupied_volumes_sorted = sorted(occupied_volumes,key=lambda k: [k['z'], k['y'], k['x']])\n\n        for placed_item in occupied_volumes_sorted:\n            x = placed_item['x'] + placed_item['length']\n            y = placed_item['y']\n            z = placed_item['z']\n            if x + item_dims[0] <= container_dims[0] and self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                positions.append((x, y, z))\n\n            x = placed_item['x']\n            y = placed_item['y'] + placed_item['width']\n            z = placed_item['z']\n            if y + item_dims[1] <= container_dims[1] and self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                positions.append((x, y, z))\n            \n            x = placed_item['x']\n            y = placed_item['y']\n            z = placed_item['z'] + placed_item['height']\n            if z + item_dims[2] <= container_dims[2] and self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                positions.append((x, y, z))\n        \n        return positions\n    \n    def _evaluate_placement(self, item_pos, item_dims, container_dims, occupied_volumes):\n        px, py, pz = item_pos\n        pl, pw, ph = item_dims\n        cl, cw, ch = container_dims\n        \n        volume = pl * pw * ph\n\n        z_score = (ch - (pz + ph)) / ch\n        y_score = (cw - (py + pw)) / cw\n        x_score = (cl - (px + pl)) / cl\n        \n        score = 1 - ((z_score+y_score+x_score)/3)\n        return score",
          "objective": 23.0,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Prioritizes items with largest quantity and selects the placement with minimum area waste on the base of the container.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Prioritizes items with largest quantity and selects the placement with minimum area waste on the base of the container.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_item_index = self._select_item(unplaced_items)\n\n        if best_item_index == -1:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n            \n        best_truck_index, best_orientation, best_position = self._find_best_placement(\n            unplaced_items[best_item_index], trucks_in_use, truck_type\n        )\n        \n        if best_truck_index == -1:\n            return -1, best_item_index, best_position[0], best_position[1], best_position[2], best_orientation\n        else:\n            return best_truck_index, best_item_index, best_position[0], best_position[1], best_position[2], best_orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_quantity = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                if item['quantity'] > max_quantity:\n                    max_quantity = item['quantity']\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_orientation = -1\n        best_position = (0.0, 0.0, 0.0)\n        min_area_waste = float('inf')\n\n        for truck_index in range(-1, len(trucks_in_use)):\n            if truck_index == -1:\n                occupied_volumes = []\n            else:\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n            for orientation, dims in self._get_orientations(item_type):\n                length, width, height = dims\n                \n                positions = self._find_valid_positions(dims, truck_type, occupied_volumes)\n                \n                for pos in positions:\n                    if self._is_valid_placement(pos, dims, truck_type, occupied_volumes):\n                        area_waste = self._calculate_area_waste(pos, dims, truck_type, occupied_volumes)\n                        if area_waste < min_area_waste:\n                            min_area_waste = area_waste\n                            best_truck_index = truck_index\n                            best_orientation = orientation\n                            best_position = pos\n\n        return best_truck_index, best_orientation, best_position\n    \n    def _find_valid_positions(self, item_dims, container_dims, occupied_volumes):\n        valid_positions = []\n        if not occupied_volumes:\n            return [(0.0, 0.0, 0.0)]\n            \n        for item in occupied_volumes:\n            x = item['x'] + item['length']\n            y = item['y'] + item['width']\n            z = item['z'] + item['height']\n\n            valid_positions.append((x, item['y'], item['z']))\n            valid_positions.append((item['x'], y, item['z']))\n            valid_positions.append((item['x'], item['y'], z))\n            \n        return valid_positions\n        \n    def _calculate_area_waste(self, item_pos, item_dims, container_dims, occupied_volumes):\n        total_area = container_dims[0] * container_dims[1]\n        occupied_area = 0\n        \n        item_area = item_dims[0] * item_dims[1]\n        occupied_area += item_area\n\n        for item in occupied_volumes:\n            occupied_area += item['length'] * item['width']\n            \n        return total_area - occupied_area",
          "objective": 23.05,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]