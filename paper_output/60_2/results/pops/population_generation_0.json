[
     {
          "algorithm": "Iteratively selects the item with the largest volume, finds the best orientation and position with minimum wasted space, and places it in the best-fit container.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Iteratively selects the item with the largest volume, finds the best orientation and position with minimum wasted space, and places it in the best-fit container.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index = -1\n        item_index = -1\n        x = 0.0\n        y = 0.0\n        z = 0.0\n        orientation = 0\n\n        best_item_index = self._select_item(unplaced_items)\n\n        if best_item_index == -1:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n            \n        best_truck_index, best_orientation, best_position = self._find_best_placement(\n            unplaced_items[best_item_index], trucks_in_use, truck_type\n        )\n        \n        item_index = best_item_index\n        if best_truck_index == -1:\n            truck_index = -1\n            orientation = best_orientation\n            x, y, z = best_position\n        else:\n            truck_index = best_truck_index\n            orientation = best_orientation\n            x, y, z = best_position\n            \n        return truck_index, item_index, x, y, z, orientation    \n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_orientation = -1\n        best_position = (0.0, 0.0, 0.0)\n        min_waste = float('inf')\n\n        for truck_index in range(-1, len(trucks_in_use)):\n            if truck_index == -1:\n                occupied_volumes = []\n            else:\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n            for orientation, dims in self._get_orientations(item_type):\n                length, width, height = dims\n                \n                positions = self._find_valid_positions(dims, truck_type, occupied_volumes)\n                \n                for pos in positions:\n                    if self._is_valid_placement(pos, dims, truck_type, occupied_volumes):\n                        waste = self._calculate_waste(pos, dims, truck_type, occupied_volumes)\n                        if waste < min_waste:\n                            min_waste = waste\n                            best_truck_index = truck_index\n                            best_orientation = orientation\n                            best_position = pos\n\n        return best_truck_index, best_orientation, best_position\n    \n    def _find_valid_positions(self, item_dims, container_dims, occupied_volumes):\n        valid_positions = []\n        if not occupied_volumes:\n            return [(0.0, 0.0, 0.0)]\n            \n        for item in occupied_volumes:\n            x = item['x'] + item['length']\n            y = item['y'] + item['width']\n            z = item['z'] + item['height']\n\n            valid_positions.append((x, item['y'], item['z']))\n            valid_positions.append((item['x'], y, item['z']))\n            valid_positions.append((item['x'], item['y'], z))\n            \n        return valid_positions\n        \n    def _calculate_waste(self, item_pos, item_dims, container_dims, occupied_volumes):\n        total_volume = container_dims[0] * container_dims[1] * container_dims[2]\n        occupied_volume = 0\n        \n        item_volume = item_dims[0] * item_dims[1] * item_dims[2]\n        occupied_volume += item_volume\n\n        for item in occupied_volumes:\n            occupied_volume += item['length'] * item['width'] * item['height']\n            \n        return total_volume - occupied_volume",
          "objective": 24.7,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm prioritizes placing the largest remaining item type into the most suitable available truck, minimizing empty space by considering various orientations and placement positions.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes placing the largest remaining item type into the most suitable available truck, minimizing empty space by considering various orientations and placement positions.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_placement = None\n        best_score = -1.0\n\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                for truck_index, truck in enumerate(trucks_in_use):\n                    placement = self._evaluate_placements_in_truck(item_type, item_index, truck, truck_index, truck_type)\n                    if placement:\n                        score = self._calculate_placement_score(item_type, placement, truck_type)\n                        if score > best_score:\n                            best_score = score\n                            best_placement = placement\n                \n                new_truck_placement = self._evaluate_placements_new_truck(item_type, item_index, truck_type)\n                if new_truck_placement:\n                  score = self._calculate_placement_score(item_type, new_truck_placement, truck_type)\n                  if score > best_score:\n                    best_score = score\n                    best_placement = new_truck_placement\n\n        if best_placement:\n            return (\n                best_placement['truck_index'],\n                best_placement['item_index'],\n                best_placement['x'],\n                best_placement['y'],\n                best_placement['z'],\n                best_placement['orientation'],\n            )\n        else:\n            return -1, 0, 0.0, 0.0, 0.0, 0\n\n    def _evaluate_placements_in_truck(self, item_type, item_index, truck, truck_index, truck_type):\n        best_placement = None\n        for orientation_index, (orientation, (length, width, height)) in enumerate(self._get_orientations(item_type)):\n            for x in np.arange(0, truck_type[0] - length + self.epsilon, 1.0):\n                for y in np.arange(0, truck_type[1] - width + self.epsilon, 1.0):\n                    for z in np.arange(0, truck_type[2] - height + self.epsilon, 1.0):\n                        x, y, z = round(x, 6), round(y, 6), round(z, 6)\n                        if self._is_valid_placement((x, y, z), (length, width, height), truck_type, truck['occupied_volumes']):\n                            return {\n                                'truck_index': truck_index,\n                                'item_index': item_index,\n                                'x': x,\n                                'y': y,\n                                'z': z,\n                                'orientation': orientation_index,\n                                'length': length,\n                                'width': width,\n                                'height': height,\n                            }\n        return None\n\n    def _evaluate_placements_new_truck(self, item_type, item_index, truck_type):\n        best_placement = None\n        for orientation_index, (orientation, (length, width, height)) in enumerate(self._get_orientations(item_type)):\n            x,y,z = 0.0, 0.0, 0.0\n            if self._is_valid_placement((x, y, z), (length, width, height), truck_type, []):\n                  return {\n                      'truck_index': -1,\n                      'item_index': item_index,\n                      'x': x,\n                      'y': y,\n                      'z': z,\n                      'orientation': orientation_index,\n                      'length': length,\n                      'width': width,\n                      'height': height\n                  }\n        return None\n\n    def _calculate_placement_score(self, item_type, placement, truck_type):\n        volume_utilization = (placement['length'] * placement['width'] * placement['height']) / (truck_type[0] * truck_type[1] * truck_type[2])\n        return volume_utilization\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _evaluate_placements_in_truck(self, item_type, item_index, truck, truck_index, truck_type):\n        best_placement = None\n        for orientation_index, (orientation, (length, width, height)) in enumerate(self._get_orientations(item_type)):\n            # Reduce the range step to speed up search. The original stepsize can be too small\n            # which makes the search too slow and cause a timeout.\n            step_size = max(length, width, height) / 2.0\n            for x in np.arange(0, truck_type[0] - length + self.epsilon, step_size):\n                for y in np.arange(0, truck_type[1] - width + self.epsilon, step_size):\n                    for z in np.arange(0, truck_type[2] - height + self.epsilon, step_size):\n                        x, y, z = round(x, 6), round(y, 6), round(z, 6)\n                        if self._is_valid_placement((x, y, z), (length, width, height), truck_type, truck['occupied_volumes']):\n                            return {\n                                'truck_index': truck_index,\n                                'item_index': item_index,\n                                'x': x,\n                                'y': y,\n                                'z': z,\n                                'orientation': orientation_index,\n                                'length': length,\n                                'width': width,\n                                'height': height,\n                            }\n        return None\nimport numpy as np\n\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_placement = None\n        best_score = -1.0\n        \n        # Sort items in descending order of volume to place larger items first\n        sorted_items = sorted(\n            [(i, item) for i, item in enumerate(unplaced_items) if item['quantity'] > 0],\n            key=lambda x: x[1]['length'] * x[1]['width'] * x[1]['height'],\n            reverse=True\n        )\n        \n        for item_index, item_type in sorted_items:\n            for truck_index, truck in enumerate(trucks_in_use):\n                placement = self._evaluate_placements_in_truck(item_type, item_index, truck, truck_index, truck_type)\n                if placement:\n                    score = self._calculate_placement_score(item_type, placement, truck_type)\n                    if score > best_score:\n                        best_score = score\n                        best_placement = placement\n            \n            new_truck_placement = self._evaluate_placements_new_truck(item_type, item_index, truck_type)\n            if new_truck_placement:\n                score = self._calculate_placement_score(item_type, new_truck_placement, truck_type)\n                if score > best_score:\n                    best_score = score\n                    best_placement = new_truck_placement\n\n        if best_placement:\n            return (\n                best_placement['truck_index'],\n                best_placement['item_index'],\n                best_placement['x'],\n                best_placement['y'],\n                best_placement['z'],\n                best_placement['orientation'],\n            )\n        else:\n            return -1, 0, 0.0, 0.0, 0.0, 0\nimport numpy as np\n\nclass AlgorithmFIX3(AlgorithmFIX2):\n    def _evaluate_placements_in_truck(self, item_type, item_index, truck, truck_index, truck_type):\n        best_placement = None\n        \n        # Prioritize orientations by volume to find the densest packing faster\n        orientations_with_volume = []\n        for orientation_index, (orientation, (length, width, height)) in enumerate(self._get_orientations(item_type)):\n            orientations_with_volume.append((orientation_index, length * width * height, orientation, (length, width, height)))\n        \n        orientations_with_volume.sort(key=lambda x: x[1], reverse=True)\n\n        # Reduce the range step to speed up search.\n        step_size = max(item_type['length'], item_type['width'], item_type['height']) / 2.0\n\n        #Limit iterations to prevent timeout\n        max_iterations = 50  # Reduced max iterations\n        iteration_count = 0\n\n        for orientation_index, _, orientation, (length, width, height) in orientations_with_volume:\n            for x in np.arange(0, truck_type[0] - length + self.epsilon, step_size):\n                for y in np.arange(0, truck_type[1] - width + self.epsilon, step_size):\n                    for z in np.arange(0, truck_type[2] - height + self.epsilon, step_size):\n                        x, y, z = round(x, 6), round(y, 6), round(z, 6)\n                        if self._is_valid_placement((x, y, z), (length, width, height), truck_type, truck['occupied_volumes']):\n                            return {\n                                'truck_index': truck_index,\n                                'item_index': item_index,\n                                'x': x,\n                                'y': y,\n                                'z': z,\n                                'orientation': orientation_index,\n                                'length': length,\n                                'width': width,\n                                'height': height,\n                            }\n                        iteration_count += 1\n                        if iteration_count > max_iterations:\n                          return None #Return none when exceeds limit.\n        return None",
          "objective": 32.15,
          "other_inf": null,
          "class_name": "AlgorithmFIX3"
     },
     {
          "algorithm": "Selects item with largest volume, iterates through trucks, tries all orientations and positions by finding the bottom-leftmost position for each orientation, and places the item if valid.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects item with largest volume, iterates through trucks, tries all orientations and positions by finding the bottom-leftmost position for each orientation, and places the item if valid.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items[item_index], trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n        for i, item_type in enumerate(unplaced_items):\n            volume = item_type['length'] * item_type['width'] * item_type['height']\n            if volume > max_volume:\n                max_volume = volume\n                best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = 0\n        min_volume_increase = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            for orientation, dims in self._get_orientations(item_type):\n                x, y, z = self._find_bottom_leftmost_position(dims, truck_type, truck['occupied_volumes'])\n                if self._is_valid_placement((x, y, z), dims, truck_type, truck['occupied_volumes']):\n                    volume_increase = dims[0] * dims[1] * dims[2]\n                    if volume_increase < min_volume_increase:\n                        min_volume_increase = volume_increase\n                        best_truck_index = truck_index\n                        best_x, best_y, best_z = x, y, z\n                        best_orientation = orientation\n        \n        if best_truck_index == -1:\n            best_truck_index = -1\n            best_x, best_y, best_z = 0, 0, 0\n            min_volume_increase = float('inf')\n            for orientation, dims in self._get_orientations(item_type):\n                if self._is_valid_placement((0, 0, 0), dims, truck_type, []):\n                    volume_increase = dims[0] * dims[1] * dims[2]\n                    if volume_increase < min_volume_increase:\n                        min_volume_increase = volume_increase\n                        best_x, best_y, best_z = 0, 0, 0\n                        best_orientation = orientation\n                    break\n            \n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_bottom_leftmost_position(self, item_dims, container_dims, occupied_volumes):\n        x, y, z = 0, 0, 0\n        \n        while True:\n            valid_x = True\n            for placed_item in occupied_volumes:\n                placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                if self._check_overlap_3d((x, y, z), item_dims, placed_item_pos, placed_item_dims):\n                    x = placed_item_pos[0] + placed_item_dims[0]\n                    valid_x = False\n                    break\n            \n            if valid_x:\n                break\n        \n        while True:\n            valid_y = True\n            for placed_item in occupied_volumes:\n                placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                if self._check_overlap_3d((x, y, z), item_dims, placed_item_pos, placed_item_dims):\n                    y = placed_item_pos[1] + placed_item_dims[1]\n                    valid_y = False\n                    break\n            \n            if valid_y:\n                break\n\n        while True:\n            valid_z = True\n            for placed_item in occupied_volumes:\n                placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                if self._check_overlap_3d((x, y, z), item_dims, placed_item_pos, placed_item_dims):\n                    z = placed_item_pos[2] + placed_item_dims[2]\n                    valid_z = False\n                    break\n            \n            if valid_z:\n                break\n\n        return x, y, z\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                volume = item_type['length'] * item_type['width'] * item_type['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n        return best_item_index",
          "objective": 46.55,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     },
     {
          "algorithm": "This algorithm iterates through items, then orientations, and attempts to fit the item in the best available truck, or a new truck based on a first-fit-decreasing approach, prioritizing items with a larger volume.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm iterates through items, then orientations, and attempts to fit the item in the best available truck, or a new truck based on a first-fit-decreasing approach, prioritizing items with a larger volume.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        item_volumes = [item['length'] * item['width'] * item['height'] for item in unplaced_items]\n        item_indices = list(range(len(unplaced_items)))\n        item_indices.sort(key=lambda i: item_volumes[i], reverse=True)\n        return item_indices\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = 0.0\n        best_y = 0.0\n        best_z = 0.0\n        best_orientation = 0\n        \n        ordered_item_indices = self._select_item(unplaced_items)\n\n        for item_index in ordered_item_indices:\n            item_type = unplaced_items[item_index]\n            if item_type['quantity'] <= 0:\n                continue\n\n            best_truck_index_for_item = -1\n            best_x_for_item = 0.0\n            best_y_for_item = 0.0\n            best_z_for_item = 0.0\n            best_orientation_for_item = 0\n            \n            for orientation_index, (orientation, (length, width, height)) in enumerate(self._get_orientations(item_type)):\n\n                # Try existing trucks\n                for truck_index in range(len(trucks_in_use)):\n                    truck = trucks_in_use[truck_index]\n                    occupied_volumes = truck['occupied_volumes']\n                    \n                    x, y, z = self._find_position_in_truck(length, width, height, truck_type, occupied_volumes)\n                    if x is not None:\n                        best_truck_index_for_item = truck_index\n                        best_x_for_item = x\n                        best_y_for_item = y\n                        best_z_for_item = z\n                        best_orientation_for_item = orientation_index\n                        return best_truck_index_for_item, item_index, best_x_for_item, best_y_for_item, best_z_for_item, best_orientation_for_item\n\n                # Try placing into a new truck if no existing truck can accommodate the item\n                x, y, z = 0.0, 0.0, 0.0\n                is_valid = self._is_valid_placement((x, y, z), (length, width, height), truck_type, [])\n                if is_valid:\n                    best_truck_index_for_item = -1\n                    best_x_for_item = x\n                    best_y_for_item = y\n                    best_z_for_item = z\n                    best_orientation_for_item = orientation_index\n                    return best_truck_index_for_item, item_index, best_x_for_item, best_y_for_item, best_z_for_item, best_orientation_for_item\n        \n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n    \n    def _find_position_in_truck(self, length, width, height, container_dims, occupied_volumes):\n        # Simple strategy: Find the first available corner (0,0,0)\n        x, y, z = 0.0, 0.0, 0.0\n        if self._is_valid_placement((x, y, z), (length, width, height), container_dims, occupied_volumes):\n            return x, y, z\n        \n        # More exhaustive strategy (to be added later if needed)\n        return None, None, None",
          "objective": 101.5,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]