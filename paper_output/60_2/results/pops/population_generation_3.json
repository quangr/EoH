[
     {
          "algorithm": "Selects the item type with the largest volume and places it in the truck and orientation that minimizes height, prioritizing lower Z positions.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item type with the largest volume and places it in the truck and orientation that minimizes height, prioritizing lower Z positions.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items[item_index], trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                volume = item_type['length'] * item_type['width'] * item_type['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = 0\n        min_height = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            for orientation, dims in self._get_orientations(item_type):\n                positions = self._get_potential_positions(dims, truck_type, truck['occupied_volumes'])\n                for x, y, z in positions:\n                    if self._is_valid_placement((x, y, z), dims, truck_type, truck['occupied_volumes']):\n                        height = z + dims[2] \n                        if height < min_height:\n                            min_height = height\n                            best_truck_index = truck_index\n                            best_x, best_y, best_z = x, y, z\n                            best_orientation = orientation\n\n        if best_truck_index == -1:\n            \n            best_x, best_y, best_z = 0, 0, 0\n            min_height = float('inf')\n            for orientation, dims in self._get_orientations(item_type):\n                if self._is_valid_placement((0, 0, 0), dims, truck_type, []):\n                    height = dims[2]\n                    if height < min_height:\n                        min_height = height\n                        best_x, best_y, best_z = 0, 0, 0\n                        best_orientation = orientation\n                        best_truck_index = -1\n                    \n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _get_potential_positions(self, item_dims, container_dims, occupied_volumes):\n        positions = []\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        for placed_item in occupied_volumes:\n            x = placed_item['x'] + placed_item['length']\n            y = placed_item['y']\n            z = placed_item['z']\n            if x + item_dims[0] <= container_dims[0] and self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                positions.append((x, y, z))\n\n            x = placed_item['x']\n            y = placed_item['y'] + placed_item['width']\n            z = placed_item['z']\n            if y + item_dims[1] <= container_dims[1] and self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                positions.append((x, y, z))\n            \n            x = placed_item['x']\n            y = placed_item['y']\n            z = placed_item['z'] + placed_item['height']\n            if z + item_dims[2] <= container_dims[2] and self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                positions.append((x, y, z))\n        \n        return positions",
          "objective": 22.1,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects an item based on a score of volume and quantity, then places it into the best position considering potential positions and height minimization.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects an item based on a score of volume and quantity, then places it into the best position considering potential positions and height minimization.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items[item_index], trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        best_score = -1\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                volume = item_type['length'] * item_type['width'] * item_type['height']\n                quantity = item_type['quantity']\n                score = volume * quantity \n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = 0\n        min_height = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            for orientation, dims in self._get_orientations(item_type):\n                positions = self._get_potential_positions(dims, truck_type, truck['occupied_volumes'])\n                for x, y, z in positions:\n                    if self._is_valid_placement((x, y, z), dims, truck_type, truck['occupied_volumes']):\n                        height = z + dims[2]\n                        if height < min_height:\n                            min_height = height\n                            best_truck_index = truck_index\n                            best_x, best_y, best_z = x, y, z\n                            best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_x, best_y, best_z = 0, 0, 0\n            min_height = float('inf')\n            for orientation, dims in self._get_orientations(item_type):\n                if self._is_valid_placement((0, 0, 0), dims, truck_type, []):\n                    height = dims[2]\n                    if height < min_height:\n                        min_height = height\n                        best_x, best_y, best_z = 0, 0, 0\n                        best_orientation = orientation\n                        best_truck_index = -1\n        \n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _get_potential_positions(self, item_dims, container_dims, occupied_volumes):\n        positions = []\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        potential_positions = []\n        for placed_item in occupied_volumes:\n            x = placed_item['x'] + placed_item['length']\n            y = placed_item['y']\n            z = placed_item['z']\n            potential_positions.append((x, y, z))\n\n            x = placed_item['x']\n            y = placed_item['y'] + placed_item['width']\n            z = placed_item['z']\n            potential_positions.append((x, y, z))\n\n            x = placed_item['x']\n            y = placed_item['y']\n            z = placed_item['z'] + placed_item['height']\n            potential_positions.append((x, y, z))\n        \n        for x,y,z in potential_positions:\n            if x + item_dims[0] <= container_dims[0] and y + item_dims[1] <= container_dims[1] and z + item_dims[2] <= container_dims[2]:\n                 positions.append((x,y,z))\n\n        valid_positions = []\n        for x, y, z in positions:\n            if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes) :\n                valid_positions.append((x,y,z))\n\n        return valid_positions",
          "objective": 22.5,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Prioritizes items with largest quantity and selects the placement with minimum area waste on the base of the container.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Prioritizes items with largest quantity and selects the placement with minimum area waste on the base of the container.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_item_index = self._select_item(unplaced_items)\n\n        if best_item_index == -1:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n            \n        best_truck_index, best_orientation, best_position = self._find_best_placement(\n            unplaced_items[best_item_index], trucks_in_use, truck_type\n        )\n        \n        if best_truck_index == -1:\n            return -1, best_item_index, best_position[0], best_position[1], best_position[2], best_orientation\n        else:\n            return best_truck_index, best_item_index, best_position[0], best_position[1], best_position[2], best_orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_quantity = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                if item['quantity'] > max_quantity:\n                    max_quantity = item['quantity']\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_orientation = -1\n        best_position = (0.0, 0.0, 0.0)\n        min_area_waste = float('inf')\n\n        for truck_index in range(-1, len(trucks_in_use)):\n            if truck_index == -1:\n                occupied_volumes = []\n            else:\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n            for orientation, dims in self._get_orientations(item_type):\n                length, width, height = dims\n                \n                positions = self._find_valid_positions(dims, truck_type, occupied_volumes)\n                \n                for pos in positions:\n                    if self._is_valid_placement(pos, dims, truck_type, occupied_volumes):\n                        area_waste = self._calculate_area_waste(pos, dims, truck_type, occupied_volumes)\n                        if area_waste < min_area_waste:\n                            min_area_waste = area_waste\n                            best_truck_index = truck_index\n                            best_orientation = orientation\n                            best_position = pos\n\n        return best_truck_index, best_orientation, best_position\n    \n    def _find_valid_positions(self, item_dims, container_dims, occupied_volumes):\n        valid_positions = []\n        if not occupied_volumes:\n            return [(0.0, 0.0, 0.0)]\n            \n        for item in occupied_volumes:\n            x = item['x'] + item['length']\n            y = item['y'] + item['width']\n            z = item['z'] + item['height']\n\n            valid_positions.append((x, item['y'], item['z']))\n            valid_positions.append((item['x'], y, item['z']))\n            valid_positions.append((item['x'], item['y'], z))\n            \n        return valid_positions\n        \n    def _calculate_area_waste(self, item_pos, item_dims, container_dims, occupied_volumes):\n        total_area = container_dims[0] * container_dims[1]\n        occupied_area = 0\n        \n        item_area = item_dims[0] * item_dims[1]\n        occupied_area += item_area\n\n        for item in occupied_volumes:\n            occupied_area += item['length'] * item['width']\n            \n        return total_area - occupied_area",
          "objective": 23.05,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects the item type with the largest area (length * width) and places it in the truck and orientation that maximizes the volume utilization, prioritizing lower Z positions and then minimizing empty space left after placement.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item type with the largest area (length * width) and places it in the truck and orientation that maximizes the volume utilization, prioritizing lower Z positions and then minimizing empty space left after placement.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items[item_index], trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_area = -1\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                area = item_type['length'] * item_type['width']\n                if area > max_area:\n                    max_area = area\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = 0\n        max_volume_utilization = -1\n        min_z = float('inf')\n        min_empty_space = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            for orientation, dims in self._get_orientations(item_type):\n                positions = self._get_potential_positions(dims, truck_type, truck['occupied_volumes'])\n                for x, y, z in positions:\n                    if self._is_valid_placement((x, y, z), dims, truck_type, truck['occupied_volumes']):\n                        volume_utilization = dims[0] * dims[1] * dims[2]\n                        empty_space = (truck_type[0] - (x + dims[0])) * (truck_type[1] - (y + dims[1])) * (truck_type[2] - (z + dims[2]))\n\n                        if volume_utilization > max_volume_utilization or \\\n                           (volume_utilization == max_volume_utilization and z < min_z) or \\\n                           (volume_utilization == max_volume_utilization and z == min_z and empty_space < min_empty_space):\n\n                            max_volume_utilization = volume_utilization\n                            min_z = z\n                            min_empty_space = empty_space\n                            best_truck_index = truck_index\n                            best_x, best_y, best_z = x, y, z\n                            best_orientation = orientation\n                            \n\n        if best_truck_index == -1:\n            \n            max_volume_utilization = -1\n            min_empty_space = float('inf')\n            min_z = float('inf')\n            best_x, best_y, best_z = 0, 0, 0\n\n            for orientation, dims in self._get_orientations(item_type):\n                if self._is_valid_placement((0, 0, 0), dims, truck_type, []):\n                    volume_utilization = dims[0] * dims[1] * dims[2]\n                    empty_space = (truck_type[0] - dims[0]) * (truck_type[1] - dims[1]) * (truck_type[2] - dims[2])\n                    if volume_utilization > max_volume_utilization or \\\n                       (volume_utilization == max_volume_utilization and 0 < min_z) or \\\n                       (volume_utilization == max_volume_utilization and 0 == min_z and empty_space < min_empty_space):\n                        max_volume_utilization = volume_utilization\n                        min_z = 0\n                        min_empty_space = empty_space\n                        best_x, best_y, best_z = 0, 0, 0\n                        best_orientation = orientation\n                        best_truck_index = -1\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _get_potential_positions(self, item_dims, container_dims, occupied_volumes):\n        positions = []\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        for placed_item in occupied_volumes:\n            x = placed_item['x'] + placed_item['length']\n            y = placed_item['y']\n            z = placed_item['z']\n            if x + item_dims[0] <= container_dims[0] and self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                positions.append((x, y, z))\n\n            x = placed_item['x']\n            y = placed_item['y'] + placed_item['width']\n            z = placed_item['z']\n            if y + item_dims[1] <= container_dims[1] and self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                positions.append((x, y, z))\n            \n            x = placed_item['x']\n            y = placed_item['y']\n            z = placed_item['z'] + placed_item['height']\n            if z + item_dims[2] <= container_dims[2] and self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                positions.append((x, y, z))\n        \n        return positions",
          "objective": 24.0,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Prioritizes items with the smallest volume-to-quantity ratio, then places them into the lowest available space in existing trucks or a new truck.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Prioritizes items with the smallest volume-to-quantity ratio, then places them into the lowest available space in existing trucks or a new truck.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items[item_index], trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        best_score = float('inf')\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                volume = item_type['length'] * item_type['width'] * item_type['height']\n                quantity = item_type['quantity']\n                score = volume / quantity if quantity > 0 else float('inf')\n                if score < best_score:\n                    best_score = score\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = 0\n        min_height = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            for orientation, dims in self._get_orientations(item_type):\n                positions = self._get_potential_positions(dims, truck_type, truck['occupied_volumes'])\n                for x, y, z in positions:\n                    if self._is_valid_placement((x, y, z), dims, truck_type, truck['occupied_volumes']):\n                        height = z + dims[2]\n                        if height < min_height:\n                            min_height = height\n                            best_truck_index = truck_index\n                            best_x, best_y, best_z = x, y, z\n                            best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_x, best_y, best_z = 0, 0, 0\n            min_height = float('inf')\n            for orientation, dims in self._get_orientations(item_type):\n                if self._is_valid_placement((0, 0, 0), dims, truck_type, []):\n                    height = dims[2]\n                    if height < min_height:\n                        min_height = height\n                        best_x, best_y, best_z = 0, 0, 0\n                        best_orientation = orientation\n                        best_truck_index = -1\n        \n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _get_potential_positions(self, item_dims, container_dims, occupied_volumes):\n        positions = []\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        potential_positions = []\n        for placed_item in occupied_volumes:\n            x = placed_item['x'] + placed_item['length']\n            y = placed_item['y']\n            z = placed_item['z']\n            potential_positions.append((x, y, z))\n\n            x = placed_item['x']\n            y = placed_item['y'] + placed_item['width']\n            z = placed_item['z']\n            potential_positions.append((x, y, z))\n\n            x = placed_item['x']\n            y = placed_item['y']\n            z = placed_item['z'] + placed_item['height']\n            potential_positions.append((x, y, z))\n        \n        for x,y,z in potential_positions:\n            if x + item_dims[0] <= container_dims[0] and y + item_dims[1] <= container_dims[1] and z + item_dims[2] <= container_dims[2]:\n                 positions.append((x,y,z))\n\n        valid_positions = []\n        for x, y, z in positions:\n            if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes) :\n                valid_positions.append((x,y,z))\n\n        return valid_positions",
          "objective": 24.15,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]