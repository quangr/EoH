{
     "algorithm": "Selects the largest unplaced item, iterates through trucks, and attempts to place it using a bottom-left-back heuristic, creating a new truck if necessary.",
     "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n        # {Selects the largest unplaced item, iterates through trucks, and attempts to place it using a bottom-left-back heuristic, creating a new truck if necessary.}\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, -1, -1, -1, -1\n\n        truck_index, x, y, z, orientation = self._find_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = item_index\n\n        return best_item_index\n\n    def _find_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n\n        item = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if not self._check_separation_compatibility(item, truck):\n                continue\n\n            x, y, z, orientation = self._find_position_in_truck(item, truck, truck_type)\n            if x != -1:\n                return truck_index, x, y, z, orientation\n\n        x, y, z, orientation = self._find_position_in_new_truck(item, truck_type)\n        if x != -1:\n            return -1, x, y, z, orientation\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item, truck, truck_type):\n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item)):\n            x, y, z = self._bottom_left_back(item_dims, truck_type, truck['occupied_volumes'])\n            if x != -1:\n                item_pos = (float(x), float(y), float(z))\n                if self._is_valid_placement(item_pos, item_dims, truck_type, truck['occupied_volumes']):\n                    return float(x), float(y), float(z), orientation_index\n        return -1, -1, -1, -1\n\n    def _find_position_in_new_truck(self, item, truck_type):\n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item)):\n            x, y, z = 0, 0, 0\n            item_pos = (float(x), float(y), float(z))\n            if self._is_valid_placement(item_pos, item_dims, truck_type, []):\n                return float(x), float(y), float(z), orientation_index\n\n        return -1, -1, -1, -1\n\n    def _bottom_left_back(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = item_dims\n\n        potential_positions = []\n\n        if not occupied_volumes:\n            return 0, 0, 0\n\n        for placed_item in occupied_volumes:\n            x = placed_item['x'] + placed_item['length']\n            y = placed_item['y'] + placed_item['width']\n            z = placed_item['z'] + placed_item['height']\n\n            potential_positions.append((x, placed_item['y'], placed_item['z']))\n            potential_positions.append((placed_item['x'], y, placed_item['z']))\n            potential_positions.append((placed_item['x'], placed_item['y'], z))\n\n        potential_positions.append((0,0,0))\n        valid_positions = []\n        for x, y, z in potential_positions:\n              if self._is_within_container_bounds((x, y, z), item_dims, container_dims):\n                  is_valid = True\n                  for placed_item in occupied_volumes:\n                      placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                      placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                      if self._check_overlap_3d((x, y, z), item_dims, placed_item_pos, placed_item_dims):\n                          is_valid = False\n                          break\n                  if is_valid:\n                      valid_positions.append((x,y,z))\n        \n        best_x, best_y, best_z = -1, -1, -1\n        if valid_positions:\n            best_x, best_y, best_z = min(valid_positions, key=lambda p: (p[2], p[1], p[0]))\n\n        return best_x, best_y, best_z",
     "objective": 25.3,
     "other_inf": null,
     "class_name": "Algorithm"
}