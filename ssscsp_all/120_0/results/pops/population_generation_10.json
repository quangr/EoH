[
     {
          "algorithm": "Selects items based on a modified volume-to-area ratio that prioritizes items with larger volume and less quantity, aiming to fill trucks more efficiently.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects items based on a modified volume-to-area ratio that prioritizes items with larger volume and less quantity, aiming to fill trucks more efficiently.}\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, -1, -1, -1, -1\n\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        best_score = -1\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                area = item['length'] * item['width']\n                if area == 0:\n                    score = 0\n                else:\n                    score = (volume / area) / (item['quantity'] + 0.1)\n\n                if score > best_score:\n                    best_score = score\n                    best_item_index = item_index\n\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_fit_score = float('inf')\n\n        item = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if not self._check_separation_compatibility(item, truck):\n                continue\n\n            x, y, z, orientation = self._find_best_position_in_truck(item, truck, truck_type)\n            if x != -1:\n                fit_score = self._evaluate_placement(x, y, z, item, truck, truck_type,orientation)\n                if fit_score < best_fit_score:\n                    best_fit_score = fit_score\n                    best_truck_index = truck_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n\n        if best_truck_index == -1:\n            x, y, z, orientation = self._find_best_position_in_new_truck(item, truck_type)\n            if x != -1:\n                return -1, x, y, z, orientation\n            else:\n                return -1, -1, -1, -1, -1\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_area = -1\n\n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item)):\n            x, y, z = self._find_skyline_position(item_dims, truck_type, truck['occupied_volumes'])\n            if x != -1:\n                item_pos = (float(x), float(y), float(z))\n                if self._is_valid_placement(item_pos, item_dims, truck_type, truck['occupied_volumes']):\n                    if z==0:\n                        area = item_dims[0] * item_dims[1]\n                        if area > best_area:\n                            best_area = area\n                            best_x, best_y, best_z, best_orientation = float(x), float(y), float(z), orientation_index\n                    else:\n                        return float(x), float(y), float(z), orientation_index\n\n        if best_x != -1:\n            return best_x, best_y, best_z, best_orientation\n            \n        return -1, -1, -1, -1\n\n    def _find_best_position_in_new_truck(self, item, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_area = -1\n\n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item)):\n            x, y, z = 0, 0, 0\n            item_pos = (float(x), float(y), float(z))\n            if self._is_valid_placement(item_pos, item_dims, truck_type, []):\n              area=item_dims[0] * item_dims[1]\n              if area > best_area:\n                best_area = area\n                best_x, best_y, best_z, best_orientation = float(x), float(y), float(z), orientation_index\n\n        if best_x != -1:\n            return best_x, best_y, best_z, best_orientation\n\n        return -1, -1, -1, -1\n\n    def _evaluate_placement(self, x, y, z, item, truck, truck_type, orientation):\n        if z == 0:\n          return -100000000 + self._calculate_remaining_volume(truck, truck_type)\n        remaining_volume = self._calculate_remaining_volume(truck, truck_type)\n        return remaining_volume\n\n    def _calculate_remaining_volume(self, truck, truck_type):\n        total_volume = truck_type[0] * truck_type[1] * truck_type[2]\n        occupied_volume = 0\n        for placed_item in truck['occupied_volumes']:\n            occupied_volume += placed_item['length'] * placed_item['width'] * placed_item['height']\n        return total_volume - occupied_volume\n\n    def _find_skyline_position(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = item_dims\n        best_x, best_y, best_z = -1, -1, -1\n        min_z = float('inf')\n\n        if not occupied_volumes:\n            return 0, 0, 0\n\n        for x in range(0, int(container_dims[0] - l + 1)):\n            for y in range(0, int(container_dims[1] - w + 1)):\n                z = self._get_skyline_height(x, y, l, w, occupied_volumes)\n                if z != -1:\n                    if self._is_within_container_bounds((x, y, z), item_dims, container_dims):\n                        is_valid = True\n                        for placed_item in occupied_volumes:\n                            placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                            placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                            if self._check_overlap_3d((x, y, z), item_dims, placed_item_pos, placed_item_dims):\n                                is_valid = False\n                                break\n                        if is_valid:\n                            if z < min_z:\n                                min_z = z\n                                best_x, best_y, best_z = x, y, z\n\n        return best_x, best_y, best_z\n\n    def _get_skyline_height(self, x, y, l, w, occupied_volumes):\n        max_height = 0\n        for placed_item in occupied_volumes:\n            px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n            pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n\n            if x < px + pl and x + l > px and y < py + pw and y + w > py:\n                max_height = max(max_height, pz + ph)\n        return max_height",
          "objective": 23.35,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects items based on a volume-to-area ratio score, considering the remaining quantity, and prioritizes placing items to maximize the filled area on the bottom of the truck.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects items based on a volume-to-area ratio score, considering the remaining quantity, and prioritizes placing items to maximize the filled area on the bottom of the truck.}\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, -1, -1, -1, -1\n\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        best_score = -1\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                area = item['length'] * item['width']\n                if area == 0:\n                    score = 0\n                else:\n                    score = (volume / area) * item['quantity']\n\n                if score > best_score:\n                    best_score = score\n                    best_item_index = item_index\n\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_fit_score = float('inf')\n\n        item = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if not self._check_separation_compatibility(item, truck):\n                continue\n\n            x, y, z, orientation = self._find_best_position_in_truck(item, truck, truck_type)\n            if x != -1:\n                fit_score = self._evaluate_placement(x, y, z, item, truck, truck_type,orientation)\n                if fit_score < best_fit_score:\n                    best_fit_score = fit_score\n                    best_truck_index = truck_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n\n        if best_truck_index == -1:\n            x, y, z, orientation = self._find_best_position_in_new_truck(item, truck_type)\n            if x != -1:\n                return -1, x, y, z, orientation\n            else:\n                return -1, -1, -1, -1, -1\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_area = -1\n\n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item)):\n            x, y, z = self._find_skyline_position(item_dims, truck_type, truck['occupied_volumes'])\n            if x != -1:\n                item_pos = (float(x), float(y), float(z))\n                if self._is_valid_placement(item_pos, item_dims, truck_type, truck['occupied_volumes']):\n                    if z==0:\n                        area = item_dims[0] * item_dims[1]\n                        if area > best_area:\n                            best_area = area\n                            best_x, best_y, best_z, best_orientation = float(x), float(y), float(z), orientation_index\n                    else:\n                        return float(x), float(y), float(z), orientation_index\n\n        if best_x != -1:\n            return best_x, best_y, best_z, best_orientation\n            \n        return -1, -1, -1, -1\n\n    def _find_best_position_in_new_truck(self, item, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_area = -1\n\n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item)):\n            x, y, z = 0, 0, 0\n            item_pos = (float(x), float(y), float(z))\n            if self._is_valid_placement(item_pos, item_dims, truck_type, []):\n              area=item_dims[0] * item_dims[1]\n              if area > best_area:\n                best_area = area\n                best_x, best_y, best_z, best_orientation = float(x), float(y), float(z), orientation_index\n\n        if best_x != -1:\n            return best_x, best_y, best_z, best_orientation\n\n        return -1, -1, -1, -1\n\n    def _evaluate_placement(self, x, y, z, item, truck, truck_type, orientation):\n        if z == 0:\n          return -100000000 + self._calculate_remaining_volume(truck, truck_type)\n        remaining_volume = self._calculate_remaining_volume(truck, truck_type)\n        return remaining_volume\n\n    def _calculate_remaining_volume(self, truck, truck_type):\n        total_volume = truck_type[0] * truck_type[1] * truck_type[2]\n        occupied_volume = 0\n        for placed_item in truck['occupied_volumes']:\n            occupied_volume += placed_item['length'] * placed_item['width'] * placed_item['height']\n        return total_volume - occupied_volume\n\n    def _find_skyline_position(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = item_dims\n        best_x, best_y, best_z = -1, -1, -1\n        min_z = float('inf')\n\n        if not occupied_volumes:\n            return 0, 0, 0\n\n        for x in range(0, int(container_dims[0] - l + 1)):\n            for y in range(0, int(container_dims[1] - w + 1)):\n                z = self._get_skyline_height(x, y, l, w, occupied_volumes)\n                if z != -1:\n                    if self._is_within_container_bounds((x, y, z), item_dims, container_dims):\n                        is_valid = True\n                        for placed_item in occupied_volumes:\n                            placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                            placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                            if self._check_overlap_3d((x, y, z), item_dims, placed_item_pos, placed_item_dims):\n                                is_valid = False\n                                break\n                        if is_valid:\n                            if z < min_z:\n                                min_z = z\n                                best_x, best_y, best_z = x, y, z\n\n        return best_x, best_y, best_z\n\n    def _get_skyline_height(self, x, y, l, w, occupied_volumes):\n        max_height = 0\n        for placed_item in occupied_volumes:\n            px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n            pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n\n            if x < px + pl and x + l > px and y < py + pw and y + w > py:\n                max_height = max(max_height, pz + ph)\n        return max_height",
          "objective": 23.6,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects the item with the largest remaining quantity and places it using a bottom-left-fill heuristic, prioritizing floor placements.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item with the largest remaining quantity and places it using a bottom-left-fill heuristic, prioritizing floor placements.}\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, -1, -1, -1, -1\n\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_quantity = -1\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                if item['quantity'] > max_quantity:\n                    max_quantity = item['quantity']\n                    best_item_index = item_index\n\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_fit_score = float('inf')\n\n        item = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if not self._check_separation_compatibility(item, truck):\n                continue\n\n            x, y, z, orientation = self._find_best_position_in_truck(item, truck, truck_type)\n            if x != -1:\n                fit_score = self._evaluate_placement(x, y, z, item, truck, truck_type,orientation)\n                if fit_score < best_fit_score:\n                    best_fit_score = fit_score\n                    best_truck_index = truck_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n\n        if best_truck_index == -1:\n            x, y, z, orientation = self._find_best_position_in_new_truck(item, truck_type)\n            if x != -1:\n                return -1, x, y, z, orientation\n            else:\n                return -1, -1, -1, -1, -1\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_area = -1\n\n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item)):\n            x, y, z = self._find_bottom_left_position(item_dims, truck_type, truck['occupied_volumes'])\n            if x != -1:\n                item_pos = (float(x), float(y), float(z))\n                if self._is_valid_placement(item_pos, item_dims, truck_type, truck['occupied_volumes']):\n                    if z==0:\n                        area = item_dims[0] * item_dims[1]\n                        if area > best_area:\n                            best_area = area\n                            best_x, best_y, best_z, best_orientation = float(x), float(y), float(z), orientation_index\n                    else:\n                        return float(x), float(y), float(z), orientation_index\n\n        if best_x != -1:\n            return best_x, best_y, best_z, best_orientation\n            \n        return -1, -1, -1, -1\n\n    def _find_best_position_in_new_truck(self, item, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_area = -1\n\n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item)):\n            x, y, z = 0, 0, 0\n            item_pos = (float(x), float(y), float(z))\n            if self._is_valid_placement(item_pos, item_dims, truck_type, []):\n              area=item_dims[0] * item_dims[1]\n              if area > best_area:\n                best_area = area\n                best_x, best_y, best_z, best_orientation = float(x), float(y), float(z), orientation_index\n\n        if best_x != -1:\n            return best_x, best_y, best_z, best_orientation\n\n        return -1, -1, -1, -1\n\n    def _evaluate_placement(self, x, y, z, item, truck, truck_type, orientation):\n        if z == 0:\n          return -100000000 + self._calculate_remaining_volume(truck, truck_type)\n        remaining_volume = self._calculate_remaining_volume(truck, truck_type)\n        return remaining_volume\n\n    def _calculate_remaining_volume(self, truck, truck_type):\n        total_volume = truck_type[0] * truck_type[1] * truck_type[2]\n        occupied_volume = 0\n        for placed_item in truck['occupied_volumes']:\n            occupied_volume += placed_item['length'] * placed_item['width'] * placed_item['height']\n        return total_volume - occupied_volume\n\n    def _find_bottom_left_position(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = item_dims\n        best_x, best_y, best_z = -1, -1, -1\n        min_z = float('inf')\n        min_y = float('inf')\n        min_x = float('inf')\n\n        for x in range(0, int(container_dims[0] - l + 1)):\n            for y in range(0, int(container_dims[1] - w + 1)):\n                z = self._get_support_height(x, y, l, w, occupied_volumes)\n                if z != -1:\n                    if self._is_within_container_bounds((x, y, z), item_dims, container_dims):\n                        is_valid = True\n                        for placed_item in occupied_volumes:\n                            placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                            placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                            if self._check_overlap_3d((x, y, z), item_dims, placed_item_pos, placed_item_dims):\n                                is_valid = False\n                                break\n                        if is_valid:\n                            if z < min_z or (z == min_z and y < min_y) or (z == min_z and y== min_y and x < min_x):\n                                min_z = z\n                                min_y = y\n                                min_x = x\n                                best_x, best_y, best_z = x, y, z\n\n        return best_x, best_y, best_z\n\n    def _get_support_height(self, x, y, l, w, occupied_volumes):\n        max_height = 0\n        for placed_item in occupied_volumes:\n            px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n            pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n\n            if x < px + pl and x + l > px and y < py + pw and y + w > py:\n                max_height = max(max_height, pz + ph)\n        return max_height",
          "objective": 24.45,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects the unplaced item with a higher priority on placing based on volume, and adjusts the space utilization importance in the overall score, placing more importance on stability.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    def __init__(self, epsilon=1e-6, alpha=1.0, stability_weight=0.7):\n        super().__init__(epsilon, alpha)\n        self.stability_weight = stability_weight\n        # {Selects the unplaced item with a higher priority on placing based on volume, and adjusts the space utilization importance in the overall score, placing more importance on stability.}\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, -1, -1, -1, -1\n\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = item_index\n\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = -1\n\n        item = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if not self._check_separation_compatibility(item, truck):\n                continue\n            \n            x, y, z, orientation, score = self._find_best_position_in_truck(item, truck, truck_type)\n\n            if score > best_score:\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_score = score\n\n        x, y, z, orientation, score = self._find_best_position_in_new_truck(item, truck_type)\n        if score > best_score:\n                best_truck_index = -1\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = -1\n\n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item)):\n            positions = self._generate_potential_positions(item_dims, truck_type, truck['occupied_volumes'])\n            for x, y, z in positions:\n                item_pos = (float(x), float(y), float(z))\n                if self._is_valid_placement(item_pos, item_dims, truck_type, truck['occupied_volumes']):\n                    score = self._evaluate_placement(item_pos, item_dims, truck_type, truck['occupied_volumes'])\n                    if score > best_score:\n                        best_x = float(x)\n                        best_y = float(y)\n                        best_z = float(z)\n                        best_orientation = orientation_index\n                        best_score = score\n\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_best_position_in_new_truck(self, item, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = -1\n\n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item)):\n            x, y, z = 0, 0, 0\n            item_pos = (float(x), float(y), float(z))\n            if self._is_valid_placement(item_pos, item_dims, truck_type, []):\n                score = self._evaluate_placement(item_pos, item_dims, truck_type, [])\n                if score > best_score:\n                    best_x = float(x)\n                    best_y = float(y)\n                    best_z = float(z)\n                    best_orientation = orientation_index\n                    best_score = score\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _generate_potential_positions(self, item_dims, container_dims, occupied_volumes):\n        potential_positions = []\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        for placed_item in occupied_volumes:\n            x = placed_item['x'] + placed_item['length']\n            y = placed_item['y'] + placed_item['width']\n            z = placed_item['z'] + placed_item['height']\n\n            potential_positions.append((x, placed_item['y'], placed_item['z']))\n            potential_positions.append((placed_item['x'], y, placed_item['z']))\n            potential_positions.append((placed_item['x'], placed_item['y'], z))\n\n        potential_positions.append((0,0,0))\n\n        valid_positions = []\n        for x, y, z in potential_positions:\n              if self._is_within_container_bounds((x, y, z), item_dims, container_dims):\n                  is_valid = True\n                  for placed_item in occupied_volumes:\n                      placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                      placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                      if self._check_overlap_3d((x, y, z), item_dims, placed_item_pos, placed_item_dims):\n                          is_valid = False\n                          break\n                  if is_valid:\n                      valid_positions.append((x,y,z))\n        \n        return valid_positions\n\n    def _evaluate_placement(self, item_pos, item_dims, container_dims, occupied_volumes):\n        \n        space_utilization_score = 1.0 - (\n            (container_dims[0] - (item_pos[0] + item_dims[0])) *\n            (container_dims[1] - (item_pos[1] + item_dims[1])) *\n            (container_dims[2] - (item_pos[2] + item_dims[2]))\n        ) / (container_dims[0] * container_dims[1] * container_dims[2])\n\n        stability_score = 0.0\n        if item_pos[2] == 0:\n            stability_score = 1.0\n        else:\n            px, py, pz = item_pos\n            pl, pw, _ = item_dims\n            total_support_area = 0.0\n            for placed_item in occupied_volumes:\n                placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n\n            \n                if abs((placed_item_pos[2] + placed_item_dims[2]) - pz) < self.epsilon:\n            \n                    overlap_x = max(0, min(px + pl, placed_item_pos[0] + placed_item_dims[0]) - max(px, placed_item_pos[0]))\n                    overlap_y = max(0, min(py + pw, placed_item_pos[1] + placed_item_dims[1]) - max(py, placed_item_pos[1]))\n                    total_support_area += overlap_x * overlap_y\n            \n            stability_score = total_support_area / (pl*pw) if (pl*pw) > 0 else 1.0\n\n        return (1 - self.stability_weight) * space_utilization_score + self.stability_weight * stability_score",
          "objective": 24.55,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects the unplaced item with the largest space demand (volume * quantity), and places it into the best position in the best truck, creating a new truck if necessary, using a score that considers both the space utilization and the stability",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n        # {Selects the unplaced item with the largest space demand (volume * quantity), and places it into the best position in the best truck, creating a new truck if necessary, using a score that considers both the space utilization and the stability}\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, -1, -1, -1, -1\n\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_space_demand = -1\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                space_demand = item['length'] * item['width'] * item['height'] * item['quantity']\n                if space_demand > max_space_demand:\n                    max_space_demand = space_demand\n                    best_item_index = item_index\n\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = -1\n\n        item = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if not self._check_separation_compatibility(item, truck):\n                continue\n            \n            x, y, z, orientation, score = self._find_best_position_in_truck(item, truck, truck_type)\n\n            if score > best_score:\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_score = score\n\n        x, y, z, orientation, score = self._find_best_position_in_new_truck(item, truck_type)\n        if score > best_score:\n                best_truck_index = -1\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = -1\n\n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item)):\n            positions = self._generate_potential_positions(item_dims, truck_type, truck['occupied_volumes'])\n            for x, y, z in positions:\n                item_pos = (float(x), float(y), float(z))\n                if self._is_valid_placement(item_pos, item_dims, truck_type, truck['occupied_volumes']):\n                    score = self._evaluate_placement(item_pos, item_dims, truck_type, truck['occupied_volumes'])\n                    if score > best_score:\n                        best_x = float(x)\n                        best_y = float(y)\n                        best_z = float(z)\n                        best_orientation = orientation_index\n                        best_score = score\n\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_best_position_in_new_truck(self, item, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = -1\n\n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item)):\n            x, y, z = 0, 0, 0\n            item_pos = (float(x), float(y), float(z))\n            if self._is_valid_placement(item_pos, item_dims, truck_type, []):\n                score = self._evaluate_placement(item_pos, item_dims, truck_type, [])\n                if score > best_score:\n                    best_x = float(x)\n                    best_y = float(y)\n                    best_z = float(z)\n                    best_orientation = orientation_index\n                    best_score = score\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _generate_potential_positions(self, item_dims, container_dims, occupied_volumes):\n        potential_positions = []\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        for placed_item in occupied_volumes:\n            x = placed_item['x'] + placed_item['length']\n            y = placed_item['y'] + placed_item['width']\n            z = placed_item['z'] + placed_item['height']\n\n            potential_positions.append((x, placed_item['y'], placed_item['z']))\n            potential_positions.append((placed_item['x'], y, placed_item['z']))\n            potential_positions.append((placed_item['x'], placed_item['y'], z))\n\n        potential_positions.append((0,0,0))\n\n        valid_positions = []\n        for x, y, z in potential_positions:\n              if self._is_within_container_bounds((x, y, z), item_dims, container_dims):\n                  is_valid = True\n                  for placed_item in occupied_volumes:\n                      placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                      placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                      if self._check_overlap_3d((x, y, z), item_dims, placed_item_pos, placed_item_dims):\n                          is_valid = False\n                          break\n                  if is_valid:\n                      valid_positions.append((x,y,z))\n        \n        return valid_positions\n\n    def _evaluate_placement(self, item_pos, item_dims, container_dims, occupied_volumes):\n        \n        space_utilization_score = 1.0 - (\n            (container_dims[0] - (item_pos[0] + item_dims[0])) *\n            (container_dims[1] - (item_pos[1] + item_dims[1])) *\n            (container_dims[2] - (item_pos[2] + item_dims[2]))\n        ) / (container_dims[0] * container_dims[1] * container_dims[2])\n\n        stability_score = 0.0\n        if item_pos[2] == 0:\n            stability_score = 1.0\n        else:\n            px, py, pz = item_pos\n            pl, pw, _ = item_dims\n            total_support_area = 0.0\n            for placed_item in occupied_volumes:\n                placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n\n            \n                if abs((placed_item_pos[2] + placed_item_dims[2]) - pz) < self.epsilon:\n            \n                    overlap_x = max(0, min(px + pl, placed_item_pos[0] + placed_item_dims[0]) - max(px, placed_item_pos[0]))\n                    overlap_y = max(0, min(py + pw, placed_item_pos[1] + placed_item_dims[1]) - max(py, placed_item_pos[1]))\n                    total_support_area += overlap_x * overlap_y\n            \n            stability_score = total_support_area / (pl*pw) if (pl*pw) > 0 else 1.0\n\n        return space_utilization_score + stability_score",
          "objective": 24.65,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]