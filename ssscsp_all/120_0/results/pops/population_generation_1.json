[
     {
          "algorithm": "Selects the largest unplaced item, iterates through trucks, and attempts to place it using a bottom-left-back heuristic, creating a new truck if necessary.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n        # {Selects the largest unplaced item, iterates through trucks, and attempts to place it using a bottom-left-back heuristic, creating a new truck if necessary.}\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, -1, -1, -1, -1\n\n        truck_index, x, y, z, orientation = self._find_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = item_index\n\n        return best_item_index\n\n    def _find_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n\n        item = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if not self._check_separation_compatibility(item, truck):\n                continue\n\n            x, y, z, orientation = self._find_position_in_truck(item, truck, truck_type)\n            if x != -1:\n                return truck_index, x, y, z, orientation\n\n        x, y, z, orientation = self._find_position_in_new_truck(item, truck_type)\n        if x != -1:\n            return -1, x, y, z, orientation\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item, truck, truck_type):\n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item)):\n            x, y, z = self._bottom_left_back(item_dims, truck_type, truck['occupied_volumes'])\n            if x != -1:\n                item_pos = (float(x), float(y), float(z))\n                if self._is_valid_placement(item_pos, item_dims, truck_type, truck['occupied_volumes']):\n                    return float(x), float(y), float(z), orientation_index\n        return -1, -1, -1, -1\n\n    def _find_position_in_new_truck(self, item, truck_type):\n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item)):\n            x, y, z = 0, 0, 0\n            item_pos = (float(x), float(y), float(z))\n            if self._is_valid_placement(item_pos, item_dims, truck_type, []):\n                return float(x), float(y), float(z), orientation_index\n\n        return -1, -1, -1, -1\n\n    def _bottom_left_back(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = item_dims\n\n        potential_positions = []\n\n        if not occupied_volumes:\n            return 0, 0, 0\n\n        for placed_item in occupied_volumes:\n            x = placed_item['x'] + placed_item['length']\n            y = placed_item['y'] + placed_item['width']\n            z = placed_item['z'] + placed_item['height']\n\n            potential_positions.append((x, placed_item['y'], placed_item['z']))\n            potential_positions.append((placed_item['x'], y, placed_item['z']))\n            potential_positions.append((placed_item['x'], placed_item['y'], z))\n\n        potential_positions.append((0,0,0))\n        valid_positions = []\n        for x, y, z in potential_positions:\n              if self._is_within_container_bounds((x, y, z), item_dims, container_dims):\n                  is_valid = True\n                  for placed_item in occupied_volumes:\n                      placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                      placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                      if self._check_overlap_3d((x, y, z), item_dims, placed_item_pos, placed_item_dims):\n                          is_valid = False\n                          break\n                  if is_valid:\n                      valid_positions.append((x,y,z))\n        \n        best_x, best_y, best_z = -1, -1, -1\n        if valid_positions:\n            best_x, best_y, best_z = min(valid_positions, key=lambda p: (p[2], p[1], p[0]))\n\n        return best_x, best_y, best_z",
          "objective": 25.3,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects the item with the largest footprint and attempts to place it in the best-fit truck based on remaining volume, creating a new truck if needed.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n        # {Selects the item with the largest footprint and attempts to place it in the best-fit truck based on remaining volume, creating a new truck if needed.}\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, -1, -1, -1, -1\n\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_footprint = -1\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                footprint = item['length'] * item['width']\n                if footprint > max_footprint:\n                    max_footprint = footprint\n                    best_item_index = item_index\n\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_remaining_volume = float('inf')\n\n        item = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if not self._check_separation_compatibility(item, truck):\n                continue\n\n            x, y, z, orientation = self._find_best_position_in_truck(item, truck, truck_type)\n            if x != -1:\n                remaining_volume = self._calculate_remaining_volume(truck, truck_type)\n                if remaining_volume < min_remaining_volume:\n                    min_remaining_volume = remaining_volume\n                    best_truck_index = truck_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n        \n        if best_truck_index == -1:\n             x, y, z, orientation = self._find_position_in_new_truck(item, truck_type)\n             if x != -1:\n                  return -1,x,y,z,orientation\n             else:\n                return -1, -1, -1, -1, -1\n        else:\n            return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n\n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item)):\n            x, y, z = self._find_position_bottom_left_back(item_dims, truck_type, truck['occupied_volumes'])\n            if x != -1:\n                item_pos = (float(x), float(y), float(z))\n                if self._is_valid_placement(item_pos, item_dims, truck_type, truck['occupied_volumes']):\n                    return float(x), float(y), float(z), orientation_index\n\n        return -1, -1, -1, -1\n\n    def _find_position_in_new_truck(self, item, truck_type):\n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item)):\n            x, y, z = 0, 0, 0\n            item_pos = (float(x), float(y), float(z))\n            if self._is_valid_placement(item_pos, item_dims, truck_type, []):\n                return float(x), float(y), float(z), orientation_index\n\n        return -1, -1, -1, -1\n\n    def _calculate_remaining_volume(self, truck, truck_type):\n        total_volume = truck_type[0] * truck_type[1] * truck_type[2]\n        occupied_volume = 0\n        for placed_item in truck['occupied_volumes']:\n            occupied_volume += placed_item['length'] * placed_item['width'] * placed_item['height']\n        return total_volume - occupied_volume\n\n    def _find_position_bottom_left_back(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = item_dims\n\n        potential_positions = []\n\n        if not occupied_volumes:\n            return 0, 0, 0\n\n        for placed_item in occupied_volumes:\n            x = placed_item['x'] + placed_item['length']\n            y = placed_item['y'] + placed_item['width']\n            z = placed_item['z'] + placed_item['height']\n\n            potential_positions.append((x, placed_item['y'], placed_item['z']))\n            potential_positions.append((placed_item['x'], y, placed_item['z']))\n            potential_positions.append((placed_item['x'], placed_item['y'], z))\n        potential_positions.append((0,0,0))\n\n        valid_positions = []\n        for x, y, z in potential_positions:\n              if self._is_within_container_bounds((x, y, z), item_dims, container_dims):\n                  is_valid = True\n                  for placed_item in occupied_volumes:\n                      placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                      placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                      if self._check_overlap_3d((x, y, z), item_dims, placed_item_pos, placed_item_dims):\n                          is_valid = False\n                          break\n                  if is_valid:\n                      valid_positions.append((x,y,z))\n\n        best_x, best_y, best_z = -1, -1, -1\n        if valid_positions:\n            best_x, best_y, best_z = min(valid_positions, key=lambda p: (p[2], p[1], p[0]))\n\n        return best_x, best_y, best_z",
          "objective": 25.9,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects items based on a volume-to-quantity ratio and places them using a best-fit heuristic, prioritizing items with separation constraints.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n        # {Selects items based on a volume-to-quantity ratio and places them using a best-fit heuristic, prioritizing items with separation constraints.}\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items, trucks_in_use)\n        if item_index == -1:\n            return -1, -1, -1, -1, -1, -1\n\n        truck_index, x, y, z, orientation = self._find_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items, trucks_in_use):\n        best_item_index = -1\n        best_score = -1\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                quantity = item['quantity']\n                score = volume / quantity\n\n                if item.get('separation_set') is not None:\n                    score *= 2 \n\n                if score > best_score:\n                    best_score = score\n                    best_item_index = item_index\n\n        return best_item_index\n\n    def _find_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n\n        item = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if not self._check_separation_compatibility(item, truck):\n                continue\n\n            x, y, z, orientation, waste = self._find_best_position_in_truck(item, truck, truck_type)\n            if x != -1 and waste < min_waste:\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                min_waste = waste\n\n        x, y, z, orientation, waste = self._find_best_position_in_new_truck(item, truck_type)\n        if x != -1 and waste < min_waste:\n            return -1, x, y, z, orientation\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n\n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item)):\n            x, y, z = self._bottom_left_back(item_dims, truck_type, truck['occupied_volumes'])\n            if x != -1:\n                item_pos = (float(x), float(y), float(z))\n                if self._is_valid_placement(item_pos, item_dims, truck_type, truck['occupied_volumes']):\n                    waste = self._calculate_waste(item_pos, item_dims, truck_type, truck['occupied_volumes'])\n                    if waste < min_waste:\n                        min_waste = waste\n                        best_x = float(x)\n                        best_y = float(y)\n                        best_z = float(z)\n                        best_orientation = orientation_index\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _find_best_position_in_new_truck(self, item, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n\n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item)):\n            x, y, z = 0, 0, 0\n            item_pos = (float(x), float(y), float(z))\n            if self._is_valid_placement(item_pos, item_dims, truck_type, []):\n                waste = self._calculate_waste(item_pos, item_dims, truck_type, [])\n                if waste < min_waste:\n                    min_waste = waste\n                    best_x = float(x)\n                    best_y = float(y)\n                    best_z = float(z)\n                    best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _bottom_left_back(self, item_dims, container_dims, occupied_volumes):\n        l, w, h = item_dims\n\n        potential_positions = []\n\n        if not occupied_volumes:\n            return 0, 0, 0\n\n        for placed_item in occupied_volumes:\n            x = placed_item['x'] + placed_item['length']\n            y = placed_item['y'] + placed_item['width']\n            z = placed_item['z'] + placed_item['height']\n\n            potential_positions.append((x, placed_item['y'], placed_item['z']))\n            potential_positions.append((placed_item['x'], y, placed_item['z']))\n            potential_positions.append((placed_item['x'], placed_item['y'], z))\n\n        potential_positions.append((0,0,0))\n        valid_positions = []\n        for x, y, z in potential_positions:\n              if self._is_within_container_bounds((x, y, z), item_dims, container_dims):\n                  is_valid = True\n                  for placed_item in occupied_volumes:\n                      placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                      placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                      if self._check_overlap_3d((x, y, z), item_dims, placed_item_pos, placed_item_dims):\n                          is_valid = False\n                          break\n                  if is_valid:\n                      valid_positions.append((x,y,z))\n        \n        best_x, best_y, best_z = -1, -1, -1\n        if valid_positions:\n            best_x, best_y, best_z = min(valid_positions, key=lambda p: (p[2], p[1], p[0]))\n\n        return best_x, best_y, best_z\n\n    def _calculate_waste(self, item_pos, item_dims, container_dims, occupied_volumes):\n        total_volume = container_dims[0] * container_dims[1] * container_dims[2]\n        occupied_volume = 0\n        for placed_item in occupied_volumes:\n            occupied_volume += placed_item['length'] * placed_item['width'] * placed_item['height']\n        \n        l,w,h = item_dims\n        occupied_volume += l*w*h\n        return total_volume - occupied_volume",
          "objective": 25.95,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Prioritize placing items in partially filled trucks, selecting the item and orientation that maximize the volume utilization of the truck, with a bias towards lower z positions.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Prioritize placing items in partially filled trucks, selecting the item and orientation that maximize the volume utilization of the truck, with a bias towards lower z positions.}\n    def __init__(self, epsilon=1e-6, alpha=1.0, z_bias=0.1):\n        super().__init__(epsilon, alpha)\n        self.z_bias = z_bias\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        if truck_index == -1:\n            truck_index, item_index, x, y, z, orientation = self._open_new_truck(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_volume_utilization = -1\n\n        for truck_index in range(len(trucks_in_use)):\n            for item_index in range(len(unplaced_items)):\n                if unplaced_items[item_index]['quantity'] > 0 and self._check_separation_compatibility(unplaced_items[item_index], trucks_in_use[truck_index]):\n                    x, y, z, orientation, volume_utilization = self._find_placement_in_truck(unplaced_items[item_index], trucks_in_use[truck_index], truck_type)\n                    if x is not None and volume_utilization > best_volume_utilization:\n                        best_truck_index = truck_index\n                        best_item_index = item_index\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation\n                        best_volume_utilization = volume_utilization\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_placement_in_truck(self, item_type, truck, container_dims):\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_volume_utilization = -1\n\n        for orientation, (item_length, item_width, item_height) in orientations:\n            for x in np.arange(0, container_dims[0] - item_length + self.epsilon, max(1, item_length / 4.0)):\n                for y in np.arange(0, container_dims[1] - item_width + self.epsilon, max(1, item_width / 4.0)):\n                    for z in np.arange(0, container_dims[2] - item_height + self.epsilon, max(1, item_height / 4.0)):\n                        item_pos = (x, y, z)\n                        item_dims = (item_length, item_width, item_height)\n                        if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                            volume_utilization = float(item_length * item_width * item_height) / (container_dims[0] * container_dims[1] * container_dims[2]) - self.z_bias * z / container_dims[2]\n                            if volume_utilization > best_volume_utilization:\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation\n                                best_volume_utilization = volume_utilization\n\n        return best_x, best_y, best_z, best_orientation, best_volume_utilization\n\n    def _open_new_truck(self, unplaced_items, trucks_in_use, truck_type):\n        for item_index in range(len(unplaced_items)):\n            if unplaced_items[item_index]['quantity'] > 0:\n                container_dims = truck_type\n                orientations = self._get_orientations(unplaced_items[item_index])\n                for orientation, (item_length, item_width, item_height) in orientations:\n                    if self._is_within_container_bounds((0, 0, 0), (item_length, item_width, item_height), container_dims):\n                        return -1, item_index, 0, 0, 0, orientation\n        return -1, -1, -1, -1, -1, -1",
          "objective": 26.9,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Iteratively try to place items into existing containers, prioritizing fitting earlier items and considering separation constraints; if no fit is found, open a new container for the first compatible item.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Iteratively try to place items into existing containers, prioritizing fitting earlier items and considering separation constraints; if no fit is found, open a new container for the first compatible item.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        \n        if truck_index == -2:\n            truck_index, item_index, x, y, z, orientation = self._open_new_truck(unplaced_items, trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n    \n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n\n        container_dims = truck_type\n        \n        for item_index in range(len(unplaced_items)):\n            if unplaced_items[item_index]['quantity'] > 0:\n                 for truck_index in range(len(trucks_in_use)):\n\n                    if self._check_separation_compatibility(unplaced_items[item_index], trucks_in_use[truck_index]):\n\n                        best_x, best_y, best_z, best_orientation = self._find_placement_in_truck(unplaced_items[item_index], trucks_in_use[truck_index], container_dims)\n\n                        if best_x is not None:\n                            return truck_index, item_index, best_x, best_y, best_z, best_orientation\n        return -2, -2, -2, -2, -2, -2\n    \n\n    def _find_placement_in_truck(self, item_type, truck, container_dims):\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        \n        for orientation, (item_length, item_width, item_height) in orientations:\n\n            for x in np.arange(0, container_dims[0] - item_length + self.epsilon, 1):\n                for y in np.arange(0, container_dims[1] - item_width + self.epsilon, 1):\n                    for z in np.arange(0, container_dims[2] - item_height + self.epsilon, 1):\n                        item_pos = (x, y, z)\n                        item_dims = (item_length, item_width, item_height)\n                        if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            best_orientation = orientation\n                            return best_x, best_y, best_z, best_orientation\n        return best_x, best_y, best_z, best_orientation\n\n    \n\n    def _open_new_truck(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = None\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                item_index = i\n                break\n\n        if item_index is None:\n            return -1,-1,-1,-1,-1,-1\n        \n        container_dims = truck_type\n        \n        orientations = self._get_orientations(unplaced_items[item_index])\n        for orientation, (item_length, item_width, item_height) in orientations:\n            if self._is_within_container_bounds((0,0,0), (item_length, item_width, item_height), container_dims):\n                return -1, item_index, 0, 0, 0, orientation\n\n        return -1,-1,-1,-1,-1,-1\nclass AlgorithmFIX1(Algorithm):\n    def _find_placement_in_truck(self, item_type, truck, container_dims):\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        max_steps = 500\n        step_count = 0\n\n        for orientation, (item_length, item_width, item_height) in orientations:\n\n            x_range = np.arange(0, container_dims[0] - item_length + self.epsilon, max(1, item_length/2.0))\n            y_range = np.arange(0, container_dims[1] - item_width + self.epsilon, max(1, item_width/2.0))            \n            z_range = np.arange(0, container_dims[2] - item_height + self.epsilon, max(1, item_height/2.0))\n            \n\n            for x in x_range:\n                for y in y_range:\n                    for z in z_range:\n\n                        if step_count > max_steps:\n                            return best_x, best_y, best_z, best_orientation\n\n                        step_count +=1\n                        item_pos = (x, y, z)\n                        item_dims = (item_length, item_width, item_height)\n                        if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            best_orientation = orientation\n                            return best_x, best_y, best_z, best_orientation\n        return best_x, best_y, best_z, best_orientation",
          "objective": 28.5,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     }
]