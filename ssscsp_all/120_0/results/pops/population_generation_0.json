[
     {
          "algorithm": "Iteratively try to place items into existing containers, prioritizing fitting earlier items and considering separation constraints; if no fit is found, open a new container for the first compatible item.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Iteratively try to place items into existing containers, prioritizing fitting earlier items and considering separation constraints; if no fit is found, open a new container for the first compatible item.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        \n        if truck_index == -2:\n            truck_index, item_index, x, y, z, orientation = self._open_new_truck(unplaced_items, trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n    \n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n\n        container_dims = truck_type\n        \n        for item_index in range(len(unplaced_items)):\n            if unplaced_items[item_index]['quantity'] > 0:\n                 for truck_index in range(len(trucks_in_use)):\n\n                    if self._check_separation_compatibility(unplaced_items[item_index], trucks_in_use[truck_index]):\n\n                        best_x, best_y, best_z, best_orientation = self._find_placement_in_truck(unplaced_items[item_index], trucks_in_use[truck_index], container_dims)\n\n                        if best_x is not None:\n                            return truck_index, item_index, best_x, best_y, best_z, best_orientation\n        return -2, -2, -2, -2, -2, -2\n    \n\n    def _find_placement_in_truck(self, item_type, truck, container_dims):\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        \n        for orientation, (item_length, item_width, item_height) in orientations:\n\n            for x in np.arange(0, container_dims[0] - item_length + self.epsilon, 1):\n                for y in np.arange(0, container_dims[1] - item_width + self.epsilon, 1):\n                    for z in np.arange(0, container_dims[2] - item_height + self.epsilon, 1):\n                        item_pos = (x, y, z)\n                        item_dims = (item_length, item_width, item_height)\n                        if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            best_orientation = orientation\n                            return best_x, best_y, best_z, best_orientation\n        return best_x, best_y, best_z, best_orientation\n\n    \n\n    def _open_new_truck(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = None\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                item_index = i\n                break\n\n        if item_index is None:\n            return -1,-1,-1,-1,-1,-1\n        \n        container_dims = truck_type\n        \n        orientations = self._get_orientations(unplaced_items[item_index])\n        for orientation, (item_length, item_width, item_height) in orientations:\n            if self._is_within_container_bounds((0,0,0), (item_length, item_width, item_height), container_dims):\n                return -1, item_index, 0, 0, 0, orientation\n\n        return -1,-1,-1,-1,-1,-1\nclass AlgorithmFIX1(Algorithm):\n    def _find_placement_in_truck(self, item_type, truck, container_dims):\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        max_steps = 500\n        step_count = 0\n\n        for orientation, (item_length, item_width, item_height) in orientations:\n\n            x_range = np.arange(0, container_dims[0] - item_length + self.epsilon, max(1, item_length/2.0))\n            y_range = np.arange(0, container_dims[1] - item_width + self.epsilon, max(1, item_width/2.0))            \n            z_range = np.arange(0, container_dims[2] - item_height + self.epsilon, max(1, item_height/2.0))\n            \n\n            for x in x_range:\n                for y in y_range:\n                    for z in z_range:\n\n                        if step_count > max_steps:\n                            return best_x, best_y, best_z, best_orientation\n\n                        step_count +=1\n                        item_pos = (x, y, z)\n                        item_dims = (item_length, item_width, item_height)\n                        if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            best_orientation = orientation\n                            return best_x, best_y, best_z, best_orientation\n        return best_x, best_y, best_z, best_orientation",
          "objective": 28.5,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     },
     {
          "algorithm": "Iteratively select the 'best' item and orientation by evaluating scoring function and find a valid placement within existing or new truck.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n        # {Iteratively select the 'best' item and orientation by evaluating scoring function and find a valid placement within existing or new truck.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = -1\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] <= 0:\n                continue\n\n            for truck_index, truck in enumerate(trucks_in_use):\n                if not self._check_separation_compatibility(item, truck):\n                    continue\n                \n                x, y, z, orientation, score = self._find_placement_in_truck(item, truck, truck_type)\n                if score > best_score:\n                    best_truck_index = truck_index\n                    best_item_index = item_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n                    best_score = score\n            \n            x, y, z, orientation, score = self._find_placement_in_new_truck(item, truck_type)\n            if score > best_score:\n                best_truck_index = -1\n                best_item_index = item_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_score = score\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_placement_in_truck(self, item, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = -1\n\n        for orientation_index, (orientation_id, (length, width, height)) in enumerate(self._get_orientations(item)):\n            \n            for x in np.arange(0, truck_type[0] - length + self.epsilon, 1.0):\n                for y in np.arange(0, truck_type[1] - width + self.epsilon, 1.0):\n                    for z in np.arange(0, truck_type[2] - height + self.epsilon, 1.0):\n                        \n                        pos = (x, y, z)\n                        dims = (length, width, height)\n                        \n                        if self._is_valid_placement(pos, dims, truck_type, truck['occupied_volumes']):\n                            score = self._evaluate_placement(pos, dims, truck_type)\n                            if score > best_score:\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation_index\n                                best_score = score\n        return best_x, best_y, best_z, best_orientation, best_score\n    \n    def _find_placement_in_new_truck(self, item, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = -1\n        \n        for orientation_index, (orientation_id, (length, width, height)) in enumerate(self._get_orientations(item)):\n            x = 0\n            y = 0\n            z = 0\n\n            pos = (x, y, z)\n            dims = (length, width, height)\n            \n            if self._is_valid_placement(pos, dims, truck_type, []):\n                score = self._evaluate_placement(pos, dims, truck_type)\n                if score > best_score:\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation_index\n                    best_score = score\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _evaluate_placement(self, position, dimensions, container_dims):\n        l, w, h = dimensions\n        cl, cw, ch = container_dims\n        x, y, z = position\n        volume_utilization = (l * w * h) / (cl * cw * ch) \n        z_score = 1 - (z / ch)\n        return volume_utilization + (0.1 * z_score)\nclass AlgorithmFIX1(Algorithm):\n    def _find_placement_in_truck(self, item, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = -1\n        step_size = max(1, min(item['length'], item['width'], item['height']) / 2)\n\n        for orientation_index, (orientation_id, (length, width, height)) in enumerate(self._get_orientations(item)):\n            \n            for x in np.arange(0, truck_type[0] - length + self.epsilon, step_size):\n                for y in np.arange(0, truck_type[1] - width + self.epsilon, step_size):\n                    for z in np.arange(0, truck_type[2] - height + self.epsilon, step_size):\n                        \n                        pos = (x, y, z)\n                        dims = (length, width, height)\n                        \n                        if self._is_valid_placement(pos, dims, truck_type, truck['occupied_volumes']):\n                            score = self._evaluate_placement(pos, dims, truck_type)\n                            if score > best_score:\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation_index\n                                best_score = score\n        return best_x, best_y, best_z, best_orientation, best_score\n    \n    def _find_placement_in_new_truck(self, item, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = -1\n\n        pos = best_x, best_y, best_z\n        dims = 0, 0, 0\n\n        for orientation_index, (orientation_id, (length, width, height)) in enumerate(self._get_orientations(item)):\n            \n            x = 0.0\n            y = 0.0\n            z = 0.0\n            \n            pos = (x, y, z)\n            dims = (length, width, height)\n\n            if self._is_valid_placement(pos, dims, truck_type, []):\n                score = self._evaluate_placement(pos, dims, truck_type)\n                if score > best_score:\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation_index\n                    best_score = score\n\n        return best_x, best_y, best_z, best_orientation, best_score\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = -1\n\n        \n        items_ranked = sorted([(i,item['length']*item['width']*item['height']) for i, item in enumerate(unplaced_items) if item['quantity'] > 0], key = lambda x: x[1], reverse = True)\n\n        for item_rank, item_volume in items_ranked:\n            item_index = item_rank\n            item = unplaced_items[item_index]\n           \n\n            for truck_index, truck in enumerate(trucks_in_use):\n                if not self._check_separation_compatibility(item, truck):\n                    continue\n                \n                x, y, z, orientation, score = self._find_placement_in_truck(item, truck, truck_type)\n                if score > best_score:\n                    best_truck_index = truck_index\n                    best_item_index = item_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n                    best_score = score\n            \n            x, y, z, orientation, score = self._find_placement_in_new_truck(item, truck_type)\n            if score > best_score:\n                best_truck_index = -1\n                best_item_index = item_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_score = score\n            if best_score > 0:\n                break\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation",
          "objective": 41.8,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     },
     {
          "algorithm": "Tries to place items in existing trucks or creates a new truck if needed, prioritizing items based on remaining quantity and truck compatibility.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n        # {Tries to place items in existing trucks or creates a new truck if needed, prioritizing items based on remaining quantity and truck compatibility.}\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                for truck_index, truck in enumerate(trucks_in_use):\n                    if self._check_separation_compatibility(item, truck):\n                        x, y, z, orientation = self._find_placement_in_truck(item, truck, truck_type)\n                        if x != -1:\n                            return truck_index, item_index, x, y, z, orientation\n\n                if best_truck_index == -1:\n                    x, y, z, orientation = self._find_placement_in_new_truck(item, truck_type, unplaced_items, item_index)\n                    if x != -1:\n                       return -1, item_index, x, y, z, orientation\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_placement_in_truck(self, item, truck, truck_type):\n        for orientation_index, (orientation_code, item_dims) in enumerate(self._get_orientations(item)):\n            for x in np.arange(0, truck_type[0], 1):\n                for y in np.arange(0, truck_type[1], 1):\n                    z = 0\n                    item_pos = (float(x), float(y), float(z))\n                    if self._is_valid_placement(item_pos, item_dims, truck_type, truck['occupied_volumes']):\n                        return float(x), float(y), float(z), orientation_index\n        return -1, -1, -1, -1\n\n    def _find_placement_in_new_truck(self, item, truck_type, unplaced_items, item_index):\n                 \n        for orientation_index, (orientation_code, item_dims) in enumerate(self._get_orientations(item)):\n            x, y, z = 0, 0, 0\n            if self._is_within_container_bounds((float(x), float(y), float(z)), item_dims, truck_type):\n                return float(x), float(y), float(z), orientation_index\n\n        return -1, -1, -1, -1",
          "objective": 41.85,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "The algorithm iterates through trucks and items, attempting to place with best-fit placement based on remaining volume, creating a new truck when needed, avoiding incompatible item placement.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n        # {The algorithm iterates through trucks and items, attempting to place with best-fit placement based on remaining volume, creating a new truck when needed, avoiding incompatible item placement.}\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_volume_utilization = -1\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                for truck_index, truck in enumerate(trucks_in_use):\n                    if self._check_separation_compatibility(item, truck):\n                        x, y, z, orientation, volume_utilization = self._find_placement_in_truck(item, truck, truck_type)\n                        if x != -1 and volume_utilization > best_volume_utilization:\n                            best_truck_index = truck_index\n                            best_item_index = item_index\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            best_orientation = orientation\n                            best_volume_utilization = volume_utilization\n        \n        if best_truck_index == -1:\n            truck_index, item_index, x, y, z, orientation = self._place_in_new_truck(unplaced_items, trucks_in_use, truck_type)\n            return truck_index, item_index, x, y, z, orientation\n                \n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_placement_in_truck(self, item, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_volume_utilization = -1\n\n        for orientation_index, (orientation_id, (length, width, height)) in enumerate(self._get_orientations(item)):\n            \n            for x in np.arange(0, truck_type[0], 1):\n                for y in np.arange(0, truck_type[1], 1):\n                    z = 0 \n                    pos = (x, y, z)\n                    dims = (length, width, height)\n                    \n                    if self._is_valid_placement(pos, dims, truck_type, truck['occupied_volumes']):\n                        volume_utilization = (length * width * height) / (truck_type[0] * truck_type[1] * truck_type[2])\n                        if volume_utilization > best_volume_utilization:\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            best_orientation = orientation_index\n                            best_volume_utilization = volume_utilization\n        \n        return best_x, best_y, best_z, best_orientation, best_volume_utilization\n\n    def _place_in_new_truck(self, unplaced_items, trucks_in_use, truck_type):\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                for orientation_index, (orientation_id, (length, width, height)) in enumerate(self._get_orientations(item)):\n                    x, y, z = 0, 0, 0\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, []):\n                        return -1, item_index, x, y, z, orientation_index\n        return -1, -1, -1, -1, -1, -1\nclass AlgorithmFIX1(Algorithm):\n    def _find_placement_in_truck(self, item, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_volume_utilization = -1\n\n        for orientation_index, (orientation_id, (length, width, height)) in enumerate(self._get_orientations(item)):\n            max_x = truck_type[0] - length\n            max_y = truck_type[1] - width\n            if max_x < 0 or max_y < 0:\n                continue\n\n            for x in np.arange(0, max_x + 1, 1):\n                for y in np.arange(0, max_y + 1, 1):\n                    z = 0\n                    pos = (x, y, z)\n                    dims = (length, width, height)\n\n                    if self._is_valid_placement(pos, dims, truck_type, truck['occupied_volumes']):\n                        volume_utilization = (length * width * height) / (truck_type[0] * truck_type[1] * truck_type[2])\n                        if volume_utilization > best_volume_utilization:\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            best_orientation = orientation_index\n                            best_volume_utilization = volume_utilization\n\n        return best_x, best_y, best_z, best_orientation, best_volume_utilization\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_placement_in_truck(self, item, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_volume_utilization = -1\n\n        for orientation_index, (orientation_id, (length, width, height)) in enumerate(self._get_orientations(item)):\n            max_x = truck_type[0] - length\n            max_y = truck_type[1] - width\n            if max_x < 0 or max_y < 0:\n                continue\n\n            x_candidates = np.arange(0, max_x + 1, max(1, length))\n            y_candidates = np.arange(0, max_y + 1, max(1, width))\n            \n\n            for x in x_candidates:\n                for y in y_candidates:\n                    z = 0\n                    pos = (x, y, z)\n                    dims = (length, width, height)\n\n                    if self._is_valid_placement(pos, dims, truck_type, truck['occupied_volumes']):\n                        volume_utilization = (length * width * height) / (truck_type[0] * truck_type[1] * truck_type[2])\n                        if volume_utilization > best_volume_utilization:\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            best_orientation = orientation_index\n                            best_volume_utilization = volume_utilization\n\n        return best_x, best_y, best_z, best_orientation, best_volume_utilization",
          "objective": 45.9,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     },
     {
          "algorithm": "Iteratively place items into trucks, selecting the best item and orientation based on available space and constraints.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Iteratively place items into trucks, selecting the best item and orientation based on available space and constraints.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items, trucks_in_use)\n        if item_index is None:\n            return None, None, None, None, None, None\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items[item_index], trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items, trucks_in_use):\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                return i\n        return None\n\n    def _find_best_placement(self, item, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        max_space_utilization = -1\n\n        for truck_index in range(len(trucks_in_use)):\n            if self._check_separation_compatibility(item, trucks_in_use[truck_index]):\n                x, y, z, orientation, space_utilization = self._find_placement_in_truck(item, trucks_in_use[truck_index], truck_type)\n\n                if x is not None and space_utilization > max_space_utilization:\n                    max_space_utilization = space_utilization\n                    best_truck_index = truck_index\n                    best_x, best_y, best_z = x, y, z\n                    best_orientation = orientation\n\n        if best_truck_index == -1:\n            x, y, z, orientation, space_utilization = self._find_placement_in_new_truck(item, truck_type)\n            if x is not None:\n                best_x, best_y, best_z = x, y, z\n                best_orientation = orientation\n        \n        if best_x is None:\n            return None, None, None, None, None\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation,\n\n    def _find_placement_in_truck(self, item, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        max_space_utilization = -1\n\n        for orientation_index, (orientation, (l, w, h)) in enumerate(self._get_orientations(item)):\n            for x in np.arange(0, container_dims[0] - l + self.epsilon, 1.0):\n                for y in np.arange(0, container_dims[1] - w + self.epsilon, 1.0):\n                    for z in np.arange(0, container_dims[2] - h + self.epsilon, 1.0):\n                        item_pos = (x, y, z)\n                        item_dims = (l, w, h)\n                        if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                            space_utilization = l * w * h\n                            if space_utilization > max_space_utilization:\n                                max_space_utilization = space_utilization\n                                best_x, best_y, best_z = x, y, z\n                                best_orientation = orientation_index\n        \n        return best_x, best_y, best_z, best_orientation, max_space_utilization\n    \n    def _find_placement_in_new_truck(self, item, truck_type):\n        container_dims = truck_type\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        max_space_utilization = -1\n        for orientation_index, (orientation, (l, w, h)) in enumerate(self._get_orientations(item)):\n            x, y, z = 0.0, 0.0, 0.0\n            item_pos = (x, y, z)\n            item_dims = (l, w, h)\n            occupied_volumes = []\n            if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                space_utilization = l * w * h\n                if space_utilization > max_space_utilization:\n                    max_space_utilization = space_utilization\n                    best_x, best_y, best_z = x, y, z\n                    best_orientation = orientation_index\n        return best_x, best_y, best_z, best_orientation, max_space_utilization\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_placement_in_truck(self, item, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        max_space_utilization = -1\n\n        for orientation_index, (orientation, (l, w, h)) in enumerate(self._get_orientations(item)):\n            for x in np.arange(0, container_dims[0] - l + self.epsilon, max(l,w,h)):\n                for y in np.arange(0, container_dims[1] - w + self.epsilon, max(l,w,h)):\n                    for z in np.arange(0, container_dims[2] - h + self.epsilon, max(l,w,h)):\n                        item_pos = (x, y, z)\n                        item_dims = (l, w, h)\n                        if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                            space_utilization = l * w * h\n                            if space_utilization > max_space_utilization:\n                                max_space_utilization = space_utilization\n                                best_x, best_y, best_z = x, y, z\n                                best_orientation = orientation_index\n        \n        return best_x, best_y, best_z, best_orientation, max_space_utilization\n    \n    def _find_placement_in_new_truck(self, item, truck_type):\n        container_dims = truck_type\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        max_space_utilization = -1\n        for orientation_index, (orientation, (l, w, h)) in enumerate(self._get_orientations(item)):\n            x, y, z = 0.0, 0.0, 0.0\n            item_pos = (x, y, z)\n            item_dims = (l, w, h)\n            occupied_volumes = []\n            if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                space_utilization = l * w * h\n                if space_utilization > max_space_utilization:\n                    max_space_utilization = space_utilization\n                    best_x, best_y, best_z = x, y, z\n                    best_orientation = orientation_index\n        return best_x, best_y, best_z, best_orientation, max_space_utilization",
          "objective": 51.15,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     }
]