{
     "algorithm": "Selects an item based on fill ratio and attempts to place it using a bottom-left placement strategy, prioritizing stability and space utilization.",
     "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects an item based on fill ratio and attempts to place it using a bottom-left placement strategy, prioritizing stability and space utilization.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item_to_place(unplaced_items, trucks_in_use, truck_type)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        selected_item = unplaced_items[item_index]\n\n        truck_index, x, y, z, orientation = self._find_best_truck_and_placement(\n            selected_item, trucks_in_use, truck_type\n        )\n\n        if truck_index is None:\n            truck_index, x, y, z, orientation = self._create_new_truck(\n                selected_item, truck_type\n            )\n            if truck_index is None:\n                return None, None, None, None, None, None\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item_to_place(self, unplaced_items, trucks_in_use, truck_type):\n        eligible_items = [\n            i for i, item in enumerate(unplaced_items) if item['quantity'] > 0\n        ]\n        if not eligible_items:\n            return None\n\n        best_item_index = None\n        max_fill_ratio = -1\n\n        for item_index in eligible_items:\n            item = unplaced_items[item_index]\n            item_volume = item['length'] * item['width'] * item['height']\n            \n            for truck in trucks_in_use:\n                if not self._check_separation_compatibility(item, truck):\n                    continue\n                \n                truck_volume = truck_type[0] * truck_type[1] * truck_type[2]\n                occupied_volume = sum(placed_item['length'] * placed_item['width'] * placed_item['height'] for placed_item in truck['occupied_volumes'])\n                available_volume = truck_volume - occupied_volume\n                \n                if available_volume > 0:\n                    fill_ratio = item_volume / available_volume\n                    if fill_ratio > max_fill_ratio:\n                        max_fill_ratio = fill_ratio\n                        best_item_index = item_index\n            \n            if not trucks_in_use:\n                 best_item_index = item_index\n                 break\n\n        if best_item_index is None:\n            best_item_index = eligible_items[0] if eligible_items else None\n\n        return best_item_index\n    \n    def _find_best_truck_and_placement(self, item, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_score = -1\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if not self._check_separation_compatibility(item, truck):\n                continue\n\n            x, y, z, orientation, score = self._find_best_position_in_truck(item, truck, truck_type)\n\n            if x is not None and score > best_score:\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_score = score\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item, truck, truck_type):\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_score = -1\n\n        for orientation, dims in self._get_orientations(item):\n            x, y, z, score = self._find_bottom_left_position(dims, truck, truck_type)\n\n            if x is not None and score > best_score:\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_score = score\n\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_bottom_left_position(self, dims, truck, truck_type):\n        occupied_volumes = truck['occupied_volumes']\n        \n        best_x, best_y, best_z = None, None, None\n        best_score = -1\n\n        for z in sorted(list(set([0] + [item['z'] + item['height'] for item in occupied_volumes]))):\n            for y in sorted(list(set([0] + [item['y'] + item['width'] for item in occupied_volumes]))):\n                for x in sorted(list(set([0] + [item['x'] + item['length'] for item in occupied_volumes]))):\n                    if self._is_valid_placement((x, y, z), dims, truck_type, occupied_volumes):\n                        score = self._calculate_placement_score((x, y, z), dims, truck, truck_type)\n                        if score > best_score:\n                            best_x, best_y, best_z = x, y, z\n                            best_score = score\n        \n        if best_x is None:\n            return None, None, None, -1\n\n        return best_x, best_y, best_z, best_score\n\n    def _calculate_placement_score(self, position, dimensions, truck, truck_type):\n        x, y, z = position\n        l, w, h = dimensions\n        cl, cw, ch = truck_type\n\n        volume_utilization = (l * w * h) / (cl * cw * ch)\n        height_ratio = (z + h) / ch\n        \n        is_bottom = 1 if abs(z) < self.epsilon else 0\n\n        return volume_utilization * 0.4 + (1 - height_ratio) * 0.3 + is_bottom * 0.3\n\n    def _create_new_truck(self, item, truck_type):\n        x, y, z, orientation, score = self._find_best_position_new_truck(item, truck_type)\n        if x is not None:\n            truck_index = 0 if not item.get('separation_set') else item.get('separation_set')-1\n            return -1, x, y, z, orientation\n        return None, None, None, None\n\n    def _find_best_position_new_truck(self, item, truck_type):\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_score = -1\n\n        for orientation, dims in self._get_orientations(item):\n            if self._is_valid_placement((0, 0, 0), dims, truck_type, []):\n                score = self._calculate_placement_score((0, 0, 0), dims, {'occupied_volumes': []}, truck_type)\n\n                if score > best_score:\n                    best_score = score\n                    best_orientation = orientation\n                    best_x = 0\n                    best_y = 0\n                    best_z = 0\n\n        if best_orientation is not None:\n            return best_x, best_y, best_z, best_orientation, best_score\n        return None, None, None, None",
     "objective": 22.75,
     "other_inf": null,
     "class_name": "Algorithm"
}