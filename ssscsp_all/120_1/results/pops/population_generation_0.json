[
     {
          "algorithm": "The algorithm selects an item, iterates through available orientations and truck positions, aiming to find the best valid placement based on a scoring function.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {The algorithm selects an item, iterates through available orientations and truck positions, aiming to find the best valid placement based on a scoring function.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index = -1\n        item_index = -1\n        x = -1\n        y = -1\n        z = -1\n        orientation = -1\n\n        selected_item_index = self._select_item(unplaced_items)\n        if selected_item_index is None:\n            return truck_index, item_index, x, y, z, orientation\n\n        selected_item = unplaced_items[selected_item_index]\n        best_placement = None\n\n        for truck_idx, truck in enumerate(trucks_in_use):\n            if not self._check_separation_compatibility(selected_item, truck):\n                continue\n\n            for orient_idx, (item_orientation, item_dims) in enumerate(self._get_orientations(selected_item)):\n                positions = self._find_valid_positions(truck, truck_type, item_dims)\n\n                for pos_x, pos_y, pos_z in positions :\n                    if self._is_valid_placement(\n                        (pos_x, pos_y, pos_z),\n                        item_dims,\n                        truck_type,\n                        truck['occupied_volumes']\n                    ):\n                        placement_score = self._evaluate_placement(\n                            truck, (pos_x, pos_y, pos_z), item_dims, truck_type\n                        )\n\n                        if best_placement is None or placement_score > best_placement['score']:\n                            best_placement = {\n                                'truck_index': truck_idx,\n                                'item_index': selected_item_index,\n                                'x': pos_x,\n                                'y': pos_y,\n                                'z': pos_z,\n                                'orientation': orient_idx,\n                                'score': placement_score,\n                            }\n\n        if best_placement is None:\n            truck_index = -1\n            for orient_idx, (item_orientation, item_dims) in enumerate(self._get_orientations(selected_item)):\n                positions = self._find_valid_positions({'occupied_volumes': []}, truck_type, item_dims)\n\n                for pos_x, pos_y, pos_z in positions:\n                    if self._is_valid_placement(\n                        (pos_x, pos_y, pos_z),\n                        item_dims,\n                        truck_type,\n                        []\n                    ):\n                        truck_index = -1\n                        item_index = selected_item_index\n                        x = pos_x\n                        y = pos_y\n                        z = pos_z\n                        orientation = orient_idx\n                        return truck_index, item_index, x, y, z, orientation\n        else:\n            truck_index = best_placement['truck_index']\n            item_index = best_placement['item_index']\n            x = best_placement['x']\n            y = best_placement['y']\n            z = best_placement['z']\n            orientation = best_placement['orientation']\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                return i\n        return None\n\n    def _find_valid_positions(self, truck, truck_type, item_dims):\n        positions = []\n        cl, cw, ch = truck_type\n        l, w, h = item_dims\n        epsilon = self.epsilon\n\n        if not truck['occupied_volumes']:\n                positions.append((0, 0, 0))\n                return positions\n\n        for placed_item in truck['occupied_volumes']:\n            px = placed_item['x'] + placed_item['length']\n            py = placed_item['y'] + placed_item['width']\n            pz = placed_item['z'] + placed_item['height']\n            \n            if px + l <= cl + epsilon:\n                positions.append((px, placed_item['y'], placed_item['z']))\n            \n            if py + w <= cw + epsilon :\n                positions.append((placed_item['x'], py, placed_item['z']))\n            if pz + h <= ch + epsilon:\n                positions.append((placed_item['x'], placed_item['y'], pz))\n        positions.append((0,0,0))\n        return positions\n\n    def _evaluate_placement(self, truck, position, item_dims, truck_type):\n         x, y, z = position\n         l, w, h = item_dims\n         \n         cl, cw, ch = truck_type\n         \n         volume_utilization = (l * w * h) / (cl * cw * ch)\n         \n         height_utilization = (z + h) / ch\n         \n         return 1 - height_utilization",
          "objective": 27.7,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Place items into trucks by iterating through potential item types, orientations, and positions, selecting the first valid placement based on separation constraints, container boundaries, overlap, and stability; if no placements exist in current trucks, open a new one.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Place items into trucks by iterating through potential item types, orientations, and positions, selecting the first valid placement based on separation constraints, container boundaries, overlap, and stability; if no placements exist in current trucks, open a new one.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_placement(self, unplaced_items, trucks_in_use, truck_type):\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                for truck_index, truck in enumerate(trucks_in_use):\n                    if self._check_separation_compatibility(item, truck):\n                        placement = self._find_position_for_item_in_truck(item, truck, truck_type,truck_index, item_index)\n                        if placement:\n                            return placement\n                new_truck_placement = self._place_in_new_truck(item, unplaced_items, trucks_in_use, truck_type,item_index)\n                if new_truck_placement:\n                    return new_truck_placement\n        return -1, 0, 0, 0, 0, 0\n\n    def _find_position_for_item_in_truck(self, item, truck, truck_type, truck_index, item_index):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n        for orientation, dims in self._get_orientations(item):\n            l, w, h = dims\n            for x in np.arange(0, container_dims[0] - l + self.epsilon, 1):\n                for y in np.arange(0, container_dims[1] - w + self.epsilon, 1):\n                    for z in np.arange(0, container_dims[2] - h + self.epsilon, 1):\n                        item_pos = (x, y, z)\n                        item_dims = (l, w, h)\n                        if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                            return truck_index, item_index, x, y, z, orientation\n        return None\n\n    def _place_in_new_truck(self, item, unplaced_items, trucks_in_use, truck_type,item_index):\n        container_dims = truck_type\n        for orientation, dims in self._get_orientations(item):\n            l, w, h = dims\n            if l <= container_dims[0] and w <= container_dims[1] and h <= container_dims[2]:\n                x, y, z = 0, 0, 0\n                item_pos = (x, y, z)\n                item_dims = (l, w, h)\n                occupied_volumes = []\n                if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                    separation_set = item.get('separation_set')\n                    return -1, item_index, x, y, z, orientation\n        return None\nclass AlgorithmFIX1(Algorithm):\n    def _find_position_for_item_in_truck(self, item, truck, truck_type, truck_index, item_index):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n        for orientation, dims in self._get_orientations(item):\n            l, w, h = dims\n            x_max = container_dims[0] - l + self.epsilon\n            y_max = container_dims[1] - w + self.epsilon\n            z_max = container_dims[2] - h + self.epsilon\n            \n            x_steps = max(1, int(x_max))\n            y_steps = max(1, int(y_max))\n            z_steps = max(1, int(z_max))\n            \n            for x in np.linspace(0, container_dims[0] - l, num=x_steps):\n                for y in np.linspace(0, container_dims[1] - w, num=y_steps):\n                    for z in np.linspace(0, container_dims[2] - h, num=z_steps):\n                        item_pos = (x, y, z)\n                        item_dims = (l, w, h)\n                        if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                            return truck_index, item_index, x, y, z, orientation\n        return None\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_position_for_item_in_truck(self, item, truck, truck_type, truck_index, item_index):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n        \n        # Reduced search space\n        num_positions = 3\n\n        for orientation, dims in self._get_orientations(item):\n            l, w, h = dims\n\n            # Check if item fits in the container\n            if l > container_dims[0] or w > container_dims[1] or h > container_dims[2]:\n                continue\n\n            for i in range(num_positions):\n                x = (container_dims[0] - l) * i / (num_positions - 1) if num_positions > 1 else 0\n                for j in range(num_positions):\n                    y = (container_dims[1] - w) * j / (num_positions - 1) if num_positions > 1 else 0\n                    for k in range(num_positions):\n                        z = (container_dims[2] - h) * k / (num_positions - 1) if num_positions > 1 else 0\n                        \n                        item_pos = (x, y, z)\n                        item_dims = (l, w, h)\n\n                        if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                            return truck_index, item_index, x, y, z, orientation\n        return None",
          "objective": 31.0,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     },
     {
          "algorithm": "Iteratively selects an item type, tries all orientations and placement positions with a first-fit heuristic.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n        # {Iteratively selects an item type, tries all orientations and placement positions with a first-fit heuristic.}\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        \"\"\"\n        Places an item into a truck, potentially creating a new truck if necessary.\n\n        Args:\n            unplaced_items (list): A list of dictionaries representing unplaced item types.\n            trucks_in_use (list): A list of dictionaries representing trucks currently in use.\n            truck_type (tuple): A tuple representing the dimensions (length, width, height) of a truck.\n\n        Returns:\n            tuple: A tuple containing:\n                - truck_index (int): Index of the truck in trucks_in_use. -1 for a new truck.\n                - item_index (int): Index of the item type in unplaced_items to place.\n                - x (float): x-coordinate of the item placement.\n                - y (float): y-coordinate of the item placement.\n                - z (float): z-coordinate of the item placement.\n                - orientation (int): Orientation of the item (0-5).\n        \"\"\"\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if self._check_separation_compatibility(unplaced_items[item_index], truck):\n                x, y, z, orientation = self._find_valid_position(unplaced_items[item_index], truck, truck_type)\n                if x is not None:\n                    return truck_index, item_index, x, y, z, orientation\n\n        truck_index = -1\n        x, y, z, orientation = self._find_valid_position_new_truck(unplaced_items[item_index], truck_type)\n        if x is not None:\n            return truck_index, item_index, x, y, z, orientation\n\n        return None, None, None, None, None, None\n\n    def _select_item(self, unplaced_items):\n        \"\"\"\n        Selects an item to place based on remaining quantity and item ID.\n        \"\"\"\n        valid_items = [i for i, item in enumerate(unplaced_items) if item['quantity'] > 0]\n        if not valid_items:\n            return None \n\n        return min(valid_items, key=lambda i: (unplaced_items[i]['quantity'], unplaced_items[i]['item_id']))\n\n    def _find_valid_position(self, item, truck, truck_type):\n        \"\"\"\n        Finds a valid position for an item in an existing truck.\n        \"\"\"\n        for orientation, dims in self._get_orientations(item):\n            for x in np.arange(0, truck_type[0], 1.0):\n                for y in np.arange(0, truck_type[1], 1.0):\n                    z = 0.0 \n                    item_pos = (x, y, z)\n                    if self._is_valid_placement(item_pos, dims, truck_type, truck['occupied_volumes']):\n                        return x, y, z, orientation\n\n        return None, None, None, None\n\n    def _find_valid_position_new_truck(self, item, truck_type):\n        \"\"\"\n        Finds a valid position for an item in a new truck.\n        \"\"\"\n        for orientation, dims in self._get_orientations(item):\n            x = 0.0\n            y = 0.0\n            z = 0.0\n            item_pos = (x, y, z)\n            if self._is_valid_placement(item_pos, dims, truck_type, []):\n                return x, y, z, orientation\n\n        return None, None, None, None\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_valid_position(self, item, truck, truck_type):\n        \"\"\"\n        Finds a valid position for an item in an existing truck.\n        \"\"\"\n        x_step = max(1.0, item['length'] / 4)\n        y_step = max(1.0, item['width'] / 4)\n\n        for orientation, dims in self._get_orientations(item):\n            for x in np.arange(0, truck_type[0] - dims[0] + self.epsilon, x_step):\n                for y in np.arange(0, truck_type[1] - dims[1] + self.epsilon, y_step):\n                    z = 0.0 \n                    item_pos = (x, y, z)\n                    if self._is_valid_placement(item_pos, dims, truck_type, truck['occupied_volumes']):\n                        return x, y, z, orientation\n\n        return None, None, None, None\n\n    def _find_valid_position_new_truck(self, item, truck_type):\n        \"\"\"\n        Finds a valid position for an item in a new truck.\n        \"\"\"\n        x_step = max(1.0, item['length'] / 4)\n        y_step = max(1.0, item['width'] / 4)\n\n        for orientation, dims in self._get_orientations(item):\n            x = 0.0\n            y = 0.0\n            z = 0.0\n            item_pos = (x, y, z)\n            if self._is_valid_placement(item_pos, dims, truck_type, []):\n                return x, y, z, orientation\n\n        return None, None, None, None",
          "objective": 41.4,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     },
     {
          "algorithm": "This algorithm iterates through unplaced items, tries all orientations and positions in existing/new trucks, and selects the best placement based on a simple heuristic.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm iterates through unplaced items, tries all orientations and positions in existing/new trucks, and selects the best placement based on a simple heuristic.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_volume_utilization = -1\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] <= 0:\n                continue\n\n            for truck_index, truck in enumerate(trucks_in_use):\n                if not self._check_separation_compatibility(item, truck):\n                    continue\n\n                occupied_volumes = truck['occupied_volumes']\n                \n                for orientation, dims in self._get_orientations(item):\n                    l, w, h = dims\n                    \n                    # Simple placement strategy: try to place the item at the bottom-left corner.\n                    x, y, z = 0.0, 0.0, 0.0\n                    \n                    valid_placement = self._is_valid_placement((x, y, z), (l, w, h), truck_type, occupied_volumes)\n                    if valid_placement:\n                        volume = l * w * h\n                        current_truck_volume = sum(i['length'] * i['width'] * i['height'] for i in occupied_volumes)\n                        truck_capacity = truck_type[0] * truck_type[1] * truck_type[2]\n                        volume_utilization = (current_truck_volume + volume) / truck_capacity\n\n                        if best_volume_utilization == -1 or volume_utilization > best_volume_utilization:\n                            best_truck_index = truck_index\n                            best_item_index = item_index\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            best_orientation = orientation\n                            best_volume_utilization = volume_utilization\n           \n            for orientation, dims in self._get_orientations(item):\n                new_truck_index = -1\n                if len(trucks_in_use) == 0 or (item.get('separation_set') is None and trucks_in_use[0].get('separation_set') is not None) or \\\n                    (item.get('separation_set') is not None and (len(trucks_in_use) > 0 and trucks_in_use[-1].get('separation_set') != item.get('separation_set'))):\n                        \n                    truck_separation_set = item.get('separation_set')\n                    \n                    l, w, h = dims\n                    x, y, z = 0.0, 0.0, 0.0\n                    occupied_volumes = []\n\n                    valid_placement = self._is_valid_placement((x, y, z), (l, w, h), truck_type, occupied_volumes)\n                    if valid_placement:\n                        volume = l * w * h\n                        capacity = truck_type[0] * truck_type[1] * truck_type[2]\n                        volume_utilization = volume / capacity\n                        if best_volume_utilization == -1 or volume_utilization > best_volume_utilization:\n                            best_truck_index = new_truck_index\n                            best_item_index = item_index\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            best_orientation = orientation\n                            best_volume_utilization = volume_utilization\n                            \n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\nclass AlgorithmFIX1(Algorithm):\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_volume_utilization = -1\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] <= 0:\n                continue\n\n            for truck_index, truck in enumerate(trucks_in_use):\n                if not self._check_separation_compatibility(item, truck):\n                    continue\n\n                occupied_volumes = truck['occupied_volumes']\n                \n                for orientation, dims in self._get_orientations(item):\n                    l, w, h = dims\n                    \n                    # Simple placement strategy: try to place the item at the bottom-left corner.\n                    x, y, z = 0.0, 0.0, 0.0\n                    \n                    valid_placement = self._is_valid_placement((x, y, z), (l, w, h), truck_type, occupied_volumes)\n                    if valid_placement:\n                        volume = l * w * h\n                        current_truck_volume = sum(i['length'] * i['width'] * i['height'] for i in occupied_volumes)\n                        truck_capacity = truck_type[0] * truck_type[1] * truck_type[2]\n                        volume_utilization = (current_truck_volume + volume) / truck_capacity\n\n                        if best_volume_utilization == -1 or volume_utilization > best_volume_utilization:\n                            best_truck_index = truck_index\n                            best_item_index = item_index\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            best_orientation = orientation\n                            best_volume_utilization = volume_utilization\n           \n            new_truck_index = -1 \n            if len(trucks_in_use) == 0 or (item.get('separation_set') is None and trucks_in_use[0].get('separation_set') is not None) or \\\n                (item.get('separation_set') is not None and (len(trucks_in_use) > 0 and trucks_in_use[-1].get('separation_set') != item.get('separation_set'))):\n                    \n                l, w, h = self._get_orientations(item)[0][1]\n                x, y, z = 0.0, 0.0, 0.0\n                \n                any_valid = False\n                for orientation, dims in self._get_orientations(item):\n                        l, w, h = dims\n                        x, y, z = 0.0, 0.0, 0.0\n                        occupied_volumes = []\n                        \n                        valid_placement = self._is_valid_placement((x, y, z), (l, w, h), truck_type, occupied_volumes)\n                        \n                        if valid_placement:\n                            volume = l * w * h\n                            capacity = truck_type[0] * truck_type[1] * truck_type[2]\n                            volume_utilization = volume / capacity\n                            if best_volume_utilization == -1 or volume_utilization > best_volume_utilization:\n                                best_truck_index = new_truck_index\n                                best_item_index = item_index\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation\n                                best_volume_utilization = volume_utilization\n                                any_valid = True\n                if not any_valid and best_truck_index == -1:\n                    continue # No valid placement found\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_volume_utilization = -1\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] <= 0:\n                continue\n\n            for truck_index, truck in enumerate(trucks_in_use):\n                if not self._check_separation_compatibility(item, truck):\n                    continue\n\n                occupied_volumes = truck['occupied_volumes']\n                \n                for orientation, dims in self._get_orientations(item):\n                    l, w, h = dims\n                    x, y, z = 0.0, 0.0, 0.0\n                    \n                    valid_placement = self._is_valid_placement((x, y, z), (l, w, h), truck_type, occupied_volumes)\n                    if valid_placement:\n                        volume = l * w * h\n                        current_truck_volume = sum(i['length'] * i['width'] * i['height'] for i in occupied_volumes)\n                        truck_capacity = truck_type[0] * truck_type[1] * truck_type[2]\n                        volume_utilization = (current_truck_volume + volume) / truck_capacity\n\n                        if best_volume_utilization == -1 or volume_utilization > best_volume_utilization:\n                            best_truck_index = truck_index\n                            best_item_index = item_index\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            best_orientation = orientation\n                            best_volume_utilization = volume_utilization\n           \n            new_truck_index = -1\n            any_valid = False\n            for orientation, dims in self._get_orientations(item):\n                l, w, h = dims\n                x, y, z = 0.0, 0.0, 0.0\n                occupied_volumes = []\n                \n                valid_placement = self._is_valid_placement((x, y, z), (l, w, h), truck_type, occupied_volumes)\n                \n                if valid_placement:\n                    volume = l * w * h\n                    capacity = truck_type[0] * truck_type[1] * truck_type[2]\n                    volume_utilization = volume / capacity\n                    if best_volume_utilization == -1 or volume_utilization > best_volume_utilization:\n                        best_truck_index = new_truck_index\n                        best_item_index = item_index\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation\n                        best_volume_utilization = volume_utilization\n                        any_valid = True\n            if (len(trucks_in_use) == 0 or (item.get('separation_set') is None and trucks_in_use[0].get('separation_set') is not None) or\n                (item.get('separation_set') is not None and (len(trucks_in_use) > 0 and trucks_in_use[-1].get('separation_set') != item.get('separation_set')))) and not any_valid and best_truck_index == -1:\n                continue\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation",
          "objective": 101.5,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     }
]