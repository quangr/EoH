[
     {
          "algorithm": "Focuses on minimizing wasted space by prioritizing the item type that fits best within the container's remaining volume, combined with a slight preference for items on the floor to improve stability.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Focuses on minimizing wasted space by prioritizing the item type that fits best within the container's remaining volume, combined with a slight preference for items on the floor to improve stability.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item_to_place(unplaced_items, trucks_in_use, truck_type)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        selected_item = unplaced_items[item_index]\n        truck_index, x, y, z, orientation = self._find_best_placement_for_item(\n            selected_item, trucks_in_use, truck_type\n        )\n\n        if truck_index is None:\n            truck_index, x, y, z, orientation = self._create_new_truck_for_item(\n                selected_item, truck_type\n            )\n            if truck_index is None:\n                return None, None, None, None, None, None\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item_to_place(self, unplaced_items, trucks_in_use, truck_type):\n        eligible_items = [\n            i for i, item in enumerate(unplaced_items) if item['quantity'] > 0\n        ]\n        if not eligible_items:\n            return None\n\n        best_fit_item = None\n        best_fit_score = -1.0\n\n        for item_index in eligible_items:\n            item = unplaced_items[item_index]\n            \n            for truck in trucks_in_use:\n                if self._check_separation_compatibility(item, truck):\n                    remaining_volume = self._calculate_remaining_volume(truck, truck_type)\n                    item_volume = item['length'] * item['width'] * item['height']\n                    fit_score = item_volume / remaining_volume if remaining_volume > 0 else 0\n                    \n                    if fit_score > best_fit_score:\n                        best_fit_score = fit_score\n                        best_fit_item = item_index\n\n        if best_fit_item is None and eligible_items:\n            best_fit_item = eligible_items[0]\n\n        return best_fit_item\n\n    def _calculate_remaining_volume(self, truck, truck_type):\n        cl, cw, ch = truck_type\n        occupied_volume = 0.0\n        for item in truck['occupied_volumes']:\n            occupied_volume += item['length'] * item['width'] * item['height']\n        return (cl * cw * ch) - occupied_volume\n\n    def _find_best_placement_for_item(self, item, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_placement_score = -1.0\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if not self._check_separation_compatibility(item, truck):\n                continue\n\n            x, y, z, orientation, placement_score = self._find_best_position_in_truck(\n                item, truck, truck_type\n            )\n            if x is not None and placement_score > best_placement_score:\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_placement_score = placement_score\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item, truck, truck_type):\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_placement_score = -1.0\n\n        for orientation, dims in self._get_orientations(item):\n            x, y, z, placement_score = self._find_valid_position_with_placement_score(\n                dims, truck, truck_type\n            )\n\n            if x is not None and placement_score > best_placement_score:\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_placement_score = placement_score\n\n        return best_x, best_y, best_z, best_orientation, best_placement_score\n\n    def _find_valid_position_with_placement_score(self, dims, truck, truck_type):\n        cl, cw, ch = truck_type\n        occupied_volumes = truck['occupied_volumes']\n\n        potential_positions = []\n        for placed_item in occupied_volumes:\n            px = placed_item['x'] + placed_item['length']\n            py = placed_item['y'] + placed_item['width']\n            pz = placed_item['z'] + placed_item['height']\n            potential_positions.extend([\n                (px, placed_item['y'], placed_item['z']),\n                (placed_item['x'], py, placed_item['z']),\n                (placed_item['x'], placed_item['y'], pz),\n            ])\n        potential_positions.append((0, 0, 0))\n        \n        valid_positions_with_score = []\n        for x, y, z in potential_positions:\n            if self._is_valid_placement((x, y, z), dims, truck_type, occupied_volumes):\n                placement_score = self._calculate_placement_score(\n                    (x, y, z), dims, truck, truck_type\n                )\n                valid_positions_with_score.append((x, y, z, placement_score))\n\n        if not valid_positions_with_score:\n            return None, None, None, -1.0\n\n        return max(valid_positions_with_score, key=lambda p: p[3])\n\n    def _create_new_truck_for_item(self, item, truck_type):\n        x, y, z, orientation, placement_score = self._find_best_position_new_truck(item, truck_type)\n        if x is not None:\n            return -1, x, y, z, orientation\n        return None, None, None, None\n\n    def _find_best_position_new_truck(self, item, truck_type):\n        best_orientation = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_placement_score = -1.0\n\n        for orientation, dims in self._get_orientations(item):\n            if self._is_valid_placement((0, 0, 0), dims, truck_type, []):\n                placement_score = self._calculate_placement_score(\n                    (0, 0, 0), dims, {'occupied_volumes': []}, truck_type\n                )\n\n                if placement_score > best_placement_score:\n                    best_placement_score = placement_score\n                    best_orientation = orientation\n                    best_x = 0\n                    best_y = 0\n                    best_z = 0\n\n        if best_orientation is not None:\n            return best_x, best_y, best_z, best_orientation, best_placement_score\n        return None, None, None, None, -1.0\n\n    def _calculate_placement_score(self, position, dimensions, truck, truck_type):\n        x, y, z = position\n        l, w, h = dimensions\n        cl, cw, ch = truck_type\n\n        volume_utilization = (l * w * h) / (cl * cw * ch)\n        height_ratio = (z + h) / ch\n        \n        stability_factor = 1.0 if z == 0 else 0.0\n\n        return volume_utilization * 0.6 + (1 - height_ratio) * 0.1 + stability_factor * 0.3",
          "objective": 22.8,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects items based on a weighted score of volume utilization and remaining quantity; places them using a best-fit heuristic that prioritizes stability and minimizes height usage.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects items based on a weighted score of volume utilization and remaining quantity; places them using a best-fit heuristic that prioritizes stability and minimizes height usage.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        selected_item_index = self._select_item(unplaced_items)\n        if selected_item_index is None:\n            return None, None, None, None, None, None\n\n        selected_item = unplaced_items[selected_item_index]\n\n        best_truck_index, best_x, best_y, best_z, best_orientation = self._find_best_placement(\n            selected_item, trucks_in_use, truck_type\n        )\n\n        if best_truck_index is None:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._create_new_truck_and_place_item(\n                selected_item, truck_type\n            )\n            if best_truck_index is None:\n                return None, None, None, None, None, None\n\n        return best_truck_index, selected_item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        eligible_items = [\n            i for i, item in enumerate(unplaced_items) if item['quantity'] > 0\n        ]\n        if not eligible_items:\n            return None\n\n        return max(\n            eligible_items,\n            key=lambda i: (\n                unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height'] * unplaced_items[i]['quantity']\n            ),\n        )\n\n    def _find_best_placement(self, item, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_score = float('-inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if not self._check_separation_compatibility(item, truck):\n                continue\n\n            x, y, z, orientation, score = self._find_best_position_in_truck(\n                item, truck, truck_type\n            )\n\n            if x is not None and score > best_score:\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_score = score\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item, truck, truck_type):\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_score = float('-inf')\n\n        for orientation, dims in self._get_orientations(item):\n            x, y, z, score = self._find_valid_position_with_score(\n                dims, truck, truck_type\n            )\n\n            if x is not None and score > best_score:\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_score = score\n\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_valid_position_with_score(self, dims, truck, truck_type):\n        epsilon = self.epsilon\n        cl, cw, ch = truck_type\n\n        if not truck['occupied_volumes']:\n            if self._is_valid_placement((0, 0, 0), dims, truck_type, truck['occupied_volumes']):\n                score = self._calculate_placement_score((0,0,0),dims, truck, truck_type)\n                return 0, 0, 0, score\n\n        potential_positions = []\n\n        for placed_item in truck['occupied_volumes']:\n            px = placed_item['x'] + placed_item['length']\n            py = placed_item['y'] + placed_item['width']\n            pz = placed_item['z'] + placed_item['height']\n\n            if px + dims[0] <= cl + epsilon:\n                potential_positions.append((px, placed_item['y'], placed_item['z']))\n\n            if py + dims[1] <= cw + epsilon:\n                potential_positions.append((placed_item['x'], py, placed_item['z']))\n\n            if pz + dims[2] <= ch + epsilon:\n                potential_positions.append((placed_item['x'], placed_item['y'], pz))\n        potential_positions.append((0, 0, 0))\n\n        valid_positions_with_score = []\n        for x, y, z in potential_positions:\n            if self._is_valid_placement((x, y, z), dims, truck_type, truck['occupied_volumes']):\n                score = self._calculate_placement_score((x,y,z), dims, truck, truck_type)\n                valid_positions_with_score.append((x, y, z, score))\n\n        if not valid_positions_with_score:\n            return None, None, None, None\n\n        return max(valid_positions_with_score, key=lambda p: p[3])\n\n    def _create_new_truck_and_place_item(self, item, truck_type):\n        x, y, z, orientation, score = self._find_valid_position_new_truck(item, truck_type)\n        if x is not None:\n            return -1, x, y, z, orientation\n        return None, None, None, None, None\n\n    def _find_valid_position_new_truck(self, item, truck_type):\n        best_orientation = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_score = float('-inf')\n        for orientation, dims in self._get_orientations(item):\n            if self._is_valid_placement((0, 0, 0), dims, truck_type, []):\n                score = self._calculate_placement_score((0,0,0), dims, {'occupied_volumes':[]}, truck_type)\n\n                if score > best_score:\n                    best_score = score\n                    best_orientation = orientation\n                    best_x = 0\n                    best_y = 0\n                    best_z = 0\n        if best_orientation is not None:\n            return best_x, best_y, best_z, best_orientation, best_score\n        return None, None, None, None, None\n\n    def _calculate_placement_score(self, position, dimensions, truck, truck_type):\n        x, y, z = position\n        l, w, h = dimensions\n        cl, cw, ch = truck_type\n\n        stability_factor = 1.0\n        if z > self.epsilon:\n            support_area = 0.0\n            for placed_item in truck['occupied_volumes']:\n                placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                if abs((placed_item_pos[2] + placed_item_dims[2]) - z) < self.epsilon:\n                    overlap_x = max(0, min(x + l, placed_item_pos[0] + placed_item_dims[0]) - max(x, placed_item_pos[0]))\n                    overlap_y = max(0, min(y + w, placed_item_pos[1] + placed_item_dims[1]) - max(y, placed_item_pos[1]))\n                    support_area += overlap_x * overlap_y\n            stability_factor = support_area / (l * w)\n\n        height_utilization = 1 - (z + h) / ch  # Prefer lower placements (minimizing height)\n        volume_utilization = (l * w * h) / (cl * cw * ch)\n\n        return  stability_factor * 0.1 + height_utilization*0.4  + volume_utilization * 0.5",
          "objective": 23.2,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Places the most space-efficient item first, prioritizing low placement and stability with adjusted scoring weights to encourage base placement.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Places the most space-efficient item first, prioritizing low placement and stability with adjusted scoring weights to encourage base placement.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item_to_place(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        selected_item = unplaced_items[item_index]\n        truck_index, x, y, z, orientation = self._find_best_placement_for_item(\n            selected_item, trucks_in_use, truck_type\n        )\n\n        if truck_index is None:\n            truck_index, x, y, z, orientation = self._create_new_truck_for_item(\n                selected_item, truck_type\n            )\n            if truck_index is None:\n                return None, None, None, None, None, None\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item_to_place(self, unplaced_items):\n        eligible_items = [\n            i for i, item in enumerate(unplaced_items) if item['quantity'] > 0\n        ]\n        if not eligible_items:\n            return None\n\n        return max(eligible_items, key=lambda i: (unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height']) / (unplaced_items[i]['length'] + unplaced_items[i]['width'] + unplaced_items[i]['height']))\n\n    def _find_best_placement_for_item(self, item, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_placement_score = -1.0\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if not self._check_separation_compatibility(item, truck):\n                continue\n\n            x, y, z, orientation, placement_score = self._find_best_position_in_truck(\n                item, truck, truck_type\n            )\n            if x is not None and placement_score > best_placement_score:\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_placement_score = placement_score\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item, truck, truck_type):\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_placement_score = -1.0\n\n        for orientation, dims in self._get_orientations(item):\n            x, y, z, placement_score = self._find_valid_position_with_placement_score(\n                dims, truck, truck_type\n            )\n\n            if x is not None and placement_score > best_placement_score:\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_placement_score = placement_score\n\n        return best_x, best_y, best_z, best_orientation, best_placement_score\n\n    def _find_valid_position_with_placement_score(self, dims, truck, truck_type):\n        cl, cw, ch = truck_type\n        occupied_volumes = truck['occupied_volumes']\n\n        potential_positions = []\n        for placed_item in occupied_volumes:\n            px = placed_item['x'] + placed_item['length']\n            py = placed_item['y'] + placed_item['width']\n            pz = placed_item['z'] + placed_item['height']\n            potential_positions.extend([\n                (px, placed_item['y'], placed_item['z']),\n                (placed_item['x'], py, placed_item['z']),\n                (placed_item['x'], placed_item['y'], pz),\n                (0,0,0)\n            ])\n        potential_positions.append((0, 0, 0))\n\n        valid_positions_with_score = []\n        for x, y, z in potential_positions:\n            if self._is_valid_placement((x, y, z), dims, truck_type, occupied_volumes):\n                placement_score = self._calculate_placement_score(\n                    (x, y, z), dims, truck, truck_type\n                )\n                valid_positions_with_score.append((x, y, z, placement_score))\n\n        if not valid_positions_with_score:\n            return None, None, None, -1.0\n\n        return max(valid_positions_with_score, key=lambda p: p[3])\n\n    def _create_new_truck_for_item(self, item, truck_type):\n        x, y, z, orientation, placement_score = self._find_best_position_new_truck(item, truck_type)\n        if x is not None:\n            truck_index = 0 if not item.get('separation_set') else item.get('separation_set')\n            return -1, x, y, z, orientation\n        return None, None, None, None\n\n    def _find_best_position_new_truck(self, item, truck_type):\n        best_orientation = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_placement_score = -1.0\n\n        for orientation, dims in self._get_orientations(item):\n            if self._is_valid_placement((0, 0, 0), dims, truck_type, []):\n                placement_score = self._calculate_placement_score(\n                    (0, 0, 0), dims, {'occupied_volumes': []}, truck_type\n                )\n\n                if placement_score > best_placement_score:\n                    best_placement_score = placement_score\n                    best_orientation = orientation\n                    best_x = 0\n                    best_y = 0\n                    best_z = 0\n\n        if best_orientation is not None:\n            return best_x, best_y, best_z, best_orientation, best_placement_score\n        return None, None, None, None, -1.0\n\n    def _calculate_placement_score(self, position, dimensions, truck, truck_type):\n        x, y, z = position\n        l, w, h = dimensions\n        cl, cw, ch = truck_type\n\n        volume_utilization = (l * w * h) / (cl * cw * ch)\n        height_ratio = (z + h) / ch\n\n        stability_factor = 1.0\n        if z > self.epsilon:\n            support_area = 0.0\n            for placed_item in truck['occupied_volumes']:\n                placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                if abs((placed_item_pos[2] + placed_item_dims[2]) - z) < self.epsilon:\n                    overlap_x = max(0, min(x + l, placed_item_pos[0] + placed_item_dims[0]) - max(x, placed_item_pos[0]))\n                    overlap_y = max(0, min(y + w, placed_item_pos[1] + placed_item_dims[1]) - max(y, placed_item_pos[1]))\n                    support_area += overlap_x * overlap_y\n            stability_factor = support_area / (l * w)\n        \n        is_base = 1.0 if abs(z) < self.epsilon else 0.0\n\n        return volume_utilization * 0.4 + (1 - height_ratio) * 0.2 + stability_factor * 0.2 + is_base*0.2",
          "objective": 23.25,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects items based on a density score considering volume and required quantity; places items using a corner-occupancy strategy, prioritizing positions that maximize contact with existing items and container walls.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects items based on a density score considering volume and required quantity; places items using a corner-occupancy strategy, prioritizing positions that maximize contact with existing items and container walls.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        selected_item_index = self._select_item(unplaced_items)\n        if selected_item_index is None:\n            return None, None, None, None, None, None\n\n        selected_item = unplaced_items[selected_item_index]\n\n        best_truck_index, best_x, best_y, best_z, best_orientation = self._find_best_placement(selected_item, trucks_in_use, truck_type)\n\n        if best_truck_index is None:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._create_new_truck_and_place_item(selected_item, truck_type)\n            if best_truck_index is None:\n                return None, None, None, None, None, None\n\n        return best_truck_index, selected_item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        eligible_items = [i for i, item in enumerate(unplaced_items) if item['quantity'] > 0]\n        if not eligible_items:\n            return None\n\n        return max(eligible_items, key=lambda i: (unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height']) / unplaced_items[i]['quantity'])\n\n    def _find_best_placement(self, item, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_corner_score = float('-inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if not self._check_separation_compatibility(item, truck):\n                continue\n\n            x, y, z, orientation, corner_score = self._find_best_position_in_truck(item, truck, truck_type)\n\n            if x is not None and corner_score > best_corner_score:\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_corner_score = corner_score\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item, truck, truck_type):\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_corner_score = float('-inf')\n\n        for orientation, dims in self._get_orientations(item):\n            x, y, z, corner_score = self._find_valid_position_with_corner_score(dims, truck, truck_type)\n\n            if x is not None and corner_score > best_corner_score:\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_corner_score = corner_score\n\n        return best_x, best_y, best_z, best_orientation, best_corner_score\n\n    def _find_valid_position_with_corner_score(self, dims, truck, truck_type):\n        epsilon = self.epsilon\n        cl, cw, ch = truck_type\n        occupied_volumes = truck['occupied_volumes']\n\n        potential_positions = []\n        if not occupied_volumes:\n            if self._is_valid_placement((0, 0, 0), dims, truck_type, occupied_volumes):\n                corner_score = self._calculate_corner_score((0, 0, 0), dims, truck_type)\n                return 0, 0, 0, corner_score\n\n        for placed_item in occupied_volumes:\n            px = placed_item['x'] + placed_item['length']\n            py = placed_item['y'] + placed_item['width']\n            pz = placed_item['z'] + placed_item['height']\n\n            if px + dims[0] <= cl + epsilon:\n                potential_positions.append((px, placed_item['y'], placed_item['z']))\n            if py + dims[1] <= cw + epsilon:\n                potential_positions.append((placed_item['x'], py, placed_item['z']))\n            if pz + dims[2] <= ch + epsilon:\n                potential_positions.append((placed_item['x'], placed_item['y'], pz))\n        potential_positions.append((0, 0, 0))\n\n        valid_positions_with_score = []\n        for x, y, z in potential_positions:\n            if self._is_valid_placement((x, y, z), dims, truck_type, occupied_volumes):\n                corner_score = self._calculate_corner_score((x, y, z), dims, truck_type, occupied_volumes)\n                valid_positions_with_score.append((x, y, z, corner_score))\n\n        if not valid_positions_with_score:\n            return None, None, None, None\n\n        return max(valid_positions_with_score, key=lambda p: p[3])\n\n    def _create_new_truck_and_place_item(self, item, truck_type):\n        x, y, z, orientation, corner_score = self._find_valid_position_new_truck(item, truck_type)\n        if x is not None:\n            return -1, x, y, z, orientation\n        return None, None, None, None, None\n\n    def _find_valid_position_new_truck(self, item, truck_type):\n        best_orientation = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_corner_score = float('-inf')\n        for orientation, dims in self._get_orientations(item):\n            if self._is_valid_placement((0, 0, 0), dims, truck_type, []):\n                corner_score = self._calculate_corner_score((0, 0, 0), dims, truck_type, [])\n\n                if corner_score > best_corner_score:\n                    best_corner_score = corner_score\n                    best_orientation = orientation\n                    best_x = 0\n                    best_y = 0\n                    best_z = 0\n        if best_orientation is not None:\n            return best_x, best_y, best_z, best_orientation, best_corner_score\n        return None, None, None, None, None\n\n    def _calculate_corner_score(self, position, dimensions, truck_type, occupied_volumes=None):\n        x, y, z = position\n        l, w, h = dimensions\n        cl, cw, ch = truck_type\n\n        corner_score = 0\n\n        if abs(x) < self.epsilon:\n            corner_score += 1\n        if abs(y) < self.epsilon:\n            corner_score += 1\n        if abs(z) < self.epsilon:\n            corner_score += 1\n        if abs(x + l - cl) < self.epsilon:\n            corner_score += 1\n        if abs(y + w - cw) < self.epsilon:\n            corner_score += 1\n        if abs(z + h - ch) < self.epsilon:\n            corner_score += 1\n\n        if occupied_volumes:\n            for placed_item in occupied_volumes:\n              px = placed_item['x']\n              py = placed_item['y']\n              pz = placed_item['z']\n              pl = placed_item['length']\n              pw = placed_item['width']\n              ph = placed_item['height']\n\n              if abs(x - (px + pl)) < self.epsilon or abs((x + l) - px) < self.epsilon:\n                  corner_score += 0.5\n              if abs(y - (py + pw)) < self.epsilon or abs((y + w) - py) < self.epsilon:\n                  corner_score += 0.5\n              if abs(z - (pz + ph)) < self.epsilon or abs((z + h) - pz) < self.epsilon:\n                  corner_score += 0.5\n        return corner_score",
          "objective": 23.55,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects the item type with the highest remaining quantity, then fits it into the best available truck position according to a space-filling score, and chooses a new truck if needed.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item type with the highest remaining quantity, then fits it into the best available truck position according to a space-filling score, and chooses a new truck if needed.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item_to_place(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        selected_item = unplaced_items[item_index]\n        truck_index, x, y, z, orientation = self._find_best_placement_for_item(\n            selected_item, trucks_in_use, truck_type\n        )\n\n        if truck_index is None:\n            truck_index, x, y, z, orientation = self._create_new_truck_for_item(\n                selected_item, truck_type\n            )\n            if truck_index is None:\n                return None, None, None, None, None, None\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item_to_place(self, unplaced_items):\n        eligible_items = [\n            i for i, item in enumerate(unplaced_items) if item['quantity'] > 0\n        ]\n        if not eligible_items:\n            return None\n\n        return max(eligible_items, key=lambda i: unplaced_items[i]['quantity'])\n\n    def _find_best_placement_for_item(self, item, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_space_fill_score = -1.0\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if not self._check_separation_compatibility(item, truck):\n                continue\n\n            x, y, z, orientation, space_fill_score = self._find_best_position_in_truck(\n                item, truck, truck_type\n            )\n            if x is not None and space_fill_score > best_space_fill_score:\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_space_fill_score = space_fill_score\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item, truck, truck_type):\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_space_fill_score = -1.0\n\n        for orientation, dims in self._get_orientations(item):\n            x, y, z, space_fill_score = self._find_valid_position_with_space_fill_score(\n                dims, truck, truck_type\n            )\n\n            if x is not None and space_fill_score > best_space_fill_score:\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_space_fill_score = space_fill_score\n\n        return best_x, best_y, best_z, best_orientation, best_space_fill_score\n\n    def _find_valid_position_with_space_fill_score(self, dims, truck, truck_type):\n        cl, cw, ch = truck_type\n        occupied_volumes = truck['occupied_volumes']\n\n        potential_positions = []\n        for placed_item in occupied_volumes:\n            px = placed_item['x'] + placed_item['length']\n            py = placed_item['y'] + placed_item['width']\n            pz = placed_item['z'] + placed_item['height']\n            potential_positions.extend([\n                (px, placed_item['y'], placed_item['z']),\n                (placed_item['x'], py, placed_item['z']),\n                (placed_item['x'], placed_item['y'], pz),\n            ])\n        potential_positions.append((0, 0, 0))\n        \n        valid_positions_with_score = []\n        for x, y, z in potential_positions:\n            if self._is_valid_placement((x, y, z), dims, truck_type, occupied_volumes):\n                space_fill_score = self._calculate_space_fill_score(\n                    (x, y, z), dims, truck, truck_type\n                )\n                valid_positions_with_score.append((x, y, z, space_fill_score))\n\n        if not valid_positions_with_score:\n            return None, None, None, -1.0\n\n        return max(valid_positions_with_score, key=lambda p: p[3])\n\n    def _create_new_truck_for_item(self, item, truck_type):\n        x, y, z, orientation, space_fill_score = self._find_best_position_new_truck(item, truck_type)\n        if x is not None:\n            return -1, x, y, z, orientation\n        return None, None, None, None\n\n    def _find_best_position_new_truck(self, item, truck_type):\n        best_orientation = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_space_fill_score = -1.0\n\n        for orientation, dims in self._get_orientations(item):\n            if self._is_valid_placement((0, 0, 0), dims, truck_type, []):\n                space_fill_score = self._calculate_space_fill_score(\n                    (0, 0, 0), dims, {'occupied_volumes': []}, truck_type\n                )\n\n                if space_fill_score > best_space_fill_score:\n                    best_space_fill_score = space_fill_score\n                    best_orientation = orientation\n                    best_x = 0\n                    best_y = 0\n                    best_z = 0\n\n        if best_orientation is not None:\n            return best_x, best_y, best_z, best_orientation, best_space_fill_score\n        return None, None, None, None, -1.0\n\n    def _calculate_space_fill_score(self, position, dimensions, truck, truck_type):\n        x, y, z = position\n        l, w, h = dimensions\n        cl, cw, ch = truck_type\n\n        volume_utilization = (l * w * h) / (cl * cw * ch)\n        height_ratio = (z + h) / ch\n\n        stability_factor = 1.0\n        if z > self.epsilon:\n            support_area = 0.0\n            for placed_item in truck['occupied_volumes']:\n                placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                if abs((placed_item_pos[2] + placed_item_dims[2]) - z) < self.epsilon:\n                    overlap_x = max(0, min(x + l, placed_item_pos[0] + placed_item_dims[0]) - max(x, placed_item_pos[0]))\n                    overlap_y = max(0, min(y + w, placed_item_pos[1] + placed_item_dims[1]) - max(y, placed_item_pos[1]))\n                    support_area += overlap_x * overlap_y\n            stability_factor = support_area / (l * w)\n            \n\n        return volume_utilization * 0.5 + (1 - height_ratio) * 0.3 + stability_factor*0.2",
          "objective": 23.8,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]