[
     {
          "algorithm": "Selects items based on a weighted score of volume utilization and remaining quantity; places them using a best-fit heuristic that prioritizes stability and minimizes height usage.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects items based on a weighted score of volume utilization and remaining quantity; places them using a best-fit heuristic that prioritizes stability and minimizes height usage.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        selected_item_index = self._select_item(unplaced_items)\n        if selected_item_index is None:\n            return None, None, None, None, None, None\n\n        selected_item = unplaced_items[selected_item_index]\n\n        best_truck_index, best_x, best_y, best_z, best_orientation = self._find_best_placement(\n            selected_item, trucks_in_use, truck_type\n        )\n\n        if best_truck_index is None:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._create_new_truck_and_place_item(\n                selected_item, truck_type\n            )\n            if best_truck_index is None:\n                return None, None, None, None, None, None\n\n        return best_truck_index, selected_item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        eligible_items = [\n            i for i, item in enumerate(unplaced_items) if item['quantity'] > 0\n        ]\n        if not eligible_items:\n            return None\n\n        return max(\n            eligible_items,\n            key=lambda i: (\n                unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height'] * unplaced_items[i]['quantity']\n            ),\n        )\n\n    def _find_best_placement(self, item, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_score = float('-inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if not self._check_separation_compatibility(item, truck):\n                continue\n\n            x, y, z, orientation, score = self._find_best_position_in_truck(\n                item, truck, truck_type\n            )\n\n            if x is not None and score > best_score:\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_score = score\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item, truck, truck_type):\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_score = float('-inf')\n\n        for orientation, dims in self._get_orientations(item):\n            x, y, z, score = self._find_valid_position_with_score(\n                dims, truck, truck_type\n            )\n\n            if x is not None and score > best_score:\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_score = score\n\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_valid_position_with_score(self, dims, truck, truck_type):\n        epsilon = self.epsilon\n        cl, cw, ch = truck_type\n\n        if not truck['occupied_volumes']:\n            if self._is_valid_placement((0, 0, 0), dims, truck_type, truck['occupied_volumes']):\n                score = self._calculate_placement_score((0,0,0),dims, truck, truck_type)\n                return 0, 0, 0, score\n\n        potential_positions = []\n\n        for placed_item in truck['occupied_volumes']:\n            px = placed_item['x'] + placed_item['length']\n            py = placed_item['y'] + placed_item['width']\n            pz = placed_item['z'] + placed_item['height']\n\n            if px + dims[0] <= cl + epsilon:\n                potential_positions.append((px, placed_item['y'], placed_item['z']))\n\n            if py + dims[1] <= cw + epsilon:\n                potential_positions.append((placed_item['x'], py, placed_item['z']))\n\n            if pz + dims[2] <= ch + epsilon:\n                potential_positions.append((placed_item['x'], placed_item['y'], pz))\n        potential_positions.append((0, 0, 0))\n\n        valid_positions_with_score = []\n        for x, y, z in potential_positions:\n            if self._is_valid_placement((x, y, z), dims, truck_type, truck['occupied_volumes']):\n                score = self._calculate_placement_score((x,y,z), dims, truck, truck_type)\n                valid_positions_with_score.append((x, y, z, score))\n\n        if not valid_positions_with_score:\n            return None, None, None, None\n\n        return max(valid_positions_with_score, key=lambda p: p[3])\n\n    def _create_new_truck_and_place_item(self, item, truck_type):\n        x, y, z, orientation, score = self._find_valid_position_new_truck(item, truck_type)\n        if x is not None:\n            return -1, x, y, z, orientation\n        return None, None, None, None, None\n\n    def _find_valid_position_new_truck(self, item, truck_type):\n        best_orientation = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_score = float('-inf')\n        for orientation, dims in self._get_orientations(item):\n            if self._is_valid_placement((0, 0, 0), dims, truck_type, []):\n                score = self._calculate_placement_score((0,0,0), dims, {'occupied_volumes':[]}, truck_type)\n\n                if score > best_score:\n                    best_score = score\n                    best_orientation = orientation\n                    best_x = 0\n                    best_y = 0\n                    best_z = 0\n        if best_orientation is not None:\n            return best_x, best_y, best_z, best_orientation, best_score\n        return None, None, None, None, None\n\n    def _calculate_placement_score(self, position, dimensions, truck, truck_type):\n        x, y, z = position\n        l, w, h = dimensions\n        cl, cw, ch = truck_type\n\n        stability_factor = 1.0\n        if z > self.epsilon:\n            support_area = 0.0\n            for placed_item in truck['occupied_volumes']:\n                placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                if abs((placed_item_pos[2] + placed_item_dims[2]) - z) < self.epsilon:\n                    overlap_x = max(0, min(x + l, placed_item_pos[0] + placed_item_dims[0]) - max(x, placed_item_pos[0]))\n                    overlap_y = max(0, min(y + w, placed_item_pos[1] + placed_item_dims[1]) - max(y, placed_item_pos[1]))\n                    support_area += overlap_x * overlap_y\n            stability_factor = support_area / (l * w)\n\n        height_utilization = 1 - (z + h) / ch  # Prefer lower placements (minimizing height)\n        volume_utilization = (l * w * h) / (cl * cw * ch)\n\n        return  stability_factor * 0.1 + height_utilization*0.4  + volume_utilization * 0.5",
          "objective": 23.2,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects items based on a volume-to-quantity ratio, places them in the best-fit position considering both existing trucks and new truck, minimizing wasted space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects items based on a volume-to-quantity ratio, places them in the best-fit position considering both existing trucks and new truck, minimizing wasted space.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        selected_item_index = self._select_item(unplaced_items)\n        if selected_item_index is None:\n            return None, None, None, None, None, None\n\n        selected_item = unplaced_items[selected_item_index]\n\n        best_truck_index, best_x, best_y, best_z, best_orientation = self._find_best_placement(\n            selected_item, trucks_in_use, truck_type\n        )\n\n        if best_truck_index is None:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._create_new_truck_and_place_item(\n                selected_item, truck_type\n            )\n            if best_truck_index is None:\n                return None, None, None, None, None, None\n\n        return best_truck_index, selected_item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        eligible_items = [\n            i for i, item in enumerate(unplaced_items) if item['quantity'] > 0\n        ]\n        if not eligible_items:\n            return None\n\n        return min(\n            eligible_items,\n            key=lambda i: (\n                1.0 / (unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height'] * unplaced_items[i]['quantity'])\n            ),\n        )\n\n    def _find_best_placement(self, item, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        min_waste = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if not self._check_separation_compatibility(item, truck):\n                continue\n\n            x, y, z, orientation, waste = self._find_best_position_in_truck(\n                item, truck, truck_type\n            )\n\n            if x is not None and waste < min_waste:\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                min_waste = waste\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item, truck, truck_type):\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        min_waste = float('inf')\n\n        for orientation, dims in self._get_orientations(item):\n            x, y, z, waste = self._find_valid_position_with_waste(\n                dims, truck, truck_type\n            )\n\n            if x is not None and waste < min_waste:\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                min_waste = waste\n\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _find_valid_position_with_waste(self, dims, truck, truck_type):\n        epsilon = self.epsilon\n        cl, cw, ch = truck_type\n\n        if not truck['occupied_volumes']:\n            if self._is_valid_placement((0, 0, 0), dims, truck_type, truck['occupied_volumes']):\n                waste = cl * cw * ch - dims[0] * dims[1] * dims[2]\n                return 0, 0, 0, waste\n\n        potential_positions = []\n\n        for placed_item in truck['occupied_volumes']:\n            px = placed_item['x'] + placed_item['length']\n            py = placed_item['y'] + placed_item['width']\n            pz = placed_item['z'] + placed_item['height']\n\n            if px + dims[0] <= cl + epsilon:\n                potential_positions.append((px, placed_item['y'], placed_item['z']))\n\n            if py + dims[1] <= cw + epsilon:\n                potential_positions.append((placed_item['x'], py, placed_item['z']))\n\n            if pz + dims[2] <= ch + epsilon:\n                potential_positions.append((placed_item['x'], placed_item['y'], pz))\n        potential_positions.append((0, 0, 0))\n\n        valid_positions_with_waste = []\n        for x, y, z in potential_positions:\n            if self._is_valid_placement((x, y, z), dims, truck_type, truck['occupied_volumes']):\n                \n                max_x = x + dims[0]\n                max_y = y + dims[1]\n                max_z = z + dims[2]\n                \n                waste = cl * cw * ch\n                \n                for placed_item in truck['occupied_volumes']:\n                  waste -= placed_item['length'] * placed_item['width'] * placed_item['height']\n                \n                waste -= dims[0] * dims[1] * dims[2]\n                \n                valid_positions_with_waste.append((x, y, z, waste))\n\n        if not valid_positions_with_waste:\n            return None, None, None, None\n\n        return min(valid_positions_with_waste, key=lambda p: p[3])\n\n    def _create_new_truck_and_place_item(self, item, truck_type):\n        x, y, z, orientation, waste = self._find_valid_position_new_truck(item, truck_type)\n        if x is not None:\n            return -1, x, y, z, orientation\n        return None, None, None, None, None\n\n    def _find_valid_position_new_truck(self, item, truck_type):\n        best_orientation = None\n        best_x = None\n        best_y = None\n        best_z = None\n        min_waste = float('inf')\n        for orientation, dims in self._get_orientations(item):\n            if self._is_valid_placement((0, 0, 0), dims, truck_type, []):\n                waste = truck_type[0] * truck_type[1] * truck_type[2] - dims[0] * dims[1] * dims[2]\n                if waste < min_waste:\n                    min_waste = waste\n                    best_orientation = orientation\n                    best_x = 0\n                    best_y = 0\n                    best_z = 0\n        if best_orientation is not None:\n            return best_x, best_y, best_z, best_orientation,min_waste\n        return None, None, None, None, None",
          "objective": 25.25,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Greedily selects the largest remaining item, places it in the lowest available corner of a suitable existing truck or a new truck using a skyline approach.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Greedily selects the largest remaining item, places it in the lowest available corner of a suitable existing truck or a new truck using a skyline approach.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        selected_item_index = self._select_item(unplaced_items)\n        if selected_item_index is None:\n            return None, None, None, None, None, None\n\n        selected_item = unplaced_items[selected_item_index]\n\n        truck_index, x, y, z, orientation = self._find_best_truck_and_position(\n            selected_item, trucks_in_use, truck_type\n        )\n\n        if truck_index is None:\n            truck_index, x, y, z, orientation = self._create_new_truck_and_place_item(\n                selected_item, truck_type\n            )\n            if truck_index is None:\n                return None, None, None, None, None, None\n\n        return truck_index, selected_item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        eligible_items = [\n            i for i, item in enumerate(unplaced_items) if item['quantity'] > 0\n        ]\n        if not eligible_items:\n            return None\n        return max(\n            eligible_items,\n            key=lambda i: (\n                unplaced_items[i]['length']\n                * unplaced_items[i]['width']\n                * unplaced_items[i]['height']\n            ),\n        )\n\n    def _find_best_truck_and_position(self, item, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if not self._check_separation_compatibility(item, truck):\n                continue\n\n            x, y, z, orientation = self._find_valid_position_in_truck(\n                item, truck, truck_type\n            )\n            if x is not None:\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                break\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_valid_position_in_truck(self, item, truck, truck_type):\n        for orientation, dims in self._get_orientations(item):\n            x, y, z = self._find_lowest_valid_corner(\n                dims, truck, truck_type\n            )\n            if x is not None:\n                return x, y, z, orientation\n        return None, None, None, None\n\n    def _find_lowest_valid_corner(self, dims, truck, truck_type):\n        epsilon = self.epsilon\n        cl, cw, ch = truck_type\n        \n        if not truck['occupied_volumes']:\n            if self._is_valid_placement((0, 0, 0), dims, truck_type, truck['occupied_volumes']):\n                return 0, 0, 0\n\n        \n        potential_positions = []\n\n        for placed_item in truck['occupied_volumes']:\n            px = placed_item['x'] + placed_item['length']\n            py = placed_item['y'] + placed_item['width']\n            pz = placed_item['z'] + placed_item['height']\n\n            if px + dims[0] <= cl + epsilon:\n                potential_positions.append((px, placed_item['y'], placed_item['z']))\n\n            if py + dims[1] <= cw + epsilon :\n                potential_positions.append((placed_item['x'], py, placed_item['z']))\n\n            if pz + dims[2] <= ch + epsilon:\n                potential_positions.append((placed_item['x'], placed_item['y'], pz))\n\n        potential_positions.append((0, 0, 0))\n\n        \n        valid_positions = []\n        for x, y, z in potential_positions:\n            if self._is_valid_placement((x, y, z), dims, truck_type, truck['occupied_volumes']):\n               valid_positions.append((x,y,z))\n               \n        if not valid_positions:\n            return None, None, None\n\n        return min(valid_positions, key=lambda p: (p[2], p[1], p[0]))\n\n    def _create_new_truck_and_place_item(self, item, truck_type):\n        x, y, z, orientation = self._find_valid_position_new_truck(item, truck_type)\n        if x is not None:\n            return -1, x, y, z, orientation\n        return None, None, None, None, None\n\n    def _find_valid_position_new_truck(self, item, truck_type):\n        for orientation, dims in self._get_orientations(item):\n            if self._is_valid_placement((0, 0, 0), dims, truck_type, []):\n                return 0, 0, 0, orientation\n        return None, None, None, None",
          "objective": 25.3,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects the largest remaining item, attempts to place it in the best available truck (lowest Z coordinate first), and if no space then creates a new truck.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the largest remaining item, attempts to place it in the best available truck (lowest Z coordinate first), and if no space then creates a new truck.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_largest_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        item = unplaced_items[item_index]\n        truck_index, x, y, z, orientation = self._find_best_truck_and_position(\n            item, trucks_in_use, truck_type\n        )\n\n        if truck_index is None:\n            truck_index, x, y, z, orientation = self._create_new_truck(\n                item, truck_type\n            )\n            if truck_index is None:\n                return None, None, None, None, None, None\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_largest_item(self, unplaced_items):\n        eligible_items = [\n            i for i, item in enumerate(unplaced_items) if item['quantity'] > 0\n        ]\n\n        if not eligible_items:\n            return None\n\n        return max(\n            eligible_items,\n            key=lambda i: (\n                unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height']\n            ),\n        )\n\n    def _find_best_truck_and_position(self, item, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if not self._check_separation_compatibility(item, truck):\n                continue\n\n            x, y, z, orientation = self._find_position_in_truck(\n                item, truck, truck_type\n            )\n\n            if x is not None:\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                break #first fit, no need to waste compute\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item, truck, truck_type):\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n\n        for orientation, dims in self._get_orientations(item):\n            x, y, z = self._find_valid_position(\n                dims, truck, truck_type\n            )\n\n            if x is not None:\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                break #first fit, no need to waste compute\n\n        return best_x, best_y, best_z, best_orientation\n\n    def _find_valid_position(self, dims, truck, truck_type):\n        cl, cw, ch = truck_type\n        epsilon = self.epsilon\n        occupied_volumes = truck['occupied_volumes']\n\n        # Try placing at the bottom left corner if the truck is empty\n        if not occupied_volumes:\n            if self._is_valid_placement((0, 0, 0), dims, truck_type, occupied_volumes):\n                return 0, 0, 0\n\n        # Generate potential positions based on existing items\n        potential_positions = []\n        for placed_item in occupied_volumes:\n            px = placed_item['x'] + placed_item['length']\n            py = placed_item['y'] + placed_item['width']\n            pz = placed_item['z'] + placed_item['height']\n\n            potential_positions.extend([\n                (px, placed_item['y'], placed_item['z']),\n                (placed_item['x'], py, placed_item['z']),\n                (placed_item['x'], placed_item['y'], pz),\n            ])\n        \n        potential_positions.append((0, 0, 0))\n\n        # Prioritize lower z coordinates for stability\n        potential_positions.sort(key=lambda pos: pos[2])\n\n        for x, y, z in potential_positions:\n            if self._is_valid_placement((x, y, z), dims, truck_type, occupied_volumes):\n                return x, y, z\n\n        return None, None, None\n\n    def _create_new_truck(self, item, truck_type):\n        for orientation, dims in self._get_orientations(item):\n            if self._is_valid_placement((0, 0, 0), dims, truck_type, []):\n                truck_index = -1\n                x = 0\n                y = 0\n                z = 0\n                return truck_index, x, y, z, orientation\n        return None, None, None, None, None",
          "objective": 25.35,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects the item with the highest remaining quantity and places it using a best-fit heuristic based on minimizing wasted space in existing trucks or a new truck.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item with the highest remaining quantity and places it using a best-fit heuristic based on minimizing wasted space in existing trucks or a new truck.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, 0, 0, 0, 0, 0\n\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        best_item_quantity = -1\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                if item['quantity'] > best_item_quantity:\n                    best_item_quantity = item['quantity']\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = 0\n        min_wasted_space = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if self._check_separation_compatibility(unplaced_items[item_index], truck):\n                x, y, z, orientation, wasted_space = self._find_best_fit_in_truck(unplaced_items[item_index], truck, truck_type)\n                if x != -1 and wasted_space < min_wasted_space:\n                    best_truck_index = truck_index\n                    best_x, best_y, best_z = x, y, z\n                    best_orientation = orientation\n                    min_wasted_space = wasted_space\n\n        x, y, z, orientation, wasted_space = self._find_best_fit_in_new_truck(unplaced_items[item_index], truck_type)\n        if x != -1 and wasted_space < min_wasted_space:\n            return -1, x, y, z, orientation\n\n        if best_truck_index != -1:\n            return best_truck_index, best_x, best_y, best_z, best_orientation\n        else:\n            return -1, 0, 0, 0, 0\n\n    def _find_best_fit_in_truck(self, item, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n        best_x, best_y, best_z = -1, -1, -1\n        best_orientation = -1\n        min_wasted_space = float('inf')\n\n        for orientation, dims in self._get_orientations(item):\n            l, w, h = dims\n            \n            for x in np.arange(0, container_dims[0] - l + self.epsilon, 1):\n                for y in np.arange(0, container_dims[1] - w + self.epsilon, 1):\n                    z=0\n                    item_pos = (x, y, z)\n                    item_dims = (l, w, h)\n                    if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                        wasted_space = self._calculate_wasted_space(item_pos,item_dims,container_dims,occupied_volumes)\n                        if wasted_space < min_wasted_space:\n                            best_x, best_y, best_z = x, y, z\n                            best_orientation = orientation\n                            min_wasted_space = wasted_space\n            for x in np.arange(0, container_dims[0] - l + self.epsilon, 1):\n                for y in np.arange(0, container_dims[1] - w + self.epsilon, 1):\n                    for z in np.arange(0, container_dims[2] - h + self.epsilon, 1):\n                        item_pos = (x, y, z)\n                        item_dims = (l, w, h)\n                        if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                            wasted_space = self._calculate_wasted_space(item_pos,item_dims,container_dims,occupied_volumes)\n                            if wasted_space < min_wasted_space:\n                                best_x, best_y, best_z = x, y, z\n                                best_orientation = orientation\n                                min_wasted_space = wasted_space\n        if best_x != -1:\n            return best_x, best_y, best_z, best_orientation, min_wasted_space\n        else:\n            return -1, -1, -1, -1, float('inf')\n            \n\n    def _find_best_fit_in_new_truck(self, item, truck_type):\n        container_dims = truck_type\n        best_x, best_y, best_z = -1, -1, -1\n        best_orientation = -1\n        min_wasted_space = float('inf')\n\n        for orientation, dims in self._get_orientations(item):\n            l, w, h = dims\n            if l <= container_dims[0] and w <= container_dims[1] and h <= container_dims[2]:\n                x, y, z = 0, 0, 0\n                item_pos = (x, y, z)\n                item_dims = (l, w, h)\n                occupied_volumes = []\n                if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                    wasted_space = self._calculate_wasted_space(item_pos, item_dims, container_dims, occupied_volumes)\n                    if wasted_space < min_wasted_space:\n                        best_x, best_y, best_z = x, y, z\n                        best_orientation = orientation\n                        min_wasted_space = wasted_space\n\n        if best_x != -1:\n            return best_x, best_y, best_z, best_orientation, min_wasted_space\n        else:\n            return -1, -1, -1, -1, float('inf')\n\n    def _calculate_wasted_space(self, item_pos, item_dims, container_dims, occupied_volumes):\n        container_volume = container_dims[0] * container_dims[1] * container_dims[2]\n        occupied_volume = 0\n        for placed_item in occupied_volumes:\n            occupied_volume += placed_item['length'] * placed_item['width'] * placed_item['height']\n        occupied_volume += item_dims[0] * item_dims[1] * item_dims[2]\n        wasted_space = container_volume - occupied_volume\n        return wasted_space\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_best_fit_in_truck(self, item, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n        best_x, best_y, best_z = -1, -1, -1\n        best_orientation = -1\n        min_wasted_space = float('inf')\n\n        for orientation, dims in self._get_orientations(item):\n            l, w, h = dims\n            \n            # Reduce the search space for x and y\n            x_candidates = [0]\n            y_candidates = [0]\n            z_candidates = [0]\n            for placed_item in occupied_volumes:\n                x_candidates.append(placed_item['x'] + placed_item['length'])\n                y_candidates.append(placed_item['y'] + placed_item['width'])\n                z_candidates.append(placed_item['z'] + placed_item['height'])\n            \n            x_candidates = sorted(list(set(x for x in x_candidates if x + l <= container_dims[0] + self.epsilon)))\n            y_candidates = sorted(list(set(y for y in y_candidates if y + w <= container_dims[1] + self.epsilon)))\n            z_candidates = sorted(list(set(z for z in z_candidates if z + h <= container_dims[2] + self.epsilon)))\n\n\n            for x in x_candidates:\n                for y in y_candidates:\n                    item_pos = (x, y, 0)\n                    item_dims = (l, w, h)\n                    if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                        wasted_space = self._calculate_wasted_space(item_pos,item_dims,container_dims,occupied_volumes)\n                        if wasted_space < min_wasted_space:\n                            best_x, best_y, best_z = x, y, 0\n                            best_orientation = orientation\n                            min_wasted_space = wasted_space\n            \n            \n            for x in x_candidates:\n                for y in y_candidates:\n                     for z in z_candidates:\n                        item_pos = (x, y, z)\n                        item_dims = (l, w, h)\n                        if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                            wasted_space = self._calculate_wasted_space(item_pos,item_dims,container_dims,occupied_volumes)\n                            if wasted_space < min_wasted_space:\n                                best_x, best_y, best_z = x, y, z\n                                best_orientation = orientation\n                                min_wasted_space = wasted_space\n\n        if best_x != -1:\n            return best_x, best_y, best_z, best_orientation, min_wasted_space\n        else:\n            return -1, -1, -1, -1, float('inf')",
          "objective": 25.45,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     }
]