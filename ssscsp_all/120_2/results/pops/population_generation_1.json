[
     {
          "algorithm": "The algorithm selects the largest volume unplaced item, iterates through trucks finding the first valid placement using a bottom-left-back strategy, and creates a new truck if no placement is found.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {The algorithm selects the largest volume unplaced item, iterates through trucks finding the first valid placement using a bottom-left-back strategy, and creates a new truck if no placement is found.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_placement(unplaced_items[item_index], trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        max_volume = -1\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n        return best_item_index\n\n    def _find_placement(self, item, trucks_in_use, truck_type):\n        for truck_index, truck in enumerate(trucks_in_use):\n            if self._check_separation_compatibility(item, truck):\n                x, y, z, orientation = self._find_position_in_truck(item, truck, truck_type)\n                if x is not None:\n                    return truck_index, x, y, z, orientation\n\n        truck_index, x, y, z, orientation = self._create_new_truck_and_place(item, trucks_in_use, truck_type)\n        return truck_index, x, y, z, orientation\n    \n    def _find_position_in_truck(self, item, truck, truck_type):\n        for orientation_index, (orientation_id, dims) in enumerate(self._get_orientations(item)):\n            length, width, height = dims\n            for z in sorted(list(set([0] + [v['z'] + v['height'] for v in truck['occupied_volumes']]))):\n                for y in sorted(list(set([0] + [v['y'] + v['width'] for v in truck['occupied_volumes']]))):\n                    for x in sorted(list(set([0] + [v['x'] + v['length'] for v in truck['occupied_volumes']]))):\n                        position = (x, y, z)\n                        if self._is_valid_placement(position, (length, width, height), truck_type, truck['occupied_volumes']):\n                            return x, y, z, orientation_id\n        return None, None, None, None\n\n    def _create_new_truck_and_place(self, item, trucks_in_use, truck_type):\n        truck_separation_set = item.get('separation_set')\n        truck = {'occupied_volumes': [], 'separation_set': truck_separation_set}\n        trucks_in_use.append(truck)\n        truck_index = len(trucks_in_use) - 1\n\n        for orientation_index, (orientation_id, dims) in enumerate(self._get_orientations(item)):\n            length, width, height = dims\n            position = (0, 0, 0)\n            if self._is_valid_placement(position, (length, width, height), truck_type, truck['occupied_volumes']):\n                return -1, 0, 0, 0, orientation_id\n        return -1, None, None, None, None",
          "objective": 25.3,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects item maximizing volume utilization within compatible trucks, placing it in best orientation and position, or creates a new truck if necessary.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects item maximizing volume utilization within compatible trucks, placing it in best orientation and position, or creates a new truck if necessary.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_best_item(unplaced_items, trucks_in_use, truck_type)\n        if item_index == -1:\n            return -1, -1, 0, 0, 0, 0\n\n        truck_index, x, y, z, orientation = self._find_best_truck_and_position(unplaced_items[item_index], trucks_in_use, truck_type)\n\n        if truck_index == -1:\n            truck_index, x, y, z, orientation = self._create_new_truck_and_place(unplaced_items[item_index], truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_best_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_item_index = -1\n        max_utilization = -1\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                utilization = self._evaluate_item_utilization(item, trucks_in_use, truck_type)\n                if utilization > max_utilization:\n                    max_utilization = utilization\n                    best_item_index = i\n        return best_item_index\n\n    def _evaluate_item_utilization(self, item, trucks_in_use, truck_type):\n        total_available_volume = 0\n        item_volume = item['length'] * item['width'] * item['height']\n\n        for truck in trucks_in_use:\n            if self._check_separation_compatibility(item, truck):\n                available_volume = truck_type[0] * truck_type[1] * truck_type[2]\n                occupied_volume = sum([v['length'] * v['width'] * v['height'] for v in truck['occupied_volumes']])\n                total_available_volume +=  max(0, available_volume - occupied_volume)\n\n        if total_available_volume == 0:\n            for orientation_index, (orientation_id, (l, w, h)) in enumerate(self._get_orientations(item)):\n                if l <= truck_type[0] and w <= truck_type[1] and h <= truck_type[2]:\n                   return 1\n            return -1\n        \n        return item_volume / total_available_volume\n\n    def _find_best_truck_and_position(self, item, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z, best_orientation = -1, -1, -1, -1\n        max_volume_utilization = -1\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if not self._check_separation_compatibility(item, truck):\n                continue\n\n            x, y, z, orientation, volume_utilization = self._find_best_position_in_truck(item, truck, truck_type)\n            if x != -1 and volume_utilization > max_volume_utilization:\n                best_truck_index = truck_index\n                best_x, best_y, best_z, best_orientation = x, y, z, orientation\n                max_volume_utilization = volume_utilization\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item, truck, truck_type):\n        best_x, best_y, best_z, best_orientation = -1, -1, -1, -1\n        max_volume_utilization = -1\n        \n        occupied_volumes = truck['occupied_volumes']\n        container_dims = truck_type\n\n        for orientation_index, (orientation_id, (l, w, h)) in enumerate(self._get_orientations(item)):\n            x, y, z = 0, 0, 0\n            valid_placement_found = False\n            while z <= container_dims[2] - h + self.epsilon:\n               x, y = 0,0\n               while y <= container_dims[1] - w + self.epsilon:\n                    x = 0\n                    while x <= container_dims[0] - l + self.epsilon:\n\n                        item_pos = (x, y, z)\n                        item_dims = (l, w, h)\n\n                        if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                            volume_utilization = self._calculate_volume_utilization(item_pos, item_dims,truck_type, occupied_volumes)\n\n                            if volume_utilization > max_volume_utilization:\n                                max_volume_utilization = volume_utilization\n                                best_x, best_y, best_z, best_orientation = x, y, z, orientation_id\n\n                        x += 1\n                    y += 1\n               z +=1\n        \n        return best_x, best_y, best_z, best_orientation, max_volume_utilization\n\n    def _calculate_volume_utilization(self, item_pos, item_dims, container_dims, occupied_volumes):\n        px, py, pz = item_pos\n        pl, pw, ph = item_dims\n        \n        item_volume = pl*pw*ph\n\n        available_volume = container_dims[0] * container_dims[1] * container_dims[2]\n        occupied_volume = sum([v['length'] * v['width'] * v['height'] for v in occupied_volumes])\n\n        return item_volume / (max(0, container_dims[0] * container_dims[1] * container_dims[2] - occupied_volume))\n\n\n    def _create_new_truck_and_place(self, item, truck_type):\n        for orientation_index, (orientation_id, (l, w, h)) in enumerate(self._get_orientations(item)):\n            if l <= truck_type[0] and w <= truck_type[1] and h <= truck_type[2]:\n                return -1, 0, 0, 0, orientation_id\n        return -1, 0, 0, 0, 0\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_best_position_in_truck(self, item, truck, truck_type):\n        best_x, best_y, best_z, best_orientation = -1, -1, -1, -1\n        max_volume_utilization = -1\n        \n        occupied_volumes = truck['occupied_volumes']\n        container_dims = truck_type\n\n        for orientation_index, (orientation_id, (l, w, h)) in enumerate(self._get_orientations(item)):\n            \n            potential_positions = []\n            if not occupied_volumes:\n                potential_positions.append((0.0, 0.0, 0.0))\n            else:\n                for placed_item in occupied_volumes:\n                    potential_positions.append((placed_item['x'] + placed_item['length'], placed_item['y'], placed_item['z']))\n                    potential_positions.append((placed_item['x'], placed_item['y'] + placed_item['width'], placed_item['z']))\n                    potential_positions.append((placed_item['x'], placed_item['y'], placed_item['z'] + placed_item['height']))\n                potential_positions.append((0.0, 0.0, 0.0))\n\n            \n            for x, y, z in sorted(list(set(potential_positions))):\n                if x + l <= truck_type[0] + self.epsilon and y + w <= truck_type[1] + self.epsilon and z + h <= truck_type[2] + self.epsilon:\n\n                    item_pos = (x, y, z)\n                    item_dims = (l, w, h)\n\n                    if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                        volume_utilization = self._calculate_volume_utilization(item_pos, item_dims,truck_type, occupied_volumes)\n\n                        if volume_utilization > max_volume_utilization:\n                            max_volume_utilization = volume_utilization\n                            best_x, best_y, best_z, best_orientation = x, y, z, orientation_id\n        \n        return best_x, best_y, best_z, best_orientation, max_volume_utilization",
          "objective": 25.35,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     },
     {
          "algorithm": "Selects item based on a volume-priority score, considering both remaining quantity and item volume for placement in existing or new compatible trucks.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects item based on a volume-priority score, considering both remaining quantity and item volume for placement in existing or new compatible trucks.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, 0, 0, 0, 0\n\n        truck_index, x, y, z, orientation = self._find_best_truck_and_position(unplaced_items[item_index], trucks_in_use, truck_type)\n\n        if truck_index == -1:\n            truck_index, x, y, z, orientation = self._create_new_truck_and_place(unplaced_items[item_index], truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        best_score = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                score = volume * item['quantity']\n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_truck_and_position(self, item, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z, best_orientation = -1, -1, -1, -1\n        \n        for truck_index, truck in enumerate(trucks_in_use):\n            if not self._check_separation_compatibility(item, truck):\n                continue\n\n            x, y, z, orientation = self._find_best_position_in_truck(item, truck, truck_type)\n            if x != -1:\n                best_truck_index = truck_index\n                best_x, best_y, best_z, best_orientation = x, y, z, orientation\n                break\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item, truck, truck_type):\n        occupied_volumes = truck['occupied_volumes']\n        container_dims = truck_type\n        best_x, best_y, best_z, best_orientation = -1, -1, -1, -1\n\n        for orientation_index, (orientation_id, (l, w, h)) in enumerate(self._get_orientations(item)):\n            \n            potential_positions = []\n            if not occupied_volumes:\n                potential_positions.append((0.0, 0.0, 0.0))\n            else:\n                for placed_item in occupied_volumes:\n                    potential_positions.append((placed_item['x'] + placed_item['length'], placed_item['y'], placed_item['z']))\n                    potential_positions.append((placed_item['x'], placed_item['y'] + placed_item['width'], placed_item['z']))\n                    potential_positions.append((placed_item['x'], placed_item['y'], placed_item['z'] + placed_item['height']))\n                potential_positions.append((0.0, 0.0, 0.0))\n                \n            for x, y, z in sorted(list(set(potential_positions))):\n                if x + l <= truck_type[0] and y + w <= truck_type[1] and z + h <= truck_type[2]:\n\n                    item_pos = (x, y, z)\n                    item_dims = (l, w, h)\n\n                    if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                       \n                        return x, y, z, orientation_id\n\n        return -1, -1, -1, -1\n\n    def _create_new_truck_and_place(self, item, truck_type):\n        for orientation_index, (orientation_id, (l, w, h)) in enumerate(self._get_orientations(item)):\n            if l <= truck_type[0] and w <= truck_type[1] and h <= truck_type[2]:\n                return -1, 0, 0, 0, orientation_id\n        return -1, 0, 0, 0, 0",
          "objective": 25.45,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects item by prioritizing quantity and volume, places it in the truck using a bottom-left strategy, favoring stability and minimizing Z; opens a new truck only if placement is impossible.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects item by prioritizing quantity and volume, places it in the truck using a bottom-left strategy, favoring stability and minimizing Z; opens a new truck only if placement is impossible.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_best_item(unplaced_items, trucks_in_use, truck_type)\n        if item_index == -1:\n            return -1, -1, 0, 0, 0, 0\n\n        truck_index, x, y, z, orientation = self._find_best_truck_and_position(unplaced_items[item_index], trucks_in_use, truck_type)\n\n        if truck_index == -1:\n            truck_index, x, y, z, orientation = self._create_new_truck_and_place(unplaced_items[item_index], truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_best_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_item_index = -1\n        max_score = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                score = self._evaluate_item_score(item, trucks_in_use, truck_type)\n                if score > max_score:\n                    max_score = score\n                    best_item_index = i\n        return best_item_index\n\n    def _evaluate_item_score(self, item, trucks_in_use, truck_type):\n        quantity_weight = 0.6\n        volume_weight = 0.4\n        \n        item_volume = item['length'] * item['width'] * item['height']\n\n        if not trucks_in_use:\n            for orientation_index, (orientation_id, (l, w, h)) in enumerate(self._get_orientations(item)):\n                if l <= truck_type[0] and w <= truck_type[1] and h <= truck_type[2]:\n                   return 1\n            return -1\n\n        total_available_volume = 0\n        compatible_trucks = 0\n\n        for truck in trucks_in_use:\n            if self._check_separation_compatibility(item, truck):\n                available_volume = truck_type[0] * truck_type[1] * truck_type[2]\n                occupied_volume = sum([v['length'] * v['width'] * v['height'] for v in truck['occupied_volumes']])\n                total_available_volume += max(0, available_volume - occupied_volume)\n                compatible_trucks += 1\n        \n        if total_available_volume == 0:\n             for orientation_index, (orientation_id, (l, w, h)) in enumerate(self._get_orientations(item)):\n                if l <= truck_type[0] and w <= truck_type[1] and h <= truck_type[2]:\n                   return 1\n             return -1\n        normalized_quantity = item['quantity'] \n        normalized_volume = item_volume / (truck_type[0] * truck_type[1] * truck_type[2])\n\n        return quantity_weight * normalized_quantity + volume_weight * normalized_volume\n\n    def _find_best_truck_and_position(self, item, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z, best_orientation = -1, -1, -1, -1\n        best_placement_score = -1\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if not self._check_separation_compatibility(item, truck):\n                continue\n\n            x, y, z, orientation, placement_score = self._find_best_position_in_truck(item, truck, truck_type)\n            if x != -1 and placement_score > best_placement_score:\n                best_truck_index = truck_index\n                best_x, best_y, best_z, best_orientation = x, y, z, orientation\n                best_placement_score = placement_score\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item, truck, truck_type):\n        best_x, best_y, best_z, best_orientation = -1, -1, -1, -1\n        best_placement_score = -1\n        \n        occupied_volumes = truck['occupied_volumes']\n        container_dims = truck_type\n\n        for orientation_index, (orientation_id, (l, w, h)) in enumerate(self._get_orientations(item)):\n            x, y, z = 0.0, 0.0, 0.0\n            \n            while True:\n                \n                item_pos = (x, y, z)\n                item_dims = (l, w, h)\n\n                if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                    placement_score = self._calculate_placement_score(item_pos, item_dims, truck_type, occupied_volumes)\n\n                    if placement_score > best_placement_score:\n                        best_placement_score = placement_score\n                        best_x, best_y, best_z, best_orientation = x, y, z, orientation_id\n                    \n                    break  \n\n                \n                can_move_x = x + 1 <= container_dims[0] - l + self.epsilon\n                can_move_y = y + 1 <= container_dims[1] - w + self.epsilon\n                can_move_z = z + 1 <= container_dims[2] - h + self.epsilon\n               \n                if can_move_x:\n                   x += 1\n                elif can_move_y:\n                    x = 0\n                    y += 1\n                elif can_move_z:\n                    x = 0\n                    y = 0\n                    z += 1\n                else:\n                    break\n\n        return best_x, best_y, best_z, best_orientation, best_placement_score\n\n    def _calculate_placement_score(self, item_pos, item_dims, container_dims, occupied_volumes):\n        stability_weight = 0.4\n        z_weight = 0.6\n        \n        px, py, pz = item_pos\n        pl, pw, ph = item_dims\n        \n        stability = 1.0 if abs(pz) < self.epsilon or self._check_stability(item_pos, item_dims, occupied_volumes) else 0.0\n        \n        z_normalized = 1.0 - (pz / container_dims[2])\n\n        return stability_weight * stability + z_weight * z_normalized\n\n    def _create_new_truck_and_place(self, item, truck_type):\n        for orientation_index, (orientation_id, (l, w, h)) in enumerate(self._get_orientations(item)):\n            if l <= truck_type[0] and w <= truck_type[1] and h <= truck_type[2]:\n                return -1, 0, 0, 0, orientation_id\n        return -1, 0, 0, 0, 0\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_best_position_in_truck(self, item, truck, truck_type):\n        best_x, best_y, best_z, best_orientation = -1, -1, -1, -1\n        best_placement_score = -1\n        \n        occupied_volumes = truck['occupied_volumes']\n        container_dims = truck_type\n\n        for orientation_index, (orientation_id, (l, w, h)) in enumerate(self._get_orientations(item)):\n            \n            potential_positions = []\n            if not occupied_volumes:\n                potential_positions.append((0.0, 0.0, 0.0))\n            else:\n                for placed_item in occupied_volumes:\n                    potential_positions.append((placed_item['x'] + placed_item['length'], placed_item['y'], placed_item['z']))\n                    potential_positions.append((placed_item['x'], placed_item['y'] + placed_item['width'], placed_item['z']))\n                    potential_positions.append((placed_item['x'], placed_item['y'], placed_item['z'] + placed_item['height']))\n                potential_positions.append((0.0, 0.0, 0.0))\n\n            \n            for x, y, z in sorted(list(set(potential_positions))):\n                if x + l <= truck_type[0] + self.epsilon and y + w <= truck_type[1] + self.epsilon and z + h <= truck_type[2] + self.epsilon:\n\n                    item_pos = (x, y, z)\n                    item_dims = (l, w, h)\n\n                    if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                        placement_score = self._calculate_placement_score(item_pos, item_dims,truck_type, occupied_volumes)\n\n                        if placement_score > best_placement_score:\n                            best_placement_score = placement_score\n                            best_x, best_y, best_z, best_orientation = x, y, z, orientation_id\n        \n        return best_x, best_y, best_z, best_orientation, best_placement_score",
          "objective": 25.7,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     },
     {
          "algorithm": "Selects the unplaced item type with the highest volume-to-quantity ratio and places it in the \"best-fit\" truck based on remaining space, or creates a new truck if no suitable placement is found.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the unplaced item type with the highest volume-to-quantity ratio and places it in the \"best-fit\" truck based on remaining space, or creates a new truck if no suitable placement is found.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_best_truck_and_placement(unplaced_items[item_index], trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        best_ratio = -1\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                ratio = volume / item['quantity']\n                if ratio > best_ratio:\n                    best_ratio = ratio\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_truck_and_placement(self, item, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x, best_y, best_z, best_orientation = None, None, None, None\n        best_remaining_volume = -1\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if self._check_separation_compatibility(item, truck):\n                x, y, z, orientation, remaining_volume = self._find_best_position_in_truck(item, truck, truck_type)\n                if x is not None and remaining_volume > best_remaining_volume:\n                    best_truck_index = truck_index\n                    best_x, best_y, best_z, best_orientation = x, y, z, orientation\n                    best_remaining_volume = remaining_volume\n\n        if best_truck_index is None:\n            truck_index, x, y, z, orientation = self._create_new_truck_and_place(item, trucks_in_use, truck_type)\n            return truck_index, x, y, z, orientation\n        else:\n            return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item, truck, truck_type):\n        best_x, best_y, best_z, best_orientation = None, None, None, None\n        best_remaining_volume = -1\n        container_volume = truck_type[0] * truck_type[1] * truck_type[2]\n        occupied_volume = 0\n        for vol in truck['occupied_volumes']:\n          occupied_volume += vol['length'] * vol['width'] * vol['height']\n        available_volume = container_volume - occupied_volume\n\n        for orientation_index, (orientation_id, dims) in enumerate(self._get_orientations(item)):\n            length, width, height = dims\n            for z in sorted(list(set([0] + [v['z'] + v['height'] for v in truck['occupied_volumes']]))):\n                for y in sorted(list(set([0] + [v['y'] + v['width'] for v in truck['occupied_volumes']]))):\n                    for x in sorted(list(set([0] + [v['x'] + v['length'] for v in truck['occupied_volumes']]))):\n                        position = (x, y, z)\n                        if self._is_valid_placement(position, (length, width, height), truck_type, truck['occupied_volumes']):\n                            remaining_volume = available_volume - (length * width * height)\n                            if remaining_volume > best_remaining_volume:\n                                best_x, best_y, best_z, best_orientation = x, y, z, orientation_id\n                                best_remaining_volume = remaining_volume\n        return best_x, best_y, best_z, best_orientation, best_remaining_volume\n    \n    def _create_new_truck_and_place(self, item, trucks_in_use, truck_type):\n        truck_separation_set = item.get('separation_set')\n        truck = {'occupied_volumes': [], 'separation_set': truck_separation_set}\n        trucks_in_use.append(truck)\n        truck_index = len(trucks_in_use) - 1\n\n        for orientation_index, (orientation_id, dims) in enumerate(self._get_orientations(item)):\n            length, width, height = dims\n            position = (0, 0, 0)\n            if self._is_valid_placement(position, (length, width, height), truck_type, truck['occupied_volumes']):\n                return -1, 0, 0, 0, orientation_id\n        return -1, None, None, None, None",
          "objective": 25.85,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]