[
     {
          "algorithm": "The algorithm selects the largest volume unplaced item, iterates through trucks finding the first valid placement using a bottom-left-back strategy, and creates a new truck if no placement is found.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {The algorithm selects the largest volume unplaced item, iterates through trucks finding the first valid placement using a bottom-left-back strategy, and creates a new truck if no placement is found.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_placement(unplaced_items[item_index], trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        max_volume = -1\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n        return best_item_index\n\n    def _find_placement(self, item, trucks_in_use, truck_type):\n        for truck_index, truck in enumerate(trucks_in_use):\n            if self._check_separation_compatibility(item, truck):\n                x, y, z, orientation = self._find_position_in_truck(item, truck, truck_type)\n                if x is not None:\n                    return truck_index, x, y, z, orientation\n\n        truck_index, x, y, z, orientation = self._create_new_truck_and_place(item, trucks_in_use, truck_type)\n        return truck_index, x, y, z, orientation\n    \n    def _find_position_in_truck(self, item, truck, truck_type):\n        for orientation_index, (orientation_id, dims) in enumerate(self._get_orientations(item)):\n            length, width, height = dims\n            for z in sorted(list(set([0] + [v['z'] + v['height'] for v in truck['occupied_volumes']]))):\n                for y in sorted(list(set([0] + [v['y'] + v['width'] for v in truck['occupied_volumes']]))):\n                    for x in sorted(list(set([0] + [v['x'] + v['length'] for v in truck['occupied_volumes']]))):\n                        position = (x, y, z)\n                        if self._is_valid_placement(position, (length, width, height), truck_type, truck['occupied_volumes']):\n                            return x, y, z, orientation_id\n        return None, None, None, None\n\n    def _create_new_truck_and_place(self, item, trucks_in_use, truck_type):\n        truck_separation_set = item.get('separation_set')\n        truck = {'occupied_volumes': [], 'separation_set': truck_separation_set}\n        trucks_in_use.append(truck)\n        truck_index = len(trucks_in_use) - 1\n\n        for orientation_index, (orientation_id, dims) in enumerate(self._get_orientations(item)):\n            length, width, height = dims\n            position = (0, 0, 0)\n            if self._is_valid_placement(position, (length, width, height), truck_type, truck['occupied_volumes']):\n                return -1, 0, 0, 0, orientation_id\n        return -1, None, None, None, None",
          "objective": 25.3,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Iteratively searches for a valid placement for each item type in available trucks or creates a new truck if needed, prioritizing floor placement and space utilization.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n        # {Iteratively searches for a valid placement for each item type in available trucks or creates a new truck if needed, prioritizing floor placement and space utilization.}\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_placement(self, unplaced_items, trucks_in_use, truck_type):\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                for truck_index, truck in enumerate(trucks_in_use):\n                    if self._check_separation_compatibility(item, truck):\n                         placement = self._find_position_in_truck(item, truck, truck_type, truck_index, item_index,trucks_in_use)\n                         if placement:\n                             return placement\n                new_truck_placement = self._create_new_truck_placement(item, truck_type, item_index)\n                if new_truck_placement:\n                    return new_truck_placement\n        return -1, -1, 0, 0, 0, 0\n\n    def _find_position_in_truck(self, item, truck, truck_type, truck_index, item_index,trucks_in_use):\n        occupied_volumes = truck['occupied_volumes']\n        container_dims = truck_type\n        \n        for orientation_index, (orientation, dims) in enumerate(self._get_orientations(item)):\n            \n            #try floors first\n            for x in [0.0]+sorted(list(set([0.0] + [placed_item['x'] + placed_item['length'] for placed_item in occupied_volumes]))):\n                for y in [0.0]+sorted(list(set([0.0] + [placed_item['y'] + placed_item['width'] for placed_item in occupied_volumes]))):\n                    z=0.0\n                    position = (x, y, z)\n                    if self._is_valid_placement(position, dims, container_dims, occupied_volumes):\n                        return truck_index, item_index, x, y, z, orientation_index\n\n            #try general placement\n            for x in sorted(list(set([0.0] + [placed_item['x'] + placed_item['length'] for placed_item in occupied_volumes]))):\n                for y in sorted(list(set([0.0] + [placed_item['y'] + placed_item['width'] for placed_item in occupied_volumes]))):\n                    for z in sorted(list(set([0.0] + [placed_item['z'] + placed_item['height'] for placed_item in occupied_volumes]))):\n                        position = (x, y, z)\n                        if self._is_valid_placement(position, dims, container_dims, occupied_volumes):\n                            return truck_index, item_index, x, y, z, orientation_index\n           \n        return None\n\n    def _create_new_truck_placement(self, item, truck_type, item_index):\n        container_dims = truck_type\n        for orientation_index, (orientation, dims) in enumerate(self._get_orientations(item)):\n            if self._is_valid_placement((0, 0, 0), dims, container_dims, []):\n                return -1, item_index, 0, 0, 0, orientation_index\n        return None",
          "objective": 27.55,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects the first available item, iterates through truck and orientations to find the first valid placement according to defined constraints.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the first available item, iterates through truck and orientations to find the first valid placement according to defined constraints.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_placement(unplaced_items[item_index], trucks_in_use, truck_type)\n\n        if truck_index is None:\n            truck_index = -1\n            x, y, z, orientation = self._find_placement_new_truck(unplaced_items[item_index], truck_type)\n            if x is None:\n                return None, None, None, None, None, None\n            \n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                return i\n        return None\n\n    def _find_placement(self, item, trucks_in_use, truck_type):\n        for truck_index, truck in enumerate(trucks_in_use):\n            if self._check_separation_compatibility(item, truck):\n                x, y, z, orientation = self._find_position_in_truck(item, truck, truck_type)\n                if x is not None:\n                    return truck_index, x, y, z, orientation\n        return None, None, None, None, None\n\n    def _find_position_in_truck(self, item, truck, truck_type):\n        occupied_volumes = truck['occupied_volumes']\n        for orientation, dims in self._get_orientations(item):\n            l, w, h = dims\n            item_dims = {'length': l, 'width': w, 'height': h}\n            for x in np.arange(0, truck_type[0] - l + self.epsilon, 1):\n                for y in np.arange(0, truck_type[1] - w + self.epsilon, 1):\n                    for z in np.arange(0, truck_type[2] - h + self.epsilon, 1):\n                        item_pos = (x, y, z)\n                        if self._is_valid_placement(item_pos, (l, w, h), truck_type, occupied_volumes):\n                            return x, y, z, orientation\n        return None, None, None, None\n\n    def _find_placement_new_truck(self, item, truck_type):\n        for orientation, dims in self._get_orientations(item):\n            l, w, h = dims\n            x, y, z = 0, 0, 0\n            if self._is_valid_placement((x,y,z), (l, w, h), truck_type, []):\n                return x, y, z, orientation\n        return None, None, None, None\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_position_in_truck(self, item, truck, truck_type):\n        occupied_volumes = truck['occupied_volumes']\n        for orientation, dims in self._get_orientations(item):\n            l, w, h = dims\n            item_dims = {'length': l, 'width': w, 'height': h}\n            \n            step_size_x = max(1, int(l / 2))\n            step_size_y = max(1, int(w / 2))\n            step_size_z = max(1, int(h / 2))\n\n            for x in np.arange(0, truck_type[0] - l + self.epsilon, step_size_x):\n                for y in np.arange(0, truck_type[1] - w + self.epsilon, step_size_y):\n                    for z in np.arange(0, truck_type[2] - h + self.epsilon, step_size_z):\n                        item_pos = (x, y, z)\n                        if self._is_valid_placement(item_pos, (l, w, h), truck_type, occupied_volumes):\n                            return x, y, z, orientation\n        return None, None, None, None",
          "objective": 31.7,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     },
     {
          "algorithm": "At each step, select the largest remaining item type based on volume, iterate through trucks and orientations, and place the item in the first valid location; if no location is found, open a new truck.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {At each step, select the largest remaining item type based on volume, iterate through trucks and orientations, and place the item in the first valid location; if no location is found, open a new truck.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, 0, 0, 0, 0\n\n        best_truck_index, best_x, best_y, best_z, best_orientation = self._find_best_placement(unplaced_items[item_index], trucks_in_use, truck_type)\n\n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._open_new_truck(unplaced_items[item_index], truck_type)\n\n        return best_truck_index, item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, item, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = 0\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if not self._check_separation_compatibility(item, truck):\n                continue\n\n            x, y, z, orientation = self._find_position_in_truck(item, truck, truck_type)\n            if x != -1:\n                return truck_index, x, y, z, orientation\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n\n    def _find_position_in_truck(self, item, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item)\n\n        for orientation_index, (orientation_id, (l, w, h)) in enumerate(orientations):\n            for x in np.arange(0, container_dims[0] - l + self.epsilon , 1):\n                for y in np.arange(0, container_dims[1] - w + self.epsilon, 1):\n                    z = 0\n                    \n\n                    position_valid = True\n                    while z <=  container_dims[2] - h + self.epsilon:\n\n                        item_pos = (x, y, z)\n                        item_dims = (l, w, h)\n\n                        if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                            return x, y, z, orientation_id\n\n                        z += 1\n\n        return -1, -1, -1, -1\n\n    def _open_new_truck(self, item, truck_type):\n        truck_index = -1\n        x, y, z = 0, 0, 0\n        orientations = self._get_orientations(item)\n        best_orientation = 0\n\n        for orientation_index, (orientation_id, (l, w, h)) in enumerate(orientations):\n            if l <= truck_type[0] and w <= truck_type[1] and h <= truck_type[2]:\n                x, y, z = 0, 0, 0\n                best_orientation = orientation_id\n                return truck_index, x, y, z, best_orientation\n\n        return truck_index, x, y, z, best_orientation\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_position_in_truck(self, item, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item)\n\n        for orientation_index, (orientation_id, (l, w, h)) in enumerate(orientations):\n            for x in np.arange(0, container_dims[0] - l + self.epsilon, min(1, container_dims[0] - l + self.epsilon) ):\n                for y in np.arange(0, container_dims[1] - w + self.epsilon, min(1, container_dims[1] - w + self.epsilon)):\n                    z = 0\n                    \n                    position_valid = True\n                    while z <=  container_dims[2] - h + self.epsilon:\n\n                        item_pos = (x, y, z)\n                        item_dims = (l, w, h)\n\n                        if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                            return x, y, z, orientation_id\n\n                        z += min(1, container_dims[2] - h + self.epsilon)\n\n        return -1, -1, -1, -1\nimport numpy as np\n\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_position_in_truck(self, item, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item)\n        step_size = 1\n\n        for orientation_index, (orientation_id, (l, w, h)) in enumerate(orientations):\n            max_x = container_dims[0] - l + self.epsilon\n            max_y = container_dims[1] - w + self.epsilon\n            max_z = container_dims[2] - h + self.epsilon\n            \n            for x in np.arange(0, max_x, step_size):\n                for y in np.arange(0, max_y, step_size):\n                  \n                    item_pos = (x, y, 0)\n                    item_dims = (l, w, h)\n\n                    if self._is_valid_placement(item_pos, item_dims, container_dims, occupied_volumes):\n                        return x, y, 0, orientation_id\n        return -1, -1, -1, -1",
          "objective": 38.6,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     },
     {
          "algorithm": "Iterate through unplaced items and trucks, select the first valid placement for an item in a truck or create a new truck if no placement is found.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Iterate through unplaced items and trucks, select the first valid placement for an item in a truck or create a new truck if no placement is found.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                for truck_index, truck in enumerate(trucks_in_use):\n                    if self._check_separation_compatibility(item_type, truck):\n                        x, y, z, orientation = self._find_valid_position_in_truck(item_type, truck, truck_type)\n                        if x is not None:\n                            return truck_index, item_index, x, y, z, orientation\n                x, y, z, orientation = self._find_valid_position_in_new_truck(item_type, truck_type)\n                if x is not None:\n                    return -1, item_index, x, y, z, orientation\n        return None, None, None, None, None, None\n\n    def _find_valid_position_in_truck(self, item_type, truck, truck_type):\n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item_type)):\n            for x in np.arange(0, truck_type[0], 1):\n                for y in np.arange(0, truck_type[1], 1):\n                    z = self._find_lowest_valid_z(x, y, item_dims, truck_type, truck['occupied_volumes'])\n                    if z is not None:\n                        if self._is_valid_placement((x, y, z), item_dims, truck_type, truck['occupied_volumes']):\n                            return x, y, z, orientation_id\n        return None, None, None, None\n\n    def _find_valid_position_in_new_truck(self, item_type, truck_type):\n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item_type)):\n            x,y,z = 0,0,0\n            if self._is_valid_placement((x, y, z), item_dims, truck_type, []):\n                return x, y, z, orientation_id\n        return None, None, None, None\n\n    def _find_lowest_valid_z(self, x, y, item_dims, container_dims, occupied_volumes):\n        z = 0\n        while z <= container_dims[2]:\n            valid = True\n            for placed_item in occupied_volumes:\n                placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                if self._check_overlap_3d((x, y, z), item_dims, placed_item_pos, placed_item_dims):\n                    valid = False\n                    z = placed_item_pos[2] + placed_item_dims[2]\n                    break\n            if valid:\n                return z\n        return None\nclass AlgorithmFIX1(Algorithm):\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                for truck_index, truck in enumerate(trucks_in_use):\n                    if self._check_separation_compatibility(item_type, truck):\n                        x, y, z, orientation = self._find_valid_position_in_truck(item_type, truck, truck_type)\n                        if x is not None:\n                            return truck_index, item_index, x, y, z, orientation\n                x, y, z, orientation = self._find_valid_position_in_new_truck(item_type, truck_type)\n                if x is not None:\n                    return -1, item_index, x, y, z, orientation\n        return None, None, None, None, None, None\n\n    def _find_valid_position_in_truck(self, item_type, truck, truck_type):\n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item_type)):\n            cl, cw, ch = truck_type\n            il, iw, ih = item_dims\n            for x in np.arange(0, cl - il + self.epsilon, 1):\n                for y in np.arange(0, cw - iw + self.epsilon, 1):\n                    z = self._find_lowest_valid_z(x, y, item_dims, truck_type, truck['occupied_volumes'])\n                    if z is not None:\n                        if self._is_valid_placement((x, y, z), item_dims, truck_type, truck['occupied_volumes']):\n                            return x, y, z, orientation_id\n        return None, None, None, None\n\n    def _find_valid_position_in_new_truck(self, item_type, truck_type):\n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item_type)):\n            x,y,z = 0,0,0\n            if self._is_valid_placement((x, y, z), item_dims, truck_type, []):\n                return x, y, z, orientation_id\n        return None, None, None, None\n\n    def _find_lowest_valid_z(self, x, y, item_dims, container_dims, occupied_volumes):\n        z = 0\n        while z <= container_dims[2] - self.epsilon:\n            valid = True\n            for placed_item in occupied_volumes:\n                placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                if self._check_overlap_3d((x, y, z), item_dims, placed_item_pos, placed_item_dims):\n                    valid = False\n                    z = placed_item_pos[2] + placed_item_dims[2]\n                    break\n            if valid:\n                return z\n            z += 1\n        return None\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_valid_position_in_truck(self, item_type, truck, truck_type):\n        for orientation_index, (orientation_id, item_dims) in enumerate(self._get_orientations(item_type)):\n            cl, cw, ch = truck_type\n            il, iw, ih = item_dims\n            \n            max_x = cl - il\n            max_y = cw - iw\n\n            for x in np.arange(0, max_x + self.epsilon, max(1, il/2)):\n                for y in np.arange(0, max_y + self.epsilon, max(1, iw/2)):\n                    x, y = round(x, 6), round(y, 6) # Avoid floating point errors\n                    z = self._find_lowest_valid_z(x, y, item_dims, truck_type, truck['occupied_volumes'])\n                    if z is not None:\n                        if self._is_valid_placement((x, y, z), item_dims, truck_type, truck['occupied_volumes']):\n                            return x, y, z, orientation_id\n        return None, None, None, None",
          "objective": 43.05,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     }
]