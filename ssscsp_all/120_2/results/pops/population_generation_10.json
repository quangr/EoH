[
     {
          "algorithm": "The algorithm prioritizes placing items that maximize the surface area they occupy on the container floor, selecting the placement that best covers the floor while maintaining stability.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {The algorithm prioritizes placing items that maximize the surface area they occupy on the container floor, selecting the placement that best covers the floor while maintaining stability.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items, trucks_in_use, truck_type)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items[item_index], trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n    \n    def _select_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_item_index = None\n        max_area_ratio = -1\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                area_ratio = self._evaluate_item_area_ratio(item, truck_type)\n                if area_ratio > max_area_ratio:\n                    max_area_ratio = area_ratio\n                    best_item_index = i\n        return best_item_index\n    \n    def _evaluate_item_area_ratio(self, item, truck_type):\n        truck_length, truck_width, truck_height = truck_type\n        truck_area = truck_length * truck_width\n        \n        max_item_area = 0\n        for _, (l, w, h) in self._get_orientations(item):\n            max_item_area = max(max_item_area, l*w, l*h, w*h)\n        \n        return max_item_area / truck_area\n    \n    def _find_best_placement(self, item, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        best_score = -1\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if self._check_separation_compatibility(item, truck):\n                x, y, z, orientation, score = self._find_best_position_in_truck(item, truck, truck_type)\n                if score > best_score:\n                    best_truck_index = truck_index\n                    best_x, best_y, best_z = x, y, z\n                    best_orientation = orientation\n                    best_score = score\n\n        if best_truck_index is None:\n            truck_index, x, y, z, orientation, score = self._create_new_truck_and_place(item, trucks_in_use, truck_type)\n            if score > best_score:\n                best_truck_index = truck_index\n                best_x, best_y, best_z = x, y, z\n                best_orientation = orientation\n                best_score = score\n            \n        return best_truck_index, best_x, best_y, best_z, best_orientation\n    \n    def _find_best_position_in_truck(self, item, truck, truck_type):\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        best_score = -1\n        \n        for orientation_index, (orientation_id, dims) in enumerate(self._get_orientations(item)):\n            length, width, height = dims\n            for z in sorted(list(set([0] + [v['z'] + v['height'] for v in truck['occupied_volumes']]))):\n                for y in sorted(list(set([0] + [v['y'] + v['width'] for v in truck['occupied_volumes']]))):\n                    for x in sorted(list(set([0] + [v['x'] + v['length'] for v in truck['occupied_volumes']]))):\n                        position = (x, y, z)\n                        if self._is_valid_placement(position, (length, width, height), truck_type, truck['occupied_volumes']):\n                            score = self._evaluate_placement(position, dims, truck_type, truck['occupied_volumes'])\n                            if score > best_score:\n                                best_x, best_y, best_z = x, y, z\n                                best_orientation = orientation_id\n                                best_score = score\n        return best_x, best_y, best_z, best_orientation, best_score\n    \n    def _evaluate_placement(self, position, dims, truck_type, occupied_volumes):\n        x, y, z = position\n        length, width, height = dims\n        truck_length, truck_width, truck_height = truck_type\n        truck_area = truck_length * truck_width\n        \n        item_area = length * width\n        area_utilization = item_area / truck_area\n        \n        stability_score = 0\n        if z > 0:\n            px, py, pz = position\n            pl, pw, _ = dims\n            total_support_area = 0.0\n            for placed_item in occupied_volumes:\n                placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n\n                if abs((placed_item_pos[2] + placed_item_dims[2]) - pz) < self.epsilon:\n                    overlap_x = max(0, min(px + pl, placed_item_pos[0] + placed_item_dims[0]) - max(px, placed_item_pos[0]))\n                    overlap_y = max(0, min(py + pw, placed_item_pos[1] + placed_item_dims[1]) - max(py, placed_item_pos[1]))\n                    total_support_area += overlap_x * overlap_y\n            stability_score = total_support_area / item_area if item_area > 0 else 0\n\n        return area_utilization + stability_score\n    \n    def _create_new_truck_and_place(self, item, trucks_in_use, truck_type):\n        truck_separation_set = item.get('separation_set')\n        truck = {'occupied_volumes': [], 'separation_set': truck_separation_set}\n        trucks_in_use.append(truck)\n        truck_index = len(trucks_in_use) - 1\n\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        best_score = -1\n\n        for orientation_index, (orientation_id, dims) in enumerate(self._get_orientations(item)):\n            length, width, height = dims\n            position = (0, 0, 0)\n            if self._is_valid_placement(position, (length, width, height), truck_type, truck['occupied_volumes']):\n                score = self._evaluate_placement(position, dims, truck_type, truck['occupied_volumes'])\n                if score > best_score:\n                    best_x, best_y, best_z = 0, 0, 0\n                    best_orientation = orientation_id\n                    best_score = score\n        \n        return -1, best_x, best_y, best_z, best_orientation, best_score",
          "objective": 22.7,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm prioritizes placing items based on a weighted score that emphasizes space utilization and minimizes z-coordinate, slightly de-emphasizing floor coverage.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes placing items based on a weighted score that emphasizes space utilization and minimizes z-coordinate, slightly de-emphasizing floor coverage.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_next_item(unplaced_items, trucks_in_use, truck_type)\n\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_best_truck_and_position(\n            unplaced_items[item_index], trucks_in_use, truck_type\n        )\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_next_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_item_index = None\n        max_volume = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_truck_and_position(self, item, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        best_score = -1\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if self._check_separation_compatibility(item, truck):\n                x, y, z, orientation, score = self._find_best_position_in_existing_truck(\n                    item, truck, truck_type\n                )\n                if score > best_score:\n                    best_truck_index = truck_index\n                    best_x, best_y, best_z = x, y, z\n                    best_orientation = orientation\n                    best_score = score\n\n        if best_truck_index is None:\n            truck_index, x, y, z, orientation, score = self._create_new_truck(item, trucks_in_use, truck_type)\n            if score > best_score:\n                best_truck_index = truck_index\n                best_x, best_y, best_z = x, y, z\n                best_orientation = orientation\n                best_score = score\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_existing_truck(self, item, truck, truck_type):\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        best_score = -1\n\n        for orientation_index, (orientation_id, dims) in enumerate(self._get_orientations(item)):\n            l, w, h = dims\n\n            for x in sorted(list(set([0] + [v['x'] + v['length'] for v in truck['occupied_volumes']]))):\n                for y in sorted(list(set([0] + [v['y'] + v['width'] for v in truck['occupied_volumes']]))):\n                    for z in sorted(list(set([0] + [v['z'] + v['height'] for v in truck['occupied_volumes']]))):\n                        position = (x, y, z)\n                        if self._is_valid_placement(position, (l, w, h), truck_type, truck['occupied_volumes']):\n                            score = self._evaluate_position(position, (l, w, h), truck_type, truck['occupied_volumes'])\n                            if score > best_score:\n                                best_x, best_y, best_z = x, y, z\n                                best_orientation = orientation_id\n                                best_score = score\n\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _create_new_truck(self, item, trucks_in_use, truck_type):\n        truck_separation_set = item.get('separation_set')\n        truck = {'occupied_volumes': [], 'separation_set': truck_separation_set}\n        trucks_in_use.append(truck)\n        truck_index = len(trucks_in_use) - 1\n\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        best_score = -1\n\n        for orientation_index, (orientation_id, dims) in enumerate(self._get_orientations(item)):\n            l, w, h = dims\n            position = (0, 0, 0)\n            if self._is_valid_placement(position, (l, w, h), truck_type, truck['occupied_volumes']):\n                score = self._evaluate_position(position, (l, w, h), truck_type, truck['occupied_volumes'])\n                if score > best_score:\n                    best_x, best_y, best_z = 0, 0, 0\n                    best_orientation = orientation_id\n                    best_score = score\n\n        return truck_index, best_x, best_y, best_z, best_orientation, best_score\n\n    def _evaluate_position(self, position, dims, truck_type, occupied_volumes):\n        x, y, z = position\n        l, w, h = dims\n        truck_length, truck_width, truck_height = truck_type\n\n        space_utilization = (l * w * h) / (truck_length * truck_width * truck_height)\n        floor_coverage = l * w\n\n        for placed_item in occupied_volumes:\n            if placed_item['z'] == 0:\n                floor_coverage -= max(0, min(x + l, placed_item['x'] + placed_item['length']) - max(x, placed_item['x'])) * \\\n                                 max(0, min(y + w, placed_item['y'] + placed_item['width']) - max(y, placed_item['y']))\n\n        normalized_z = z / truck_height\n        return 0.7 * space_utilization - 0.1 * normalized_z + 0.2 * (floor_coverage / (truck_length * truck_width))\nclass AlgorithmFIX1(Algorithm):\n    def _create_new_truck(self, item, trucks_in_use, truck_type):\n        truck_separation_set = item.get('separation_set')\n        truck = {'occupied_volumes': [], 'separation_set': truck_separation_set}\n        trucks_in_use.append(truck)\n        truck_index = len(trucks_in_use) - 1\n\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        best_score = -1\n\n        for orientation_index, (orientation_id, dims) in enumerate(self._get_orientations(item)):\n            l, w, h = dims\n            position = (0, 0, 0)\n            if self._is_valid_placement(position, (l, w, h), truck_type, truck['occupied_volumes']):\n                score = self._evaluate_position(position, (l, w, h), truck_type, truck['occupied_volumes'])\n                if score > best_score:\n                    best_x, best_y, best_z = 0, 0, 0\n                    best_orientation = orientation_id\n                    best_score = score\n\n        return truck_index, best_x, best_y, best_z, best_orientation, best_score\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _create_new_truck(self, item, trucks_in_use, truck_type):\n        truck_separation_set = item.get('separation_set')\n        truck = {'occupied_volumes': [], 'separation_set': truck_separation_set}\n        trucks_in_use.append(truck)\n        truck_index = len(trucks_in_use) - 1\n\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        best_score = -1\n\n        for orientation_index, (orientation_id, dims) in enumerate(self._get_orientations(item)):\n            l, w, h = dims\n            position = (0, 0, 0)\n            if self._is_valid_placement(position, (l, w, h), truck_type, truck['occupied_volumes']):\n                score = self._evaluate_position(position, (l, w, h), truck_type, truck['occupied_volumes'])\n                if score > best_score:\n                    best_x, best_y, best_z = 0, 0, 0\n                    best_orientation = orientation_id\n                    best_score = score\n\n        return -1, best_x, best_y, best_z, best_orientation, best_score",
          "objective": 22.8,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     },
     {
          "algorithm": "This algorithm prioritizes placing the largest remaining item, optimizing placement based on a heuristic combining space utilization and floor coverage.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes placing the largest remaining item, optimizing placement based on a heuristic combining space utilization and floor coverage.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_next_item(unplaced_items, trucks_in_use, truck_type)\n\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_best_truck_and_position(\n            unplaced_items[item_index], trucks_in_use, truck_type\n        )\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_next_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_item_index = None\n        max_volume = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_truck_and_position(self, item, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        best_score = -1\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if self._check_separation_compatibility(item, truck):\n                x, y, z, orientation, score = self._find_best_position_in_existing_truck(\n                    item, truck, truck_type\n                )\n                if score > best_score:\n                    best_truck_index = truck_index\n                    best_x, best_y, best_z = x, y, z\n                    best_orientation = orientation\n                    best_score = score\n\n        if best_truck_index is None:\n            truck_index, x, y, z, orientation, score = self._create_new_truck(item, trucks_in_use, truck_type)\n            if score > best_score:\n                best_truck_index = truck_index\n                best_x, best_y, best_z = x, y, z\n                best_orientation = orientation\n                best_score = score\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_existing_truck(self, item, truck, truck_type):\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        best_score = -1\n\n        for orientation_index, (orientation_id, dims) in enumerate(self._get_orientations(item)):\n            l, w, h = dims\n\n            for x in sorted(list(set([0] + [v['x'] + v['length'] for v in truck['occupied_volumes']]))):\n                for y in sorted(list(set([0] + [v['y'] + v['width'] for v in truck['occupied_volumes']]))):\n                    for z in sorted(list(set([0] + [v['z'] + v['height'] for v in truck['occupied_volumes']]))):\n                        position = (x, y, z)\n                        if self._is_valid_placement(position, (l, w, h), truck_type, truck['occupied_volumes']):\n                            score = self._evaluate_position(position, (l, w, h), truck_type, truck['occupied_volumes'])\n                            if score > best_score:\n                                best_x, best_y, best_z = x, y, z\n                                best_orientation = orientation_id\n                                best_score = score\n\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _create_new_truck(self, item, trucks_in_use, truck_type):\n        truck_separation_set = item.get('separation_set')\n        truck = {'occupied_volumes': [], 'separation_set': truck_separation_set}\n        trucks_in_use.append(truck)\n        truck_index = len(trucks_in_use) - 1\n\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        best_score = -1\n\n        for orientation_index, (orientation_id, dims) in enumerate(self._get_orientations(item)):\n            l, w, h = dims\n            position = (0, 0, 0)\n            if self._is_valid_placement(position, (l, w, h), truck_type, truck['occupied_volumes']):\n                score = self._evaluate_position(position, (l, w, h), truck_type, truck['occupied_volumes'])\n                if score > best_score:\n                    best_x, best_y, best_z = 0, 0, 0\n                    best_orientation = orientation_id\n                    best_score = score\n\n        return truck_index, best_x, best_y, best_z, best_orientation, best_score\n\n    def _evaluate_position(self, position, dims, truck_type, occupied_volumes):\n        x, y, z = position\n        l, w, h = dims\n        truck_length, truck_width, truck_height = truck_type\n\n        space_utilization = (l * w * h) / (truck_length * truck_width * truck_height)\n\n        floor_coverage = l * w\n        for placed_item in occupied_volumes:\n            if placed_item['z'] == 0:\n                floor_coverage -= max(0, min(x + l, placed_item['x'] + placed_item['length']) - max(x, placed_item['x'])) * \\\n                                 max(0, min(y + w, placed_item['y'] + placed_item['width']) - max(y, placed_item['y']))\n\n        return 0.6 * space_utilization + 0.4 * (floor_coverage / (truck_length * truck_width))\nclass AlgorithmFIX1(Algorithm):\n    def _create_new_truck(self, item, trucks_in_use, truck_type):\n        truck_separation_set = item.get('separation_set')\n        truck = {'occupied_volumes': [], 'separation_set': truck_separation_set}\n        trucks_in_use.append(truck)\n        truck_index = len(trucks_in_use) - 1\n\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        best_score = -1\n\n        for orientation_index, (orientation_id, dims) in enumerate(self._get_orientations(item)):\n            l, w, h = dims\n            position = (0, 0, 0)\n            if self._is_valid_placement(position, (l, w, h), truck_type, truck['occupied_volumes']):\n                score = self._evaluate_position(position, (l, w, h), truck_type, truck['occupied_volumes'])\n                if score > best_score:\n                    best_x, best_y, best_z = 0, 0, 0\n                    best_orientation = orientation_id\n                    best_score = score\n\n        return truck_index, best_x, best_y, best_z, best_orientation, best_score\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _create_new_truck(self, item, trucks_in_use, truck_type):\n        truck_separation_set = item.get('separation_set')\n        truck = {'occupied_volumes': [], 'separation_set': truck_separation_set}\n        trucks_in_use.append(truck)\n        truck_index = len(trucks_in_use) - 1\n\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        best_score = -1\n\n        for orientation_index, (orientation_id, dims) in enumerate(self._get_orientations(item)):\n            l, w, h = dims\n            position = (0, 0, 0)\n            if self._is_valid_placement(position, (l, w, h), truck_type, truck['occupied_volumes']):\n                score = self._evaluate_position(position, (l, w, h), truck_type, truck['occupied_volumes'])\n                if score > best_score:\n                    best_x, best_y, best_z = 0, 0, 0\n                    best_orientation = orientation_id\n                    best_score = score\n\n        return -1, best_x, best_y, best_z, best_orientation, best_score",
          "objective": 22.85,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     },
     {
          "algorithm": "This algorithm prioritizes placing the item that maximizes the floor coverage, favoring stable placements at lower z-levels with less emphasis on total space utilization.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes placing the item that maximizes the floor coverage, favoring stable placements at lower z-levels with less emphasis on total space utilization.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_next_item(unplaced_items, trucks_in_use, truck_type)\n\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_best_truck_and_position(\n            unplaced_items[item_index], trucks_in_use, truck_type\n        )\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_next_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_item_index = None\n        max_floor_area = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                floor_area = item['length'] * item['width']\n                if floor_area > max_floor_area:\n                    max_floor_area = floor_area\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_truck_and_position(self, item, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        best_score = -1\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if self._check_separation_compatibility(item, truck):\n                x, y, z, orientation, score = self._find_best_position_in_existing_truck(\n                    item, truck, truck_type\n                )\n                if score > best_score:\n                    best_truck_index = truck_index\n                    best_x, best_y, best_z = x, y, z\n                    best_orientation = orientation\n                    best_score = score\n\n        if best_truck_index is None:\n            truck_index, x, y, z, orientation, score = self._create_new_truck(item, trucks_in_use, truck_type)\n            if score > best_score:\n                best_truck_index = truck_index\n                best_x, best_y, best_z = x, y, z\n                best_orientation = orientation\n                best_score = score\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_existing_truck(self, item, truck, truck_type):\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        best_score = -1\n\n        for orientation_index, (orientation_id, dims) in enumerate(self._get_orientations(item)):\n            l, w, h = dims\n\n            for x in sorted(list(set([0] + [v['x'] + v['length'] for v in truck['occupied_volumes']]))):\n                for y in sorted(list(set([0] + [v['y'] + v['width'] for v in truck['occupied_volumes']]))):\n                    for z in sorted(list(set([0] + [v['z'] + v['height'] for v in truck['occupied_volumes']]))):\n                        position = (x, y, z)\n                        if self._is_valid_placement(position, (l, w, h), truck_type, truck['occupied_volumes']):\n                            score = self._evaluate_position(position, (l, w, h), truck_type, truck['occupied_volumes'])\n                            if score > best_score:\n                                best_x, best_y, best_z = x, y, z\n                                best_orientation = orientation_id\n                                best_score = score\n\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _create_new_truck(self, item, trucks_in_use, truck_type):\n        truck_separation_set = item.get('separation_set')\n        truck = {'occupied_volumes': [], 'separation_set': truck_separation_set}\n        trucks_in_use.append(truck)\n        truck_index = len(trucks_in_use) - 1\n\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        best_score = -1\n\n        for orientation_index, (orientation_id, dims) in enumerate(self._get_orientations(item)):\n            l, w, h = dims\n            position = (0, 0, 0)\n            if self._is_valid_placement(position, (l, w, h), truck_type, truck['occupied_volumes']):\n                score = self._evaluate_position(position, (l, w, h), truck_type, truck['occupied_volumes'])\n                if score > best_score:\n                    best_x, best_y, best_z = 0, 0, 0\n                    best_orientation = orientation_id\n                    best_score = score\n\n        return truck_index, best_x, best_y, best_z, best_orientation, best_score\n\n    def _evaluate_position(self, position, dims, truck_type, occupied_volumes):\n        x, y, z = position\n        l, w, h = dims\n        truck_length, truck_width, truck_height = truck_type\n\n        space_utilization = (l * w * h) / (truck_length * truck_width * truck_height)\n\n        floor_coverage = l * w\n\n        stability_factor = 1.0 / (z + 1e-6)\n\n        return 0.1 * space_utilization + 0.8 * (floor_coverage / (truck_length * truck_width)) + 0.1 * stability_factor\nclass AlgorithmFIX1(Algorithm):\n    def _create_new_truck(self, item, trucks_in_use, truck_type):\n        truck_separation_set = item.get('separation_set')\n        truck = {'occupied_volumes': [], 'separation_set': truck_separation_set}\n        trucks_in_use.append(truck)\n        truck_index = len(trucks_in_use) - 1\n\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        best_score = -1\n\n        for orientation_index, (orientation_id, dims) in enumerate(self._get_orientations(item)):\n            l, w, h = dims\n            position = (0, 0, 0)\n            if self._is_valid_placement(position, (l, w, h), truck_type, truck['occupied_volumes']):\n                score = self._evaluate_position(position, (l, w, h), truck_type, truck['occupied_volumes'])\n                if score > best_score:\n                    best_x, best_y, best_z = 0, 0, 0\n                    best_orientation = orientation_id\n                    best_score = score\n\n        return truck_index, best_x, best_y, best_z, best_orientation, best_score\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _create_new_truck(self, item, trucks_in_use, truck_type):\n        truck_separation_set = item.get('separation_set')\n        truck = {'occupied_volumes': [], 'separation_set': truck_separation_set}\n        trucks_in_use.append(truck)\n        truck_index = len(trucks_in_use) - 1\n\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        best_score = -1\n\n        for orientation_index, (orientation_id, dims) in enumerate(self._get_orientations(item)):\n            l, w, h = dims\n            position = (0, 0, 0)\n            if self._is_valid_placement(position, (l, w, h), truck_type, truck['occupied_volumes']):\n                score = self._evaluate_position(position, (l, w, h), truck_type, truck['occupied_volumes'])\n                if score > best_score:\n                    best_x, best_y, best_z = 0, 0, 0\n                    best_orientation = orientation_id\n                    best_score = score\n\n        return -1, best_x, best_y, best_z, best_orientation, best_score",
          "objective": 23.15,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     },
     {
          "algorithm": "This algorithm selects the item type with the least remaining quantity and places it in the best available position, prioritizing existing trucks and lowest z coordinate.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm selects the item type with the least remaining quantity and places it in the best available position, prioritizing existing trucks and lowest z coordinate.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item_least_quantity(unplaced_items)\n\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_best_placement(\n            unplaced_items[item_index], trucks_in_use, truck_type\n        )\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item_least_quantity(self, unplaced_items):\n        best_item_index = None\n        min_quantity = float('inf')\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                if item['quantity'] < min_quantity:\n                    min_quantity = item['quantity']\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, item, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        best_score = -1\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if self._check_separation_compatibility(item, truck):\n                x, y, z, orientation, score = self._find_best_position_in_truck(\n                    item, truck, truck_type\n                )\n                if score > best_score:\n                    best_truck_index = truck_index\n                    best_x, best_y, best_z = x, y, z\n                    best_orientation = orientation\n                    best_score = score\n\n        if best_truck_index is None:\n            truck_index, x, y, z, orientation, score = self._create_new_truck(item, trucks_in_use, truck_type)\n            if score > best_score:\n                best_truck_index = truck_index\n                best_x, best_y, best_z = x, y, z\n                best_orientation = orientation\n                best_score = score\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item, truck, truck_type):\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        best_score = -1\n\n        for orientation_index, (orientation_id, dims) in enumerate(self._get_orientations(item)):\n            l, w, h = dims\n            \n            potential_positions = []\n            for x in sorted(list(set([0] + [v['x'] + v['length'] for v in truck['occupied_volumes']]))):\n                for y in sorted(list(set([0] + [v['y'] + v['width'] for v in truck['occupied_volumes']]))):\n                    for z in sorted(list(set([0] + [v['z'] + v['height'] for v in truck['occupied_volumes']]))):\n                        potential_positions.append((x,y,z))\n                        \n            for x, y, z in potential_positions:\n                position = (x, y, z)\n                if self._is_valid_placement(position, (l, w, h), truck_type, truck['occupied_volumes']):\n                    score = self._evaluate_position(position, (l, w, h), truck_type, truck['occupied_volumes'])\n                    if score > best_score:\n                        best_x, best_y, best_z = x, y, z\n                        best_orientation = orientation_id\n                        best_score = score\n\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _create_new_truck(self, item, trucks_in_use, truck_type):\n        truck_separation_set = item.get('separation_set')\n        truck = {'occupied_volumes': [], 'separation_set': truck_separation_set}\n        trucks_in_use.append(truck)\n        truck_index = len(trucks_in_use) - 1\n\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        best_score = -1\n\n        for orientation_index, (orientation_id, dims) in enumerate(self._get_orientations(item)):\n            l, w, h = dims\n            position = (0, 0, 0)\n            if self._is_valid_placement(position, (l, w, h), truck_type, truck['occupied_volumes']):\n                score = self._evaluate_position(position, (l, w, h), truck_type, truck['occupied_volumes'])\n                if score > best_score:\n                    best_x, best_y, best_z = 0, 0, 0\n                    best_orientation = orientation_id\n                    best_score = score\n\n        return truck_index, best_x, best_y, best_z, best_orientation, best_score\n\n    def _evaluate_position(self, position, dims, truck_type, occupied_volumes):\n        x, y, z = position\n        l, w, h = dims\n        truck_length, truck_width, truck_height = truck_type\n\n        space_utilization = (l * w * h) / (truck_length * truck_width * truck_height)\n\n        floor_coverage = l * w\n        for placed_item in occupied_volumes:\n            if placed_item['z'] == 0:\n                floor_coverage -= max(0, min(x + l, placed_item['x'] + placed_item['length']) - max(x, placed_item['x'])) * \\\n                                 max(0, min(y + w, placed_item['y'] + placed_item['width']) - max(y, placed_item['y']))\n\n        return 0.6 * space_utilization + 0.4 * (floor_coverage / (truck_length * truck_width))\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _create_new_truck(self, item, trucks_in_use, truck_type):\n        truck_separation_set = item.get('separation_set')\n        truck = {'occupied_volumes': [], 'separation_set': truck_separation_set}\n        trucks_in_use.append(truck)\n        truck_index = len(trucks_in_use) - 1\n\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        best_score = -1\n\n        for orientation_index, (orientation_id, dims) in enumerate(self._get_orientations(item)):\n            l, w, h = dims\n            position = (0, 0, 0)\n            if self._is_valid_placement(position, (l, w, h), truck_type, truck['occupied_volumes']):\n                score = self._evaluate_position(position, (l, w, h), truck_type, truck['occupied_volumes'])\n                if score > best_score:\n                    best_x, best_y, best_z = 0, 0, 0\n                    best_orientation = orientation_id\n                    best_score = score\n\n        return truck_index, best_x, best_y, best_z, best_orientation, best_score\nimport numpy as np\n\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _create_new_truck(self, item, trucks_in_use, truck_type):\n        truck_separation_set = item.get('separation_set')\n        truck = {'occupied_volumes': [], 'separation_set': truck_separation_set}\n        trucks_in_use.append(truck)\n        truck_index = len(trucks_in_use) - 1\n\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        best_score = -1\n\n        for orientation_index, (orientation_id, dims) in enumerate(self._get_orientations(item)):\n            l, w, h = dims\n            position = (0, 0, 0)\n            if self._is_valid_placement(position, (l, w, h), truck_type, truck['occupied_volumes']):\n                score = self._evaluate_position(position, (l, w, h), truck_type, truck['occupied_volumes'])\n                if score > best_score:\n                    best_x, best_y, best_z = 0, 0, 0\n                    best_orientation = orientation_id\n                    best_score = score\n\n        return -1, best_x, best_y, best_z, best_orientation, best_score",
          "objective": 23.55,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     }
]