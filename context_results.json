[
    [
        "import numpy as np\n\ndef place_item(unplaced_items, trucks_in_use, truck_types):\n    \"\"\"\n    {This algorithm prioritizes filling existing trucks by first trying to place items into them based on a best-fit volume heuristic, considering support and weight constraints, and only opens a new truck if no existing truck can accommodate any remaining item.}\n    \"\"\"\n\n    truck_index = -1\n    item_index = -1\n    x = -1.0\n    y = -1.0\n    z = -1.0\n    truck_type_index = -1\n\n    # Helper Functions\n    def check_overlap(x, y, z, length, width, height, occupied_volumes):\n        for _, ox, oy, oz, olength, owidth, oheight in occupied_volumes:\n            if (x < ox + olength and\n                x + length > ox and\n                y < oy + owidth and\n                y + width > oy and\n                z < oz + oheight and\n                z + height > oz):\n                return True\n        return False\n\n    def calculate_support(x, y, z, length, width, height, occupied_volumes, truck_height):\n        supported_area = 0.0\n        total_area = length * width\n\n        # Check support from the truck floor\n        if z == 0:\n            supported_area = total_area\n            return supported_area / total_area >= 0.8\n\n        # Check support from other items\n        for _, ox, oy, oz, olength, owidth, oheight in occupied_volumes:\n            if z == oz + oheight:  # Directly above another item\n                x_overlap = max(0, min(x + length, ox + olength) - max(x, ox))\n                y_overlap = max(0, min(y + width, oy + owidth) - max(y, oy))\n                supported_area += x_overlap * y_overlap\n\n        return supported_area / total_area >= 0.8\n\n    def find_best_fit(truck_index, item, truck, truck_dims):\n        best_x, best_y, best_z = -1.0, -1.0, -1.0\n        min_waste = float('inf')\n\n        length, width, height = item['length'], item['width'], item['height']\n        truck_length, truck_width, truck_height = truck_dims\n\n        for z_ in sorted(list(set([0] + [oz + oh for _, _, _, oz, _, _, oh in truck['occupied_volumes']]))):\n          for x_ in sorted(list(set([0] + [ox + ol for _, ox, _, _, ol, _, _ in truck['occupied_volumes']]))):\n            for y_ in sorted(list(set([0] + [oy + ow for _, _, oy, _, _, ow, _ in truck['occupied_volumes']]))):\n            # Check if item fits in the truck\n              if x_ + length <= truck_length and y_ + width <= truck_width and z_ + height <= truck_height:\n                # Check for overlaps\n                if not check_overlap(x_, y_, z_, length, width, height, truck['occupied_volumes']):\n                    # Check for support\n                    if calculate_support(x_, y_, z_, length, width, height, truck['occupied_volumes'], truck_height):\n\n                        # Calculate remaining volume in truck after placing the item there\n                        waste = truck_length * truck_width * truck_height\n                        for _, ox, oy, oz, olength, owidth, oheight in truck['occupied_volumes']:\n                            waste -= olength * owidth * oheight\n                        waste -= length * width * height\n\n                        # Find best placement based on lowest waste.\n                        if waste < min_waste:\n                            min_waste = waste\n                            best_x, best_y, best_z = x_, y_, z_\n\n        return best_x, best_y, best_z\n\n\n    # Try to fit into existing trucks\n    for i, truck in enumerate(trucks_in_use):\n        truck_type_index = truck['truck_type_index']\n        capacity, truck_length, truck_width, truck_height = truck_types[truck_type_index]\n\n        for j, item in enumerate(unplaced_items):\n            if truck['current_weight'] + item['weight'] <= capacity:\n                \n                x_, y_, z_ = find_best_fit(i, item, truck, (truck_length, truck_width, truck_height))\n\n                if x_ != -1:\n                    truck_index = i\n                    item_index = j\n                    x = x_\n                    y = y_\n                    z = z_\n                    return truck_index, item_index, x, y, z, truck_type_index\n\n    # If no existing truck can fit any item, open a new truck\n    truck_type_index = 0\n    for i, item in enumerate(unplaced_items):\n        capacity, truck_length, truck_width, truck_height = truck_types[truck_type_index]\n        if item['weight'] <= capacity:\n            truck_index = -1\n            item_index = i\n            x = 0.0\n            y = 0.0\n            z = 0.0\n            return truck_index, item_index, x, y, z, truck_type_index\n\n    # If no item can be placed in any truck, return -1 for all indices to indicate failure.\n    return truck_index, item_index, x, y, z, truck_type_index"
    ],
    [
        "import numpy as np\n\ndef place_item(unplaced_items, trucks_in_use, truck_types):\n    \"\"\"\n    Places items into trucks, minimizing the number of trucks used.\n\n    This algorithm prioritizes filling existing trucks using a heuristic\n    based on remaining volume and weight capacity. If no suitable truck is found,\n    a new truck is selected.\n    \"\"\"\n\n    truck_index = -1\n    item_index = -1\n    x = -1.0\n    y = -1.0\n    z = -1.0\n    truck_type_index = -1\n\n    # Helper function to check for overlaps\n    def check_overlap(x, y, z, length, width, height, occupied_volumes):\n        for _, ox, oy, oz, ol, ow, oh in occupied_volumes:\n            if (x < ox + ol and\n                x + length > ox and\n                y < oy + ow and\n                y + width > oy and\n                z < oz + oh and\n                z + height > oz):\n                return True\n        return False\n\n    # Helper function to check for support\n    def check_support(x, y, z, length, width, height, occupied_volumes, truck_height):\n        if z == 0:\n            return True\n\n        supported_area = 0.0\n        total_area = length * width\n\n        for _, ox, oy, oz, ol, ow, oh in occupied_volumes:\n            if z == oz + oh:\n                x_overlap = max(0, min(x + length, ox + ol) - max(x, ox))\n                y_overlap = max(0, min(y + width, oy + ow) - max(y, oy))\n                supported_area += x_overlap * y_overlap\n\n        return supported_area / total_area >= 0.8\n\n    # Iterate through unplaced items\n    for i, item in enumerate(unplaced_items):\n        item_length = item['length']\n        item_width = item['width']\n        item_height = item['height']\n        item_weight = item['weight']\n\n        # Try to fit the item into existing trucks\n        for j, truck in enumerate(trucks_in_use):\n            truck_type_index_local = truck['truck_type_index']\n            truck_capacity, truck_length, truck_width, truck_height = truck_types[truck_type_index_local]\n            occupied_volumes = truck['occupied_volumes']\n            current_weight = truck['current_weight']\n\n            if current_weight + item_weight <= truck_capacity:\n                # Try different positions within the truck\n                for xi in range(0, int(truck_length - item_length + 1), int(min(item_length, truck_length/10.0))):\n                    for yi in range(0, int(truck_width - item_width + 1), int(min(item_width, truck_width/10.0))):\n                        #Find the lowest possible z, with support or z=0\n                        zi = 0.0\n                        max_z_found = False\n\n                        while not max_z_found:\n                            overlap = check_overlap(xi, yi, zi, item_length, item_width, item_height, occupied_volumes)\n                            if not overlap:\n                                support = check_support(xi, yi, zi, item_length, item_width, item_height, occupied_volumes, truck_height)\n\n                                if support and (zi + item_height <= truck_height):\n\n                                    truck_index = j\n                                    item_index = i\n                                    x = float(xi)\n                                    y = float(yi)\n                                    z = float(zi)\n                                    \n                                    return truck_index, item_index, x, y, z, truck_type_index\n\n                                else:\n                                    #Move up one increment in z\n                                    found_valid_z = False\n                                    for _, _, _, oz, _, _, oh in occupied_volumes:\n                                        if(xi >= 0 and xi < truck_length and yi >= 0 and yi < truck_width):\n                                            if(oz+oh > zi and oz+oh <= truck_height ):\n                                                zi = oz+oh\n                                                found_valid_z = True\n                                                break;\n                                    if not found_valid_z:\n                                        max_z_found = True\n                                        break\n                            else:\n                                max_z_found = True\n                                break\n            # If item fits in existing truck, return the placement\n            # No suitable position found in existing trucks, proceed to find a new truck\n\n        #If a suitable position hasn't been found, then select the first truck type.\n        truck_type_index = 0\n        truck_capacity, truck_length, truck_width, truck_height = truck_types[truck_type_index]\n\n        # Check if the item's weight exceeds the truck capacity.\n        if item_weight > truck_capacity:\n          continue;\n\n        # Place it at the origin (0, 0, 0) of the new truck\n        truck_index = -1\n        item_index = i\n        x = 0.0\n        y = 0.0\n        z = 0.0\n\n        return truck_index, item_index, x, y, z, truck_type_index\n\n    # If no placement is found after iterating through all items and trucks\n    return truck_index, item_index, x, y, z, truck_type_index"
    ],
    [
        "import numpy as np\n\ndef place_item(unplaced_items, trucks_in_use, truck_types):\n    \"\"\"\n    Places items into trucks, minimizing the number of trucks used, while satisfying constraints.\n    \"\"\"\n    # {This algorithm prioritizes filling existing trucks before opening new ones, selecting items based on a volumetric heuristic and placement locations based on space availability and support, optimized for speed using numpy for collision checks and support calculations.}\n\n    truck_index = -1\n    item_index = -1\n    x = -1.0\n    y = -1.0\n    z = -1.0\n    truck_type_index = -1\n\n    # Try to place in existing trucks first\n    for ti, truck in enumerate(trucks_in_use):\n        truck_type_index_local = truck['truck_type_index']\n        capacity, length, width, height = truck_types[truck_type_index_local]\n        current_weight = truck['current_weight']\n        occupied_volumes = truck['occupied_volumes']\n\n        for ii, item in enumerate(unplaced_items):\n            item_length = item['length']\n            item_width = item['width']\n            item_height = item['height']\n            item_weight = item['weight']\n\n            if current_weight + item_weight <= capacity:\n                # Find a suitable position in the truck\n                best_x, best_y, best_z = -1, -1, -1\n\n                # Iterate through possible positions (simplified for speed)\n                x_step = max(1, int(item_length / 4)) # Reduce iterations\n                y_step = max(1, int(item_width / 4))  # Reduce iterations\n                z_step = max(1, int(item_height / 4))  # Reduce iterations\n\n                for ix in range(0, int(length - item_length) + 1, x_step):\n                    for iy in range(0, int(width - item_width) + 1, y_step):\n                        iz = 0 # Always start from bottom and stack\n\n                        # Check for collisions\n                        collision = False\n                        for placed_item in occupied_volumes:\n                            x0, y0, z0, l0, w0, h0 = placed_item[1], placed_item[2], placed_item[3], placed_item[4], placed_item[5], placed_item[6]\n                            if (ix < x0 + l0 and ix + item_length > x0 and\n                                iy < y0 + w0 and iy + item_width > y0 and\n                                iz < z0 + h0 and iz + item_height > z0):\n                                collision = True\n                                break\n                        if collision:\n                            continue\n\n                        # Check for support\n                        supported = False\n                        if iz == 0:\n                            supported = True\n                        else:\n                            supported_area = 0.0\n                            item_bottom_area = item_length * item_width\n                            for placed_item in occupied_volumes:\n                                x0, y0, z0, l0, w0, h0 = placed_item[1], placed_item[2], placed_item[3], placed_item[4], placed_item[5], placed_item[6]\n\n                                if iz == z0 + h0:\n                                    x_overlap = max(0, min(ix + item_length, x0 + l0) - max(ix, x0))\n                                    y_overlap = max(0, min(iy + item_width, y0 + w0) - max(iy, y0))\n                                    supported_area += x_overlap * y_overlap\n\n                            if supported_area / item_bottom_area >= 0.8:\n                                supported = True\n                                \n                        if supported:\n                            best_x, best_y, best_z = ix, iy, iz\n                            break # Found a spot in this truck\n\n                    if best_x != -1:\n                        break\n\n                if best_x != -1:\n                    truck_index = ti\n                    item_index = ii\n                    x = float(best_x)\n                    y = float(best_y)\n                    z = float(best_z)\n                    return truck_index, item_index, x, y, z, truck_type_index\n\n    # If no suitable truck found, open a new truck\n    for tti, truck_type in enumerate(truck_types):\n        capacity, length, width, height = truck_type\n\n        for ii, item in enumerate(unplaced_items):\n            item_length = item['length']\n            item_width = item['width']\n            item_height = item['height']\n            item_weight = item['weight']\n\n            if item_weight <= capacity and item_length <= length and item_width <= width and item_height <= height:\n                # Place item at the bottom-left-front corner\n                truck_index = -1  # New truck\n                item_index = ii\n                x = 0.0\n                y = 0.0\n                z = 0.0\n                truck_type_index = tti\n                return truck_index, item_index, x, y, z, truck_type_index\n\n    # If no placement found at all, return -1 for item_index (should not happen if problem is feasible)\n    return truck_index, item_index, x, y, z, truck_type_index"
    ],
    [
        "import numpy as np\n\ndef place_item(unplaced_items, trucks_in_use, truck_types):\n    \"\"\"\n    Places items into trucks, minimizing the number of trucks used, while satisfying constraints.\n    {The algorithm prioritizes filling existing trucks by selecting the item that best fits into available spaces, considering remaining weight capacity and support, and if no suitable space is found, it opens a new truck of a type that can accommodate the largest remaining item.}\n    \"\"\"\n    truck_index = -1\n    item_index = -1\n    x = 0.0\n    y = 0.0\n    z = 0.0\n    truck_type_index = -1\n\n    # 1. Try to fit into existing trucks\n    for i, truck in enumerate(trucks_in_use):\n        truck_type = truck_types[truck['truck_type_index']]\n        available_items = []\n        for j, item in enumerate(unplaced_items):\n            if truck['current_weight'] + item['weight'] <= truck_type[0]:\n                available_items.append((j, item))\n\n        if not available_items:\n            continue\n\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_fit_score = float('inf')  # Lower score means better fit\n\n        for j, item in available_items:\n            \n            #Try possible placements\n            potential_placements = find_potential_placements(truck, truck_type, item)\n\n            for px, py, pz in potential_placements:\n                if can_place_item(truck, item, px, py, pz, truck_type,truck_types):\n                    \n                    #Check support\n                    if check_support(truck, item, px, py, pz, truck_type):\n                        fit_score = item['length'] * item['width'] * item['height']\n                        if fit_score < best_fit_score:\n                            best_fit_score = fit_score\n                            best_item_index = j\n                            best_x = px\n                            best_y = py\n                            best_z = pz\n\n        if best_item_index != -1:\n            truck_index = i\n            item_index = best_item_index\n            x = best_x\n            y = best_y\n            z = best_z\n            return truck_index, item_index, x, y, z, truck_type_index\n\n    # 2. If no existing truck can fit, create a new truck\n    # Find the largest unplaced item to determine truck type.\n    largest_item_index = -1\n    largest_item_volume = 0\n    for i, item in enumerate(unplaced_items):\n        volume = item['length'] * item['width'] * item['height']\n        if volume > largest_item_volume:\n            largest_item_volume = volume\n            largest_item_index = i\n\n    if largest_item_index != -1:\n        best_truck_type_index = -1\n        for i, truck_type in enumerate(truck_types):\n             #Check if can fit largest item\n            if (truck_type[1] >= unplaced_items[largest_item_index]['length'] and\n                truck_type[2] >= unplaced_items[largest_item_index]['width'] and\n                truck_type[3] >= unplaced_items[largest_item_index]['height']):\n                best_truck_type_index = i\n                break\n        \n        if best_truck_type_index != -1:\n            truck_index = -1\n            item_index = largest_item_index\n            x = 0.0\n            y = 0.0\n            z = 0.0\n            truck_type_index = best_truck_type_index\n            return truck_index, item_index, x, y, z, truck_type_index\n\n    # 3. If all items are placed\n    return truck_index, item_index, x, y, z, truck_type_index\n\n\ndef find_potential_placements(truck, truck_type, item):\n    \"\"\"\n    Finds potential placement locations within the truck, considering existing items.\n    \"\"\"\n    occupied_volumes = truck['occupied_volumes']\n    truck_length, truck_width, truck_height = truck_type[1], truck_type[2], truck_type[3]\n    item_length, item_width, item_height = item['length'], item['width'], item['height']\n    placements = []\n\n    # 1. Placement on the floor\n    placements.extend([(0.0, 0.0, 0.0)])  # Bottom-left-front corner\n\n    # 2. Placement next to existing items\n    for placed_item in occupied_volumes:\n        x, y, z, length, width, height = placed_item[1], placed_item[2], placed_item[3], placed_item[4], placed_item[5], placed_item[6]\n        \n        # Potential placement on top\n        placements.append((x, y, z + height))\n\n        #Potential placement along length\n        placements.append((x+length, y, z))\n        \n        #Potential placement along width\n        placements.append((x, y+width, z))\n        \n    #Remove duplicate placements\n    unique_placements = []\n    for x, y, z in placements:\n        if (x, y, z) not in unique_placements:\n            unique_placements.append((x, y, z))\n\n    return unique_placements\n\ndef can_place_item(truck, item, x, y, z, truck_type, truck_types):\n    \"\"\"\n    Checks if an item can be placed at a given location in the truck without overlapping or exceeding dimensions.\n    \"\"\"\n    truck_length, truck_width, truck_height = truck_type[1], truck_type[2], truck_type[3]\n    item_length, item_width, item_height = item['length'], item['width'], item['height']\n    occupied_volumes = truck['occupied_volumes']\n\n    # Check truck boundaries\n    if (x + item_length > truck_length or\n        y + item_width > truck_width or\n        z + item_height > truck_height):\n        return False\n\n    # Check for overlaps with existing items\n    for placed_item in occupied_volumes:\n        px, py, pz, plength, pwidth, pheight = placed_item[1], placed_item[2], placed_item[3], placed_item[4], placed_item[5], placed_item[6]\n        if (x < px + plength and\n            x + item_length > px and\n            y < py + pwidth and\n            y + item_width > py and\n            z < pz + pheight and\n            z + item_height > pz):\n            return False\n\n    return True\n\ndef check_support(truck, item, x, y, z, truck_type):\n    \"\"\"\n    Checks if the item has sufficient support from the floor or other items.\n    \"\"\"\n    item_length, item_width, item_height = item['length'], item['width'], item['height']\n    occupied_volumes = truck['occupied_volumes']\n    truck_length, truck_width, truck_height = truck_type[1], truck_type[2], truck_type[3]\n    \n    supported_area = 0.0\n    total_area = item_length * item_width\n    \n    #Check support from the floor\n    if z == 0:\n        supported_area = total_area\n    else:\n        #Check support from other items\n        for placed_item in occupied_volumes:\n            px, py, pz, plength, pwidth, pheight = placed_item[1], placed_item[2], placed_item[3], placed_item[4], placed_item[5], placed_item[6]\n            \n            #If the item is directly underneath the placed item\n            if pz + pheight == z:\n                #Calculate overlapping area\n                x_overlap = max(0, min(x + item_length, px + plength) - max(x, px))\n                y_overlap = max(0, min(y + item_width, py + pwidth) - max(y, py))\n                \n                supported_area += x_overlap * y_overlap\n    \n    return truck_index, item_index, x, y, z, truck_type_index"
    ],
    [
        "import numpy as np\n\ndef place_item(unplaced_items, trucks_in_use, truck_types):\n    \"\"\"\n    Places items into trucks, minimizing the number of trucks used while satisfying constraints.\n    \n    The algorithm first prioritizes filling existing trucks by iterating through unplaced items and trucks to find the best fit based on volume utilization and weight constraints.\n    If no existing truck can accommodate the item, it selects a new truck type and places the item in the new truck.\n    \"\"\"\n    truck_index = -1\n    item_index = -1\n    x = -1.0\n    y = -1.0\n    z = -1.0\n    truck_type_index = -1\n    \n    # First, try to place the item in an existing truck\n    for i_idx, item in enumerate(unplaced_items):\n        item_length = item['length']\n        item_width = item['width']\n        item_height = item['height']\n        item_weight = item['weight']\n\n        best_truck_index = -1\n        best_x = -1.0\n        best_y = -1.0\n        best_z = -1.0\n        \n        for t_idx, truck in enumerate(trucks_in_use):\n            truck_type_index_local = truck['truck_type_index']\n            truck_capacity = truck_types[truck_type_index_local][0]\n            truck_length = truck_types[truck_type_index_local][1]\n            truck_width = truck_types[truck_type_index_local][2]\n            truck_height = truck_types[truck_type_index_local][3]\n            truck_current_weight = truck['current_weight']\n            occupied_volumes = truck['occupied_volumes']\n\n            if truck_current_weight + item_weight <= truck_capacity:\n                # Find a suitable position within the truck\n                \n                # Simplistic approach: Iterate through possible positions\n                for x_pos in np.arange(0, truck_length - item_length + 1, min(item_length/2, 200)):\n                  for y_pos in np.arange(0, truck_width - item_width + 1, min(item_width/2, 200)):\n                    for z_pos in np.arange(0, truck_height - item_height + 1, min(item_height/2, 200)):\n                      \n                      x_pos = round(x_pos, 2)\n                      y_pos = round(y_pos, 2)\n                      z_pos = round(z_pos, 2)\n                      \n                      # Check for overlap\n                      overlap = False\n                      for placed_item in occupied_volumes:\n                          placed_x = placed_item[1]\n                          placed_y = placed_item[2]\n                          placed_z = placed_item[3]\n                          placed_length = placed_item[4]\n                          placed_width = placed_item[5]\n                          placed_height = placed_item[6]\n\n                          if (x_pos < placed_x + placed_length and\n                              x_pos + item_length > placed_x and\n                              y_pos < placed_y + placed_width and\n                              y_pos + item_width > placed_y and\n                              z_pos < placed_z + placed_height and\n                              z_pos + item_height > placed_z):\n                              overlap = True\n                              break\n\n                      if not overlap:\n                          # Check for support\n                          supported = False\n                          if z_pos == 0:\n                              supported = True\n                          else:\n                              supported_area = 0.0\n                              item_bottom_area = item_length * item_width\n\n                              for placed_item in occupied_volumes:\n                                  placed_x = placed_item[1]\n                                  placed_y = placed_item[2]\n                                  placed_z = placed_item[3]\n                                  placed_length = placed_item[4]\n                                  placed_width = placed_item[5]\n                                  placed_height = placed_item[6]\n\n                                  if z_pos == placed_z + placed_height: #Item is above placed item\n                                      x_overlap = max(0, min(x_pos + item_length, placed_x + placed_length) - max(x_pos, placed_x))\n                                      y_overlap = max(0, min(y_pos + item_width, placed_y + placed_width) - max(y_pos, placed_y))\n                                      supported_area += x_overlap * y_overlap\n                              if supported_area / item_bottom_area >= 0.8:\n                                supported = True\n                          \n                          if supported:\n                            best_truck_index = t_idx\n                            best_x = x_pos\n                            best_y = y_pos\n                            best_z = z_pos\n                            break # Found a valid placement in this truck\n                    if best_truck_index != -1:\n                      break\n                  if best_truck_index != -1:\n                    break\n        if best_truck_index != -1:\n            truck_index = best_truck_index\n            item_index = i_idx\n            x = best_x\n            y = best_y\n            z = best_z\n            \n            return truck_index, item_index, x, y, z, truck_type_index #Successfully placed in an existing truck\n    \n    # If no suitable truck was found, create a new truck\n    if truck_index == -1:\n        for tt_idx, truck_type in enumerate(truck_types):\n            truck_capacity = truck_type[0]\n            truck_length = truck_type[1]\n            truck_width = truck_type[2]\n            truck_height = truck_type[3]\n\n            #Check the unplaced items weight\n            for i_idx, item in enumerate(unplaced_items):\n                item_length = item['length']\n                item_width = item['width']\n                item_height = item['height']\n                item_weight = item['weight']\n                if item_weight <= truck_capacity and item_length <= truck_length and item_width <= truck_width and item_height <= truck_height:\n                    truck_type_index = tt_idx\n                    item_index = i_idx\n                    x = 0.0\n                    y = 0.0\n                    z = 0.0\n                    \n                    return truck_index, item_index, x, y, z, truck_type_index\n    return truck_index, item_index, x, y, z, truck_type_index"
    ],
    [
        "import numpy as np\n\ndef place_item(unplaced_items, trucks_in_use, truck_types):\n    \"\"\"\n    This function implements a placement strategy that prioritizes filling existing trucks\n    using a heuristic approach to find suitable item, truck, and placement combinations.\n    \"\"\"\n    truck_index = -1\n    item_index = -1\n    x = -1.0\n    y = -1.0\n    z = -1.0\n    truck_type_index = -1\n\n    # 1. Iterate through unplaced items and existing trucks to find a suitable placement.\n    for i_idx, item in enumerate(unplaced_items):\n        item_length = item['length']\n        item_width = item['width']\n        item_height = item['height']\n        item_weight = item['weight']\n\n        for t_idx, truck in enumerate(trucks_in_use):\n            truck_type_index = truck['truck_type_index']\n            truck_capacity = truck_types[truck_type_index][0]\n            truck_length = truck_types[truck_type_index][1]\n            truck_width = truck_types[truck_type_index][2]\n            truck_height = truck_types[truck_type_index][3]\n            truck_current_weight = truck['current_weight']\n            \n            if truck_current_weight + item_weight > truck_capacity:\n                continue\n            \n            occupied_volumes = truck['occupied_volumes']\n            \n            # Try to find a valid placement within the truck\n            \n            # Brute force search for a suitable position\n            \n            x_step = min(item_length/2, 200)\n            y_step = min(item_width/2, 200)\n            z_step = min(item_height/2, 200)\n            \n            for ix in np.arange(0, truck_length - item_length + x_step, x_step):\n                for iy in np.arange(0, truck_width - item_width + y_step, y_step):\n                    iz_options = [0.0]\n                    \n                    # Check existing placed items for possible support positions\n                    for placed_item in occupied_volumes:\n                        if (placed_item[1] <= ix and ix + item_length <= placed_item[1] + placed_item[4]\n                            and placed_item[2] <= iy and iy + item_width <= placed_item[2] + placed_item[5]):\n                            iz_options.append(placed_item[3] + placed_item[6])\n                    \n                    for iz in sorted(iz_options):\n                        \n                        x = float(ix)\n                        y = float(iy)\n                        z = float(iz)\n                        \n                        # Basic truck boundary check\n                        if (x < 0 or x + item_length > truck_length or\n                            y < 0 or y + item_width > truck_width or\n                            z < 0 or z + item_height > truck_height):\n                            continue\n                            \n                        # Check for overlap with existing items\n                        overlap = False\n                        for placed_item in occupied_volumes:\n                            if (x < placed_item[1] + placed_item[4] and x + item_length > placed_item[1] and\n                                y < placed_item[2] + placed_item[5] and y + item_width > placed_item[2] and\n                                z < placed_item[3] + placed_item[6] and z + item_height > placed_item[3]):\n                                overlap = True\n                                break\n                        if overlap:\n                            continue\n                            \n                        # Check for support\n                        support = False\n                        if z == 0:\n                            support = True\n                        else:\n                            supported_area = 0\n                            for placed_item in occupied_volumes:\n                                if (x < placed_item[1] + placed_item[4] and x + item_length > placed_item[1] and\n                                    y < placed_item[2] + placed_item[5] and y + item_width > placed_item[2] and\n                                    z == placed_item[3] + placed_item[6]):\n                                    x_overlap = max(0, min(x + item_length, placed_item[1] + placed_item[4]) - max(x, placed_item[1]))\n                                    y_overlap = max(0, min(y + item_width, placed_item[2] + placed_item[5]) - max(y, placed_item[2]))\n                                    supported_area += x_overlap * y_overlap\n\n                            if supported_area >= 0.8 * item_length * item_width:\n                                support = True\n\n                        if not support:\n                            continue\n                            \n                        # Placement found, assign variables and break out\n                        truck_index = t_idx\n                        item_index = i_idx\n                        \n                        return truck_index, item_index, x, y, z, truck_type_index\n\n    # 2. If no placement found in existing trucks, use a new truck.\n    truck_type_index = 0  # Default truck type\n    for tt_idx, truck_type in enumerate(truck_types):\n        \n        # Find the first truck type that can hold the item\n        if truck_type[0] >= item['weight'] and truck_type[1] >= item['length'] and truck_type[2] >= item['width'] and truck_type[3] >= item['height']:\n            truck_type_index = tt_idx\n            break\n\n    # If item can fit in a truck, place it\n    if (truck_types[truck_type_index][0] >= item['weight'] and truck_types[truck_type_index][1] >= item['length'] and\n        truck_types[truck_type_index][2] >= item['width'] and truck_types[truck_type_index][3] >= item['height']):\n        truck_index = -1  # Use a new truck\n        item_index = i_idx\n        x = 0.0\n        y = 0.0\n        z = 0.0\n\n        return truck_index, item_index, x, y, z, truck_type_index\n\n    # 3. If no placement found in new truck, return default values (should not happen with a valid problem definition)\n    truck_index = 0 if trucks_in_use else -1\n    item_index = 0 if unplaced_items else -1\n    x = 0.0\n    y = 0.0\n    z = 0.0\n    truck_type_index = 0\n\n    return truck_index, item_index, x, y, z, truck_type_index"
    ],
    [
        "import numpy as np\n\ndef place_item(unplaced_items, trucks_in_use, truck_types):\n    \"\"\"\n    Places items into trucks, minimizing the number of trucks used while satisfying constraints.\n    {The algorithm prioritizes filling existing trucks by iterating through unplaced items and trucks, finding the best fit based on volume utilization and weight capacity, and if no suitable truck is found, it opens a new truck with the smallest possible capacity that can fit the item.}\n    \"\"\"\n    truck_index = -1\n    item_index = -1\n    x = -1.0\n    y = -1.0\n    z = -1.0\n    truck_type_index = -1\n\n    # Iterate through unplaced items\n    for i, item in enumerate(unplaced_items):\n        item_length = item['length']\n        item_width = item['width']\n        item_height = item['height']\n        item_weight = item['weight']\n\n        best_truck_index = -1\n        best_x = -1.0\n        best_y = -1.0\n        best_z = -1.0\n        max_volume_utilization = -1.0\n\n        # Iterate through existing trucks\n        for j, truck in enumerate(trucks_in_use):\n            truck_type_index_local = truck['truck_type_index']\n            truck_capacity = truck_types[truck_type_index_local][0]\n            truck_length = truck_types[truck_type_index_local][1]\n            truck_width = truck_types[truck_type_index_local][2]\n            truck_height = truck_types[truck_type_index_local][3]\n            current_weight = truck['current_weight']\n            occupied_volumes = truck['occupied_volumes']\n            \n            if current_weight + item_weight <= truck_capacity:\n                # Find a suitable position in the truck\n                best_x_local, best_y_local, best_z_local, volume_utilization = find_position_in_truck(\n                    item_length, item_width, item_height,\n                    truck_length, truck_width, truck_height,\n                    occupied_volumes\n                )\n\n                if best_x_local != -1:\n                    if volume_utilization > max_volume_utilization:\n                        max_volume_utilization = volume_utilization\n                        best_truck_index = j\n                        best_x = best_x_local\n                        best_y = best_y_local\n                        best_z = best_z_local\n\n        # If a suitable truck is found, place the item in it\n        if best_truck_index != -1:\n            truck_index = best_truck_index\n            item_index = i\n            x = best_x\n            y = best_y\n            z = best_z\n            return truck_index, item_index, x, y, z, truck_type_index\n\n    # If no suitable truck is found, open a new truck\n    best_truck_type_index = -1\n    for k, truck_type in enumerate(truck_types):\n        capacity = truck_type[0]\n        length = truck_type[1]\n        width = truck_type[2]\n        height = truck_type[3]\n        if (unplaced_items[0]['weight'] <= capacity and\n                unplaced_items[0]['length'] <= length and\n                unplaced_items[0]['width'] <= width and\n                unplaced_items[0]['height'] <= height):\n            best_truck_type_index = k\n            break\n    \n    if best_truck_type_index != -1:\n        truck_index = -1  # Indicates a new truck\n        item_index = 0\n        x = 0.0\n        y = 0.0\n        z = 0.0\n        truck_type_index = best_truck_type_index\n        return truck_index, item_index, x, y, z, truck_type_index\n    \n    #If even opening a new truck fails. Return zero values so the program doesn't crash, but this signals complete failure.\n    return 0, 0, 0.0, 0.0, 0.0, 0\n\ndef find_position_in_truck(item_length, item_width, item_height, truck_length, truck_width, truck_height, occupied_volumes):\n    \"\"\"\n    Finds a suitable position for the item in the truck, considering no overlap and support.\n    \"\"\"\n    best_x = -1.0\n    best_y = -1.0\n    best_z = -1.0\n    max_volume_utilization = -1.0\n\n    # Iterate through possible positions\n    x = 0.0\n    while x + item_length <= truck_length:\n        y = 0.0\n        while y + item_width <= truck_width:\n            z = 0.0\n            while z + item_height <= truck_height:\n                # Check for overlap with existing items\n                overlap = False\n                for existing_item in occupied_volumes:\n                    existing_x = existing_item[1]\n                    existing_y = existing_item[2]\n                    existing_z = existing_item[3]\n                    existing_length = existing_item[4]\n                    existing_width = existing_item[5]\n                    existing_height = existing_item[6]\n\n                    if (x < existing_x + existing_length and\n                            x + item_length > existing_x and\n                            y < existing_y + existing_width and\n                            y + item_width > existing_y and\n                            z < existing_z + existing_height and\n                            z + item_height > existing_z):\n                        overlap = True\n                        break\n\n                if not overlap:\n                    # Check for support\n                    if check_support(x, y, z, item_length, item_width, truck_height, occupied_volumes):\n                        # Calculate volume utilization (a simple metric to prioritize better placements)\n                        volume_utilization = (item_length * item_width * item_height) / (truck_length * truck_width * truck_height)\n\n                        # Update best position if this position is better than the current best\n                        if volume_utilization > max_volume_utilization:\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            max_volume_utilization = volume_utilization\n                z += 100.0 #Increase step size to improve performance\n            y += 100.0 #Increase step size to improve performance\n        x += 100.0 #Increase step size to improve performance\n\n    return best_x, best_y, best_z, max_volume_utilization\n\n\ndef check_support(x, y, z, item_length, item_width, truck_height, occupied_volumes):\n    \"\"\"\n    Checks if the item is sufficiently supported by the truck floor or other items.\n    \"\"\"\n    supported_area = 0.0\n    total_area = item_length * item_width\n\n    # Check support from the truck floor\n    if z == 0.0:\n        supported_area = total_area\n\n    # Check support from other items\n    for existing_item in occupied_volumes:\n        existing_x = existing_item[1]\n        existing_y = existing_item[2]\n        existing_z = existing_item[3]\n        existing_length = existing_item[4]\n        existing_width = existing_item[5]\n        existing_height = existing_item[6]\n        \n        # Determine overlap in x and y dimensions\n        x_overlap = max(0, min(x + item_length, existing_x + existing_length) - max(x, existing_x))\n        y_overlap = max(0, min(y + item_width, existing_y + existing_width) - max(y, existing_y))\n        \n        if x_overlap > 0 and y_overlap > 0 and z == existing_z + existing_height:\n            supported_area += x_overlap * y_overlap\n    \n    # Check if at least 80% of the bottom surface area is supported\n    return truck_index, item_index, x, y, z, truck_type_index"
    ],
    [
        "import numpy as np\n\ndef place_item(unplaced_items, trucks_in_use, truck_types):\n    \"\"\"\n    Places items into trucks, minimizing the number of trucks used, while satisfying all constraints.\n    {This algorithm prioritizes placing items into existing trucks using a scoring system that considers space utilization and weight capacity, and it opens a new truck only when no existing truck can accommodate the item, optimizing placement based on a best-fit approach with support and overlap checks.}\n    \"\"\"\n\n    truck_index = -1\n    item_index = -1\n    x = -1.0\n    y = -1.0\n    z = -1.0\n    truck_type_index = -1\n\n    # Helper Functions\n\n    def check_overlap(x, y, z, length, width, height, occupied_volumes):\n        \"\"\"Checks for overlap with existing items in the truck.\"\"\"\n        for _, ox, oy, oz, ol, ow, oh in occupied_volumes:\n            if (x < ox + ol and x + length > ox and\n                y < oy + ow and y + width > oy and\n                z < oz + oh and z + height > oz):\n                return True\n        return False\n\n    def calculate_support(x, y, z, length, width, height, occupied_volumes, truck_height):\n        \"\"\"Calculates support for an item.\"\"\"\n        supported_area = 0.0\n        total_area = length * width\n\n        # Check for support from the truck floor\n        if z == 0:\n            supported_area = total_area\n        else:\n            # Check for support from other items\n            for _, ox, oy, oz, ol, ow, oh in occupied_volumes:\n                if oz + oh == z:\n                    x_overlap = max(0, min(x + length, ox + ol) - max(x, ox))\n                    y_overlap = max(0, min(y + width, oy + ow) - max(y, oy))\n                    supported_area += x_overlap * y_overlap\n\n        return supported_area / total_area >= 0.8\n\n    def find_best_placement(item, truck, truck_type):\n        \"\"\"Finds the best placement for an item in a truck.\"\"\"\n        best_x, best_y, best_z = -1, -1, -1\n        max_score = -1\n        item_length, item_width, item_height = item['length'], item['width'], item['height']\n        truck_length, truck_width, truck_height = truck_type[1], truck_type[2], truck_type[3]\n        occupied_volumes = [(item_id, x, y, z, length, width, height) for item_id, x, y, z, length, width, height in truck['occupied_volumes']]\n\n        # Iterate through possible positions\n        for z_candidate in sorted(list(set([0] + [oz + oh for _, ox, oy, oz, ol, ow, oh in occupied_volumes]))):\n            for y_candidate in sorted(list(set([0] + [oy + ow for _, ox, oy, oz, ol, ow, oh in occupied_volumes]))):\n                for x_candidate in sorted(list(set([0] + [ox + ol for _, ox, oy, oz, ol, ow, oh in occupied_volumes]))):\n                    # Check if item fits within the truck boundaries\n                    if x_candidate + item_length <= truck_length and y_candidate + item_width <= truck_width and z_candidate + item_height <= truck_height:\n                        # Check for overlap\n                        if not check_overlap(x_candidate, y_candidate, z_candidate, item_length, item_width, item_height, occupied_volumes):\n                            # Check for support\n                            if calculate_support(x_candidate, y_candidate, z_candidate, item_length, item_width, item_height, occupied_volumes, truck_height):\n                                # Calculate a score (e.g., based on how much space is filled)\n                                score = item_length * item_width * item_height # Simple score: volume of item\n                                if score > max_score:\n                                    max_score = score\n                                    best_x, best_y, best_z = x_candidate, y_candidate, z_candidate\n\n        return best_x, best_y, best_z\n\n    # --- Placement Logic ---\n\n    # 1. Iterate through unplaced items\n    for i, item in enumerate(unplaced_items):\n        best_truck_index = -1\n        best_x, best_y, best_z = -1, -1, -1\n\n        # 2. Try to fit the item into existing trucks\n        for j, truck in enumerate(trucks_in_use):\n            truck_type_index = truck['truck_type_index']\n            truck_type = truck_types[truck_type_index]\n\n            # Check weight capacity\n            if truck['current_weight'] + item['weight'] <= truck_type[0]:\n                x_candidate, y_candidate, z_candidate = find_best_placement(item, truck, truck_type)\n                if x_candidate != -1 and y_candidate != -1 and z_candidate != -1:\n                        best_truck_index = j\n                        best_x, best_y, best_z = x_candidate, y_candidate, z_candidate\n                        break # Found a suitable truck, no need to check others\n\n        # 3. If no existing truck can fit the item, open a new truck\n        if best_truck_index == -1:\n            # Find a truck type that can accommodate the item\n            for k, truck_type in enumerate(truck_types):\n                if item['weight'] <= truck_type[0] and item['length'] <= truck_type[1] and item['width'] <= truck_type[2] and item['height'] <= truck_type[3]:\n                    truck_type_index = k\n                    truck_index = -1\n                    item_index = i\n                    x = 0.0\n                    y = 0.0\n                    z = 0.0\n                    return truck_index, item_index, x, y, z, truck_type_index\n\n            # If no truck type is large enough, return -1 for truck_index, indicating failure to place the item.\n            # This might happen if an item exceeds the dimensions of all available truck types.\n            continue # Try to place the next item\n\n        # 4. Place the item in the best truck found\n        else:\n            truck_index = best_truck_index\n            item_index = i\n            x = best_x\n            y = best_y\n            z = best_z\n            truck_type_index = trucks_in_use[truck_index]['truck_type_index']\n            return truck_index, item_index, x, y, z, truck_type_index\n    \n    # If all items have been considered but some couldn't be placed, it indicates failure.\n    return truck_index, item_index, x, y, z, truck_type_index"
    ],
    [
        "import numpy as np\n\ndef place_item(unplaced_items, trucks_in_use, truck_types):\n    \"\"\"\n    {This algorithm prioritizes filling existing trucks, selecting the item that best fits available space and weight capacity using a scoring system considering volume utilization and support, while minimizing fragmentation and truck usage.}\n    \"\"\"\n    truck_index = -1\n    item_index = -1\n    x = 0.0\n    y = 0.0\n    z = 0.0\n    truck_type_index = -1\n\n    best_truck_index = -1\n    best_item_index = -1\n    best_x = 0.0\n    best_y = 0.0\n    best_z = 0.0\n    best_score = -1.0\n\n    # Iterate through unplaced items and trucks in use to find the best fit\n    for i, item in enumerate(unplaced_items):\n        item_length = item['length']\n        item_width = item['width']\n        item_height = item['height']\n        item_weight = item['weight']\n\n        for t_idx, truck in enumerate(trucks_in_use):\n            truck_type_index_local = truck['truck_type_index']\n            truck_capacity, truck_length, truck_width, truck_height = truck_types[truck_type_index_local]\n            current_weight = truck['current_weight']\n\n            if current_weight + item_weight <= truck_capacity:\n                # Iterate through possible positions within the truck\n                occupied_volumes = truck['occupied_volumes']\n                \n                # Check all possible positions in the truck\n                for pos_x in np.arange(0, truck_length - item_length + 1, min(item_length/2, 500)):\n                  for pos_y in np.arange(0, truck_width - item_width + 1, min(item_width/2, 500)):\n                      pos_z = 0.0\n                      \n                      # Find the lowest possible z\n                      max_z = 0.0\n                      for occupied_item in occupied_volumes:\n                          o_x, o_y, o_z, o_l, o_w, o_h = occupied_item[1:]\n                          if (pos_x < o_x + o_l and pos_x + item_length > o_x and\n                                  pos_y < o_y + o_w and pos_y + item_width > o_y):\n                              max_z = max(max_z, o_z + o_h)\n                      pos_z = max_z\n                      \n                      if pos_z + item_height <= truck_height:\n                          # Check for overlaps\n                          overlap = False\n                          for occupied_item in occupied_volumes:\n                              o_x, o_y, o_z, o_l, o_w, o_h = occupied_item[1:]\n                              if (pos_x < o_x + o_l and pos_x + item_length > o_x and\n                                      pos_y < o_y + o_w and pos_y + item_width > o_y and\n                                      pos_z < o_z + o_h and pos_z + item_height > o_z):\n                                  overlap = True\n                                  break\n\n                          if not overlap:\n                              # Check for support\n                              supported_area = 0.0\n                              total_area = item_length * item_width\n                              \n                              if pos_z == 0.0: # Supported by floor\n                                supported_area = total_area\n                              else:\n                                for occupied_item in occupied_volumes:\n                                  o_x, o_y, o_z, o_l, o_w, o_h = occupied_item[1:]\n                                  \n                                  if o_z + o_h == pos_z:\n                                      intersect_x_start = max(pos_x, o_x)\n                                      intersect_x_end = min(pos_x + item_length, o_x + o_l)\n                                      intersect_y_start = max(pos_y, o_y)\n                                      intersect_y_end = min(pos_y + item_width, o_y + o_w)\n                                      \n                                      if intersect_x_start < intersect_x_end and intersect_y_start < intersect_y_end:\n                                        supported_area += (intersect_x_end - intersect_x_start) * (intersect_y_end - intersect_y_start)\n\n                              if supported_area / total_area >= 0.8:\n\n                                  # Calculate a score based on volume utilization\n                                  remaining_volume = (truck_length * truck_width * truck_height) - sum([v[4]*v[5]*v[6] for v in truck['occupied_volumes']])\n                                  volume_utilization = (item_length * item_width * item_height) / remaining_volume\n                                  score = volume_utilization # Try different scoring mechanisms\n\n                                  if score > best_score:\n                                      best_score = score\n                                      best_truck_index = t_idx\n                                      best_item_index = i\n                                      best_x = pos_x\n                                      best_y = pos_y\n                                      best_z = pos_z\n                                      \n\n    if best_truck_index != -1:\n        truck_index = best_truck_index\n        item_index = best_item_index\n        x = best_x\n        y = best_y\n        z = best_z\n        \n    else:  # Need a new truck\n        # Prioritize fitting the largest item in a new truck\n\n        best_truck_type_index = -1\n        best_item_index_new_truck = -1\n\n        for i, item in enumerate(unplaced_items):\n          item_length = item['length']\n          item_width = item['width']\n          item_height = item['height']\n          item_weight = item['weight']\n\n          for tt_idx, truck_type in enumerate(truck_types):\n            capacity, length, width, height = truck_type\n            if item_weight <= capacity:\n\n              if item_length <= length and item_width <= width and item_height <= height:\n                #Select the truck type that is closest to the dimensions of the item\n                volume_ratio = (item_length*item_width*item_height)/(length*width*height)\n                if best_truck_type_index == -1 or volume_ratio > best_score:\n                  best_truck_type_index = tt_idx\n                  best_item_index_new_truck = i\n                  best_score = volume_ratio\n\n\n        if best_truck_type_index != -1:\n          truck_index = -1\n          item_index = best_item_index_new_truck\n          x = 0.0\n          y = 0.0\n          z = 0.0\n          truck_type_index = best_truck_type_index\n        else: #No truck type fits any item\n          return -1, 0, 0.0, 0.0, 0.0, 0 #Return invalid values. This case is unlikely with provided dimensions\n\n    return truck_index, item_index, x, y, z, truck_type_index"
    ],
    [
        "import numpy as np\n\ndef place_item(unplaced_items, trucks_in_use, truck_types):\n    \"\"\"\n    {This algorithm prioritizes placing larger items first, then iterates through existing trucks and potential positions, followed by opening a new truck if necessary, evaluating each placement based on space, weight, and support constraints.}\n    \"\"\"\n\n    truck_index = -1\n    item_index = -1\n    x = -1.0\n    y = -1.0\n    z = -1.0\n    truck_type_index = -1\n\n    # Sort unplaced items by volume (length * width * height) in descending order\n    item_indices = sorted(range(len(unplaced_items)), key=lambda i: unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height'], reverse=True)\n\n    for item_idx in item_indices:\n        item = unplaced_items[item_idx]\n        item_length = item['length']\n        item_width = item['width']\n        item_height = item['height']\n        item_weight = item['weight']\n\n        # Try placing in existing trucks\n        for truck_idx, truck in enumerate(trucks_in_use):\n            truck_type = truck_types[truck['truck_type_index']]\n            truck_capacity = truck_type[0]\n            truck_length = truck_type[1]\n            truck_width = truck_type[2]\n            truck_height = truck_type[3]\n            current_weight = truck['current_weight']\n            occupied_volumes = truck['occupied_volumes']\n\n            if current_weight + item_weight <= truck_capacity:\n                # Find a suitable position in the truck\n                for z_val in sorted(list({0.0} | set([vol[3] + vol[6] for vol in occupied_volumes]))):\n                    for y_val in sorted(list({0.0} | set([vol[2] + vol[5] for vol in occupied_volumes]))):\n                        for x_val in sorted(list({0.0} | set([vol[1] + vol[4] for vol in occupied_volumes]))):\n\n                            if x_val + item_length <= truck_length and \\\n                               y_val + item_width <= truck_width and \\\n                               z_val + item_height <= truck_height:\n\n                                # Check for overlaps\n                                overlap = False\n                                for vol in occupied_volumes:\n                                    if (x_val < vol[1] + vol[4] and x_val + item_length > vol[1] and\n                                        y_val < vol[2] + vol[5] and y_val + item_width > vol[2] and\n                                        z_val < vol[3] + vol[6] and z_val + item_height > vol[3]):\n                                        overlap = True\n                                        break\n                                if overlap:\n                                    continue\n\n                                # Check for support\n                                supported = False\n                                if z_val == 0.0:\n                                    supported = True\n                                else:\n                                    supported_area = 0.0\n                                    item_area = item_length * item_width\n                                    for vol in occupied_volumes:\n                                        if z_val == vol[3] + vol[6]:\n                                            x_overlap = max(0, min(x_val + item_length, vol[1] + vol[4]) - max(x_val, vol[1]))\n                                            y_overlap = max(0, min(y_val + item_width, vol[2] + vol[5]) - max(y_val, vol[2]))\n                                            supported_area += x_overlap * y_overlap\n\n                                    if supported_area / item_area >= 0.8:\n                                        supported = True\n\n                                if supported:\n                                    truck_index = truck_idx\n                                    item_index = item_idx\n                                    x = x_val\n                                    y = y_val\n                                    z = z_val\n                                    truck_type_index = truck['truck_type_index']\n                                    return truck_index, item_index, x, y, z, truck_type_index\n                                \n        # If no suitable truck found, open a new truck\n        if truck_index == -1:\n            for tt_idx, truck_type in enumerate(truck_types):\n                truck_capacity = truck_type[0]\n                truck_length = truck_type[1]\n                truck_width = truck_type[2]\n                truck_height = truck_type[3]\n\n                if item_weight <= truck_capacity and \\\n                   item_length <= truck_length and \\\n                   item_width <= truck_width and \\\n                   item_height <= truck_height:\n\n                    truck_index = -1\n                    item_index = item_idx\n                    x = 0.0\n                    y = 0.0\n                    z = 0.0\n                    truck_type_index = tt_idx\n                    return truck_index, item_index, x, y, z, truck_type_index\n\n    # If no placement is possible, return default values\n    truck_index = -1\n    item_index = 0 if unplaced_items else -1\n    x = 0.0\n    y = 0.0\n    z = 0.0\n    truck_type_index = 0 if truck_types else -1\n    return truck_index, item_index, x, y, z, truck_type_index"
    ]
]