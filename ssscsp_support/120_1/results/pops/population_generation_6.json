[
     {
          "algorithm": "Places the item that maximizes the ratio of volume to combined surface area, prioritizing compact shapes for better space utilization.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Places the item that maximizes the ratio of volume to combined surface area, prioritizing compact shapes for better space utilization.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = 0.0\n        best_y = 0.0\n        best_z = 0.0\n        best_orientation = 0\n        best_score = -1.0\n\n        item_index = self._select_item_to_place(unplaced_items)\n        if item_index == -1:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n        for truck_index in range(-1, len(trucks_in_use)):\n            if truck_index == -1:\n                occupied_volumes = []\n            else:\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n            x, y, z, orientation = self._find_best_position_for_item(unplaced_items[item_index], truck_type, occupied_volumes)\n\n            if x is not None:\n                dims = self._get_orientations(unplaced_items[item_index])[orientation][1]\n                new_item = {\n                    'item_type_id': unplaced_items[item_index]['item_id'],\n                    'x': x,\n                    'y': y,\n                    'z': z,\n                    'length': dims[0],\n                    'width': dims[1],\n                    'height': dims[2]\n                }\n\n                if truck_index == -1:\n                    new_volumes = [new_item]\n                else:\n                    new_volumes = occupied_volumes + [new_item]\n                score = self._evaluate_placement(truck_type, new_volumes)\n\n                if score > best_score:\n                    best_score = score\n                    best_truck_index = truck_index\n                    best_item_index = item_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item_to_place(self, unplaced_items):\n        best_item_index = -1\n        max_volume_to_sa_ratio = -1.0\n\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                l, w, h = item_type['length'], item_type['width'], item_type['height']\n                volume = l * w * h\n                surface_area = 2 * (l * w + l * h + w * h)\n                if surface_area > 0:\n                    volume_to_sa_ratio = volume / surface_area\n                else:\n                    volume_to_sa_ratio = 0.0\n                if volume_to_sa_ratio > max_volume_to_sa_ratio:\n                    max_volume_to_sa_ratio = volume_to_sa_ratio\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_position_for_item(self, item_type, truck_type, occupied_volumes):\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_fit_score = float('inf')\n\n        for orientation_index, dims in self._get_orientations(item_type):\n            possible_positions = self._generate_potential_positions(truck_type, occupied_volumes, dims[0], dims[1], dims[2])\n            for x, y, z in possible_positions:\n                if self._is_valid_placement((x, y, z), dims, truck_type, occupied_volumes):\n                    fit_score = self._calculate_fit_score((x, y, z), dims, truck_type)\n\n                    if fit_score < best_fit_score:\n                        best_fit_score = fit_score\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n        return best_x, best_y, best_z, best_orientation\n\n    def _generate_potential_positions(self, truck_dims, occupied_volumes, length, width, height):\n        positions = [(0.0, 0.0, 0.0)]\n        for item in occupied_volumes:\n            positions.append((item['x'] + item['length'], item['y'], item['z']))\n            positions.append((item['x'], item['y'] + item['width'], item['z']))\n            positions.append((item['x'], item['y'], item['z'] + item['height']))\n        return positions\n\n    def _calculate_fit_score(self, position, dims, truck_dims):\n        length, width, height = dims\n        x, y, z = position\n        length_diff = abs(truck_dims[0] - (x + length))\n        width_diff = abs(truck_dims[1] - (y + width))\n        return length_diff + width_diff\n\n    def _evaluate_placement(self, truck_dims, occupied_volumes):\n        total_volume = truck_dims[0] * truck_dims[1] * truck_dims[2]\n        occupied_volume = 0.0\n        for item in occupied_volumes:\n            occupied_volume += item['length'] * item['width'] * item['height']\n        return occupied_volume / total_volume",
          "objective": 21.95,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects the item type with the largest volume and attempts to place it, prioritizing the lowest available z-coordinate, best supporting area, and a best-fit position strategy within the container.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item type with the largest volume and attempts to place it, prioritizing the lowest available z-coordinate, best supporting area, and a best-fit position strategy within the container.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_support_area = -1\n        best_fit = float('inf')\n\n        item_index = self._select_item(unplaced_items)\n\n        if item_index == -1:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n        for truck_index in range(-1, len(trucks_in_use)):\n            if truck_index == -1:\n                occupied_volumes = []\n            else:\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n            x, y, z, orientation, support_area, fit = self._find_position_for_item(unplaced_items[item_index], truck_type, occupied_volumes)\n\n            if x != -1:\n                if best_truck_index == -1 or z < best_z or (z == best_z and support_area > best_support_area) or \\\n                   (z == best_z and support_area == best_support_area and fit < best_fit):\n                    best_truck_index = truck_index\n                    best_item_index = item_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n                    best_support_area = support_area\n                    best_fit = fit\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = 0\n\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                volume = item_type['length'] * item_type['width'] * item_type['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_position_for_item(self, item_type, truck_type, occupied_volumes):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_support_area = -1\n        best_fit = float('inf')\n\n        for orientation_index, item_dims in self._get_orientations(item_type):\n            possible_positions = self._generate_possible_positions(truck_type, occupied_volumes, item_dims)\n\n            for x, y, z in possible_positions:\n                if self._is_valid_placement((x, y, z), item_dims, truck_type, occupied_volumes):\n                    support_area = self._calculate_support_area((x, y, z), item_dims, occupied_volumes)\n                    fit = self._calculate_fit((x, y, z), item_dims, truck_type)\n\n                    if best_x == -1 or z < best_z or (z == best_z and support_area > best_support_area) or \\\n                       (z == best_z and support_area == best_support_area and fit < best_fit):\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n                        best_support_area = support_area\n                        best_fit = fit\n\n        return best_x, best_y, best_z, best_orientation, best_support_area, best_fit\n\n    def _generate_possible_positions(self, truck_dims, occupied_volumes, item_dims):\n        positions = []\n        if not occupied_volumes:\n            positions.append((0.0, 0.0, 0.0))\n            return positions\n\n        min_x, min_y, min_z = 0.0, 0.0, 0.0\n        max_x, max_y, max_z = truck_dims[0] - item_dims[0], truck_dims[1] - item_dims[1], truck_dims[2] - item_dims[2]\n\n        for item in occupied_volumes:\n            positions.append((item['x'] + item['length'], item['y'], item['z']))\n            positions.append((item['x'], item['y'] + item['width'], item['z']))\n            positions.append((item['x'], item['y'], item['z'] + item['height']))\n\n        valid_positions = []\n\n        for x, y, z in positions:\n            is_valid = True\n            for placed_item in occupied_volumes:\n                 placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                 placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                 if self._check_overlap_3d((x, y, z), item_dims, placed_item_pos, placed_item_dims):\n                      is_valid = False\n                      break\n            if is_valid and min_x <= x <= max_x and min_y <= y <= max_y and min_z <= z <= max_z:\n                valid_positions.append((x, y, z))\n\n        return valid_positions\n\n    def _calculate_support_area(self, item_to_place_pos, item_to_place_dims, occupied_volumes):\n        px, py, pz = item_to_place_pos\n        pl, pw, _ = item_to_place_dims\n        if abs(pz) < self.epsilon:\n            return pl * pw\n\n        total_support_area = 0.0\n        for placed_item in occupied_volumes:\n            placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n            placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n\n            if abs((placed_item_pos[2] + placed_item_dims[2]) - pz) < self.epsilon:\n                overlap_x = max(0, min(px + pl, placed_item_pos[0] + placed_item_dims[0]) - max(px, placed_item_pos[0]))\n                overlap_y = max(0, min(py + pw, placed_item_pos[1] + placed_item_dims[1]) - max(py, placed_item_pos[1]))\n                total_support_area += overlap_x * overlap_y\n\n        return total_support_area\n    \n    def _calculate_fit(self, item_pos, item_dims, truck_dims):\n        x, y, z = item_pos\n        l, w, h = item_dims\n        truck_length, truck_width, truck_height = truck_dims\n\n        space_x = truck_length - (x + l)\n        space_y = truck_width - (y + w)\n        space_z = truck_height - (z + h)\n\n        return space_x + space_y + space_z",
          "objective": 22.2,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects items based on a combination of remaining quantity and volume, iteratively placing them at the lowest available Z, maximizing contact area, and penalizing unused space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects items based on a combination of remaining quantity and volume, iteratively placing them at the lowest available Z, maximizing contact area, and penalizing unused space.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = -1.0\n\n        item_index = self._select_item(unplaced_items)\n\n        if item_index == -1:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n        for truck_index in range(-1, len(trucks_in_use)):\n            if truck_index == -1:\n                occupied_volumes = []\n            else:\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n            x, y, z, orientation = self._find_position_for_item(unplaced_items[item_index], truck_type, occupied_volumes)\n\n            if x != -1:\n                dims = self._get_orientations(unplaced_items[item_index])[orientation][1]\n                score = self._evaluate_placement((x, y, z), dims, truck_type, occupied_volumes)\n\n                if score > best_score:\n                    best_score = score\n                    best_truck_index = truck_index\n                    best_item_index = item_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        best_priority = -1.0\n\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                volume = item_type['length'] * item_type['width'] * item_type['height']\n                priority = (item_type['quantity'] / 60.0) + (volume / (40.0 * 32.0 * 35.0))  # Normalize and combine factors\n                if priority > best_priority:\n                    best_priority = priority\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_position_for_item(self, item_type, truck_type, occupied_volumes):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_contact_area = -1\n\n        for orientation_index, item_dims in self._get_orientations(item_type):\n            possible_positions = self._generate_possible_positions(truck_type, occupied_volumes, item_dims)\n\n            for x, y, z in possible_positions:\n                if self._is_valid_placement((x, y, z), item_dims, truck_type, occupied_volumes):\n                    contact_area = self._calculate_contact_area((x, y, z), item_dims, occupied_volumes)\n\n                    if best_x == -1 or z < best_z or (z == best_z and contact_area > best_contact_area):\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n                        best_contact_area = contact_area\n\n        return best_x, best_y, best_z, best_orientation\n\n    def _generate_possible_positions(self, truck_dims, occupied_volumes, item_dims):\n        positions = []\n        if not occupied_volumes:\n            positions.append((0.0, 0.0, 0.0))\n            return positions\n\n        for item in occupied_volumes:\n            positions.append((item['x'] + item['length'], item['y'], item['z']))\n            positions.append((item['x'], item['y'] + item['width'], item['z']))\n            positions.append((item['x'], item['y'], item['z'] + item['height']))\n        tolerance = 1e-6\n        valid_positions = []\n\n        for x, y, z in positions:\n            is_valid = True\n            for placed_item in occupied_volumes:\n                 placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                 placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                 if self._check_overlap_3d((x, y, z), item_dims, placed_item_pos, placed_item_dims):\n                      is_valid = False\n                      break\n            if is_valid:\n               if (x >= 0.0 - tolerance and x + item_dims[0] <= truck_dims[0] + tolerance and\n                     y >= 0.0 - tolerance and y + item_dims[1] <= truck_dims[1] + tolerance and\n                     z >= 0.0 - tolerance and z + item_dims[2] <= truck_dims[2] + tolerance):\n                    valid_positions.append((x, y, z))\n\n        return valid_positions\n    \n    def _calculate_contact_area(self, item_to_place_pos, item_to_place_dims, occupied_volumes):\n        px, py, pz = item_to_place_pos\n        pl, pw, _ = item_to_place_dims\n        if abs(pz) < self.epsilon:\n            return pl * pw\n\n        total_contact_area = 0.0\n        for placed_item in occupied_volumes:\n            placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n            placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n\n            if abs((placed_item_pos[2] + placed_item_dims[2]) - pz) < self.epsilon:\n                overlap_x = max(0, min(px + pl, placed_item_pos[0] + placed_item_dims[0]) - max(px, placed_item_pos[0]))\n                overlap_y = max(0, min(py + pw, placed_item_pos[1] + placed_item_dims[1]) - max(py, placed_item_pos[1]))\n                total_contact_area += overlap_x * overlap_y\n\n        return total_contact_area\n\n    def _evaluate_placement(self, item_pos, item_dims, truck_dims, occupied_volumes):\n        total_volume = truck_dims[0] * truck_dims[1] * truck_dims[2]\n        occupied_volume = 0.0\n        current_item_volume = item_dims[0] * item_dims[1] * item_dims[2]\n\n        for item in occupied_volumes:\n            occupied_volume += item['length'] * item['width'] * item['height']\n\n        empty_space_penalty = (total_volume - (occupied_volume + current_item_volume)) / total_volume\n        x, y, z = item_pos\n        utilization_reward = self._calculate_contact_area((x, y, z), item_dims, occupied_volumes) / (item_dims[0] * item_dims[1])\n        return utilization_reward - 0.1 * empty_space_penalty",
          "objective": 22.7,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects items based on remaining quantity, places them using a best-fit heuristic minimizing wasted space, and opens a new truck if necessary.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects items based on remaining quantity, places them using a best-fit heuristic minimizing wasted space, and opens a new truck if necessary.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_wasted_space = float('inf')\n\n        item_index = self._select_item(unplaced_items)\n\n        if item_index == -1:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n        for truck_index in range(-1, len(trucks_in_use)):\n            if truck_index == -1:\n                occupied_volumes = []\n            else:\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n            x, y, z, orientation, wasted_space = self._find_position_for_item(unplaced_items[item_index], truck_type, occupied_volumes)\n\n            if x != -1:\n                if best_truck_index == -1 or wasted_space < best_wasted_space:\n                    best_truck_index = truck_index\n                    best_item_index = item_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n                    best_wasted_space = wasted_space\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        best_quantity = -1\n\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                quantity = item_type['quantity']\n                if quantity > best_quantity:\n                    best_quantity = quantity\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_position_for_item(self, item_type, truck_type, occupied_volumes):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_wasted_space = float('inf')\n\n        for orientation_index, item_dims in self._get_orientations(item_type):\n            possible_positions = self._generate_possible_positions(truck_type, occupied_volumes, item_dims)\n\n            for x, y, z in possible_positions:\n                if self._is_valid_placement((x, y, z), item_dims, truck_type, occupied_volumes):\n                    wasted_space = self._calculate_wasted_space((x, y, z), item_dims, truck_type, occupied_volumes)\n\n                    if best_x == -1 or wasted_space < best_wasted_space:\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n                        best_wasted_space = wasted_space\n\n        return best_x, best_y, best_z, best_orientation, best_wasted_space\n\n    def _generate_possible_positions(self, truck_dims, occupied_volumes, item_dims):\n        positions = []\n        if not occupied_volumes:\n            positions.append((0.0, 0.0, 0.0))\n            return positions\n\n        for x in sorted(list(set([0.0] + [item['x'] + item['length'] for item in occupied_volumes]))):\n            for y in sorted(list(set([0.0] + [item['y'] + item['width'] for item in occupied_volumes]))):\n                for z in sorted(list(set([0.0] + [item['z'] + item['height'] for item in occupied_volumes]))):\n                    is_valid = True\n                    for placed_item in occupied_volumes:\n                        placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                        placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                        if self._check_overlap_3d((x, y, z), item_dims, placed_item_pos, placed_item_dims):\n                            is_valid = False\n                            break\n                    if is_valid and self._is_within_container_bounds((x,y,z), item_dims, truck_dims):\n                        positions.append((x, y, z))\n\n        return positions\n\n    def _calculate_wasted_space(self, item_to_place_pos, item_to_place_dims, truck_dims, occupied_volumes):\n        truck_length, truck_width, truck_height = truck_dims\n        item_length, item_width, item_height = item_to_place_dims\n\n        max_x = item_to_place_pos[0] + item_length\n        max_y = item_to_place_pos[1] + item_width\n        max_z = item_to_place_pos[2] + item_height\n        \n        for item in occupied_volumes:\n            max_x = max(max_x, item['x'] + item['length'])\n            max_y = max(max_y, item['y'] + item['width'])\n            max_z = max(max_z, item['z'] + item['height'])\n            \n        wasted_space = (truck_length - max_x) * truck_width * truck_height + (truck_width - max_y) * truck_length * truck_height + (truck_height-max_z)*truck_length*truck_width\n        return wasted_space",
          "objective": 22.95,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects items prioritizing high quantity and low height, places items on the lowest Z, maximizes stability, and aggressively penalizes empty space to encourage full truck utilization.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects items prioritizing high quantity and low height, places items on the lowest Z, maximizes stability, and aggressively penalizes empty space to encourage full truck utilization.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n        self.empty_space_penalty_factor = 0.5\n        self.quantity_priority_factor = 1.0\n        self.height_priority_factor = 0.5\n        self.stability_reward_factor = 0.8\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = -1.0\n\n        item_index = self._select_item(unplaced_items)\n\n        if item_index == -1:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n        for truck_index in range(-1, len(trucks_in_use)):\n            if truck_index == -1:\n                occupied_volumes = []\n            else:\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n            x, y, z, orientation = self._find_position_for_item(unplaced_items[item_index], truck_type, occupied_volumes)\n\n            if x != -1:\n                dims = self._get_orientations(unplaced_items[item_index])[orientation][1]\n                score = self._evaluate_placement((x, y, z), dims, truck_type, occupied_volumes)\n\n                if score > best_score:\n                    best_score = score\n                    best_truck_index = truck_index\n                    best_item_index = item_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        best_priority = -1.0\n\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                height = item_type['height']\n                priority = (self.quantity_priority_factor * item_type['quantity'] / 60.0) - (self.height_priority_factor * height / 35.0)\n                if priority > best_priority:\n                    best_priority = priority\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_position_for_item(self, item_type, truck_type, occupied_volumes):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_contact_area = -1\n\n        for orientation_index, item_dims in self._get_orientations(item_type):\n            possible_positions = self._generate_possible_positions(truck_type, occupied_volumes, item_dims)\n\n            for x, y, z in possible_positions:\n                if self._is_valid_placement((x, y, z), item_dims, truck_type, occupied_volumes):\n                    contact_area = self._calculate_contact_area((x, y, z), item_dims, occupied_volumes)\n\n                    if best_x == -1 or z < best_z or (z == best_z and contact_area > best_contact_area):\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n                        best_contact_area = contact_area\n\n        return best_x, best_y, best_z, best_orientation\n\n    def _generate_possible_positions(self, truck_dims, occupied_volumes, item_dims):\n        positions = []\n        if not occupied_volumes:\n            positions.append((0.0, 0.0, 0.0))\n            return positions\n\n        for item in occupied_volumes:\n            positions.append((item['x'] + item['length'], item['y'], item['z']))\n            positions.append((item['x'], item['y'] + item['width'], item['z']))\n            positions.append((item['x'], item['y'], item['z'] + item['height']))\n        tolerance = 1e-6\n        valid_positions = []\n\n        for x, y, z in positions:\n            is_valid = True\n            for placed_item in occupied_volumes:\n                 placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                 placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                 if self._check_overlap_3d((x, y, z), item_dims, placed_item_pos, placed_item_dims):\n                      is_valid = False\n                      break\n            if is_valid:\n               if (x >= 0.0 - tolerance and x + item_dims[0] <= truck_dims[0] + tolerance and\n                     y >= 0.0 - tolerance and y + item_dims[1] <= truck_dims[1] + tolerance and\n                     z >= 0.0 - tolerance and z + item_dims[2] <= truck_dims[2] + tolerance):\n                    valid_positions.append((x, y, z))\n\n        return valid_positions\n\n    def _calculate_contact_area(self, item_to_place_pos, item_to_place_dims, occupied_volumes):\n        px, py, pz = item_to_place_pos\n        pl, pw, _ = item_to_place_dims\n        if abs(pz) < self.epsilon:\n            return pl * pw\n\n        total_contact_area = 0.0\n        for placed_item in occupied_volumes:\n            placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n            placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n\n            if abs((placed_item_pos[2] + placed_item_dims[2]) - pz) < self.epsilon:\n                overlap_x = max(0, min(px + pl, placed_item_pos[0] + placed_item_dims[0]) - max(px, placed_item_pos[0]))\n                overlap_y = max(0, min(py + pw, placed_item_pos[1] + placed_item_dims[1]) - max(py, placed_item_pos[1]))\n                total_contact_area += overlap_x * overlap_y\n\n        return total_contact_area\n\n    def _evaluate_placement(self, item_pos, item_dims, truck_dims, occupied_volumes):\n        total_volume = truck_dims[0] * truck_dims[1] * truck_dims[2]\n        occupied_volume = 0.0\n        current_item_volume = item_dims[0] * item_dims[1] * item_dims[2]\n\n        for item in occupied_volumes:\n            occupied_volume += item['length'] * item['width'] * item['height']\n\n        empty_space_penalty = (total_volume - (occupied_volume + current_item_volume)) / total_volume\n        x, y, z = item_pos\n        utilization_reward = self.stability_reward_factor * (self._calculate_contact_area((x, y, z), item_dims, occupied_volumes) / (item_dims[0] * item_dims[1]))\n        return utilization_reward - self.empty_space_penalty_factor * empty_space_penalty",
          "objective": 23.0,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]