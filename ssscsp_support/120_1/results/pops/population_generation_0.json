[
     {
          "algorithm": "Iteratively select the item type with the largest volume and attempt to place it in the first available truck or a new truck, trying all 6 orientations at the lowest feasible position, using a heuristic based on minimum wasted space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Iteratively select the item type with the largest volume and attempt to place it in the first available truck or a new truck, trying all 6 orientations at the lowest feasible position, using a heuristic based on minimum wasted space.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = 0.0\n        best_y = 0.0\n        best_z = 0.0\n        best_orientation = 0\n        min_wasted_space = float('inf')\n\n        item_index = self._select_item(unplaced_items)\n\n        if item_index == -1:\n            return -1, -1, 0.0, 0.0, 0.0, 0  # No items left to place\n\n        for truck_index in range(-1, len(trucks_in_use)):\n            if truck_index == -1:\n                occupied_volumes = []\n            else:\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n            x, y, z, orientation = self._find_position_for_item(unplaced_items[item_index], truck_type, occupied_volumes)\n\n            if x is not None:\n                item_dims = self._get_orientations(unplaced_items[item_index])[orientation][1]\n\n                item_placement = {\n                    'item_type_id': unplaced_items[item_index]['item_id'],\n                    'x': x,\n                    'y': y,\n                    'z': z,\n                    'length': item_dims[0],\n                    'width': item_dims[1],\n                    'height': item_dims[2]\n                }\n\n                if truck_index == -1:\n                    new_truck_volumes = [item_placement]\n                else:\n                    new_truck_volumes = trucks_in_use[truck_index]['occupied_volumes'] + [item_placement]\n\n                wasted_space = self._calculate_wasted_space(truck_type, new_truck_volumes)\n\n                if wasted_space < min_wasted_space:\n                    min_wasted_space = wasted_space\n                    best_truck_index = truck_index\n                    best_item_index = item_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                volume = item_type['length'] * item_type['width'] * item_type['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n\n        return best_item_index\n\n\n    def _find_position_for_item(self, item_type, truck_type, occupied_volumes):\n        possible_positions = self._generate_possible_positions(truck_type, occupied_volumes)\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n\n        for orientation_index, item_dims in self._get_orientations(item_type):\n            for x, y, z in possible_positions:\n                if self._is_valid_placement((x, y, z), item_dims, truck_type, occupied_volumes):\n                    return x, y, z, orientation_index\n\n        return best_x, best_y, best_z, best_orientation\n\n    def _generate_possible_positions(self, truck_dims, occupied_volumes):\n        positions = [(0.0, 0.0, 0.0)]\n        for item in occupied_volumes:\n            positions.append((item['x'] + item['length'], item['y'], item['z']))\n            positions.append((item['x'], item['y'] + item['width'], item['z']))\n            positions.append((item['x'], item['y'], item['z'] + item['height']))\n\n        return positions\n\n    def _calculate_wasted_space(self, truck_dims, occupied_volumes):\n        total_volume = truck_dims[0] * truck_dims[1] * truck_dims[2]\n        occupied_volume = 0.0\n        for item in occupied_volumes:\n            occupied_volume += item['length'] * item['width'] * item['height']\n        return total_volume - occupied_volume",
          "objective": 24.85,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "The algorithm iterates through unplaced items, tries all orientations and positions in existing trucks, and if no valid placement is found, opens a new truck and places the item there using a bottom-left-fill strategy.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {The algorithm iterates through unplaced items, tries all orientations and positions in existing trucks, and if no valid placement is found, opens a new truck and places the item there using a bottom-left-fill strategy.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] <= 0:\n                continue\n\n            for truck_index, truck in enumerate(trucks_in_use):\n                x, y, z, orientation = self._find_placement_in_truck(item_type, truck_type, truck['occupied_volumes'])\n                if x != -1:\n                    return truck_index, item_index, x, y, z, orientation\n            \n\n            x, y, z, orientation = self._find_placement_in_new_truck(item_type, truck_type)\n            if x != -1:\n                return -1, item_index, x, y, z, orientation\n            \n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n\n    def _find_placement_in_truck(self, item_type, truck_type, occupied_volumes):\n        for orientation, item_dims in self._get_orientations(item_type):\n            length, width, height = item_dims\n            \n            positions = self._generate_potential_positions(truck_type, occupied_volumes, length, width, height)\n            for x, y, z in positions:\n                if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                    return x, y, z, orientation\n        return -1, -1, -1, -1\n\n    def _find_placement_in_new_truck(self, item_type, truck_type):\n        for orientation, item_dims in self._get_orientations(item_type):\n            length, width, height = item_dims\n            if self._is_valid_placement((0, 0, 0), (length, width, height), truck_type, []):\n                return 0, 0, 0, orientation\n        return -1, -1, -1, -1\n    \n    def _generate_potential_positions(self, truck_dims, occupied_volumes, length, width, height):\n        cl, cw, ch = truck_dims\n        potential_positions = []\n\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        for item in occupied_volumes:\n            ix, iy, iz = item['x'], item['y'], item['z']\n            il, iw, ih = item['length'], item['width'], item['height']\n\n\n            potential_positions.append((ix + il, iy, iz))\n            potential_positions.append((ix, iy + iw, iz))\n            potential_positions.append((ix, iy, iz + ih))\n\n        potential_positions.append((0, 0, 0))\n\n        cleaned_positions = []\n        for x, y, z in potential_positions:\n            is_duplicate = False\n            for cx, cy, cz in cleaned_positions:\n                if abs(x - cx) < self.epsilon and abs(y - cy) < self.epsilon and abs(z - cz) < self.epsilon:\n                    is_duplicate = True\n                    break\n            if not is_duplicate:\n                cleaned_positions.append((x, y, z))\n\n        return cleaned_positions",
          "objective": 27.35,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm prioritizes filling existing trucks by iterating through item types and orientations, placing the first valid stable placement found, or opens a new truck if no placement is possible.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes filling existing trucks by iterating through item types and orientations, placing the first valid stable placement found, or opens a new truck if no placement is possible.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_placement(self, unplaced_items, trucks_in_use, truck_type):\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                for truck_index in range(len(trucks_in_use)):\n                    found_placement = self._attempt_placement_in_truck(item_index, item_type, trucks_in_use[truck_index], truck_type)\n                    if found_placement:\n                        return truck_index, item_index, found_placement['x'], found_placement['y'], found_placement['z'], found_placement['orientation']\n\n                new_truck_placement = self._attempt_placement_in_new_truck(item_index, item_type, truck_type)\n                if new_truck_placement:\n                    return -1, item_index, new_truck_placement['x'], new_truck_placement['y'], new_truck_placement['z'], new_truck_placement['orientation']\n        return -1, 0, 0, 0, 0, 0\n\n    def _attempt_placement_in_truck(self, item_index, item_type, truck, truck_type):\n        for orientation, dims in self._get_orientations(item_type):\n            length, width, height = dims\n            for x in np.arange(0, truck_type[0], 1.0):\n                for y in np.arange(0, truck_type[1], 1.0):\n                    z = 0.0\n                    item_pos = (x, y, z)\n                    item_dims = (length, width, height)\n                    if self._is_valid_placement(item_pos, item_dims, truck_type, truck['occupied_volumes']):\n                        return {'x': x, 'y': y, 'z': z, 'orientation': orientation}\n                    \n                    z=0.0\n                    for placed_item in truck['occupied_volumes']:\n                      placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                      placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])   \n                      if x >= placed_item_pos[0] and x+ length <= placed_item_pos[0]+placed_item_dims[0] and y >= placed_item_pos[1] and y + width <= placed_item_pos[1]+placed_item_dims[1]:\n                        z= placed_item_pos[2] + placed_item_dims[2]\n                        item_pos = (x, y, z)\n                        item_dims = (length, width, height)\n                        if self._is_valid_placement(item_pos, item_dims, truck_type, truck['occupied_volumes']):\n                            return {'x': x, 'y': y, 'z': z, 'orientation': orientation}\n        return None\n\n    def _attempt_placement_in_new_truck(self, item_index, item_type, truck_type):\n        for orientation, dims in self._get_orientations(item_type):\n            length, width, height = dims\n            x, y, z = 0.0, 0.0, 0.0\n            item_pos = (x, y, z)\n            item_dims = (length, width, height)\n            if self._is_within_container_bounds(item_pos, item_dims, truck_type):\n                return {'x': x, 'y': y, 'z': z, 'orientation': orientation}\n        return None\nclass AlgorithmFIX1(Algorithm):\n    def _attempt_placement_in_truck(self, item_index, item_type, truck, truck_type):\n        for orientation, dims in self._get_orientations(item_type):\n            length, width, height = dims\n            for x in np.arange(0, truck_type[0] - length + self.epsilon, 1.0):\n                for y in np.arange(0, truck_type[1] - width + self.epsilon, 1.0):\n                    z = 0.0\n                    item_pos = (x, y, z)\n                    item_dims = (length, width, height)\n                    if self._is_valid_placement(item_pos, item_dims, truck_type, truck['occupied_volumes']):\n                        return {'x': x, 'y': y, 'z': z, 'orientation': orientation}\n                    \n                    z=0.0\n                    for placed_item in truck['occupied_volumes']:\n                      placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                      placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])   \n                      if x >= placed_item_pos[0] and x+ length <= placed_item_pos[0]+placed_item_dims[0] and y >= placed_item_pos[1] and y + width <= placed_item_pos[1]+placed_item_dims[1]:\n                        z= placed_item_pos[2] + placed_item_dims[2]\n                        item_pos = (x, y, z)\n                        item_dims = (length, width, height)\n                        if self._is_valid_placement(item_pos, item_dims, truck_type, truck['occupied_volumes']):\n                            return {'x': x, 'y': y, 'z': z, 'orientation': orientation}\n        return None",
          "objective": 28.35,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     },
     {
          "algorithm": "Selects the item type with the largest remaining quantity, iterates through orientations and positions to find a valid placement in an existing truck or creates a new one.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item type with the largest remaining quantity, iterates through orientations and positions to find a valid placement in an existing truck or creates a new one.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n\n        sorted_item_indices = sorted(range(len(unplaced_items)), key=lambda k: unplaced_items[k]['quantity'], reverse=True)\n        \n        for item_index in sorted_item_indices:\n            item_type = unplaced_items[item_index]\n\n            for orientation, dims in self._get_orientations(item_type):\n                l, w, h = dims\n\n                for truck_index, truck in enumerate(trucks_in_use):\n                    occupied_volumes = truck['occupied_volumes']\n                    \n                    positions = self._generate_candidate_positions(truck_type, l, w, h, occupied_volumes)\n                    \n                    for x, y, z in positions:\n                        if self._is_valid_placement((x, y, z), (l, w, h), truck_type, occupied_volumes):\n                            return truck_index, item_index, x, y, z, orientation\n\n                #Try new truck if no placement is found\n                positions_new_truck = self._generate_candidate_positions(truck_type, l, w, h, [])\n                for x, y, z in positions_new_truck:\n                        if self._is_valid_placement((x, y, z), (l, w, h), truck_type, []):\n                            return -1, item_index, x, y, z, orientation\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _generate_candidate_positions(self, container_dims, item_length, item_width, item_height, occupied_volumes):\n        positions = []\n        if not occupied_volumes:\n            positions.append((0.0, 0.0, 0.0))\n            return positions\n\n        for placed_item in occupied_volumes:\n            x, y, z = placed_item['x'], placed_item['y'], placed_item['z']\n            l, w, h = placed_item['length'], placed_item['width'], placed_item['height']\n            \n            #Positions to the right, front, and top of each item.\n            positions.append((x + l, y, z))\n            positions.append((x, y + w, z))\n            positions.append((x, y, z + h))\n\n        #Add origin as a candidate position in case no items exist (first item case) and in all other cases to pack better\n        positions.append((0.0,0.0,0.0))\n        \n        return positions",
          "objective": 28.45,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects the largest remaining item type, tries all orientations and positions, and places it in the existing or new truck if a valid placement is found.",
          "code": "import numpy as np\n\n\nclass Algorithm(BaseAlgorithm):\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    # {Selects the largest remaining item type, tries all orientations and positions, and places it in the existing or new truck if a valid placement is found.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, 0, 0, 0, 0\n\n        item_type = unplaced_items[item_index]\n        truck_index, x, y, z, orientation = self._find_placement(item_type, trucks_in_use, truck_type)\n\n        if truck_index == -1:\n            truck_index, x, y, z, orientation = self._place_in_new_truck(item_type, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                volume = item_type['length'] * item_type['width'] * item_type['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_placement(self, item_type, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z = 0, 0, 0\n        best_orientation = 0\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            occupied_volumes = truck['occupied_volumes']\n            x, y, z, orientation = self._find_position_in_truck(item_type, truck_type, occupied_volumes)\n            if x is not None:\n                return truck_index, x, y, z, orientation\n        \n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck_type, occupied_volumes):\n        orientations = self._get_orientations(item_type)\n        for orientation_index, (orientation, (l, w, h)) in enumerate(orientations):\n            for x in np.arange(0, truck_type[0] - l + self.epsilon, 1.0):\n                for y in np.arange(0, truck_type[1] - w + self.epsilon, 1.0):\n                    for z in np.arange(0, truck_type[2] - h + self.epsilon, 1.0):\n                        potential_position = (x, y, z)\n                        potential_dimensions = (l, w, h)\n                        if self._is_valid_placement(potential_position, potential_dimensions, truck_type, occupied_volumes):\n                            return x, y, z, orientation_index\n        return None, None, None, None\n\n    def _place_in_new_truck(self, item_type, truck_type):\n        orientations = self._get_orientations(item_type)\n        for orientation_index, (orientation, (l, w, h)) in enumerate(orientations):\n            if l <= truck_type[0] and w <= truck_type[1] and h <= truck_type[2]:\n                return -1, 0, 0, 0, orientation_index\n        return -1,0,0,0,0\nclass AlgorithmFIX1(Algorithm):\n    def _find_position_in_truck(self, item_type, truck_type, occupied_volumes):\n        orientations = self._get_orientations(item_type)\n        max_steps = 10\n        for orientation_index, (orientation, (l, w, h)) in enumerate(orientations):\n            x_step = max(1.0, l)\n            y_step = max(1.0, w)\n            z_step = max(1.0, h)\n            \n            x_range = np.arange(0, truck_type[0] - l + self.epsilon, x_step)\n            y_range = np.arange(0, truck_type[1] - w + self.epsilon, y_step)\n            z_range = np.arange(0, truck_type[2] - h + self.epsilon, z_step)\n            \n            if len(x_range) * len(y_range) * len(z_range) > max_steps:\n                \n                x_range = np.linspace(0, truck_type[0] - l + self.epsilon, min(len(x_range), int(np.sqrt(max_steps)) ) )\n                y_range = np.linspace(0, truck_type[1] - w + self.epsilon, min(len(y_range), int(np.sqrt(max_steps)) ) )\n                z_range = np.array([0.0])\n            \n\n            for x in x_range:\n                for y in y_range:\n                    for z in z_range:\n                        potential_position = (x, y, z)\n                        potential_dimensions = (l, w, h)\n                        if self._is_valid_placement(potential_position, potential_dimensions, truck_type, occupied_volumes):\n                            return x, y, z, orientation_index\n        return None, None, None, None",
          "objective": 30.25,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     }
]