{
     "algorithm": "Iteratively selects the item type with the smallest base area and attempts to place it, prioritizing the lowest available z-coordinate and best supporting area, using a skyline heuristic to find potential positions.",
     "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Iteratively selects the item type with the smallest base area and attempts to place it, prioritizing the lowest available z-coordinate and best supporting area, using a skyline heuristic to find potential positions.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_support_area = -1\n\n        item_index = self._select_item(unplaced_items)\n\n        if item_index == -1:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n        for truck_index in range(-1, len(trucks_in_use)):\n            if truck_index == -1:\n                occupied_volumes = []\n            else:\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n            x, y, z, orientation, support_area = self._find_position_for_item(unplaced_items[item_index], truck_type, occupied_volumes)\n\n            if x != -1:\n                if best_truck_index == -1 or z < best_z or (z == best_z and support_area > best_support_area):\n                    best_truck_index = truck_index\n                    best_item_index = item_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n                    best_support_area = support_area\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        min_base_area = float('inf')\n\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                base_area = item_type['length'] * item_type['width']\n                if base_area < min_base_area:\n                    min_base_area = base_area\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_position_for_item(self, item_type, truck_type, occupied_volumes):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_support_area = -1\n\n        for orientation_index, item_dims in self._get_orientations(item_type):\n            possible_positions = self._generate_possible_positions(truck_type, occupied_volumes, item_dims)\n\n            for x, y, z in possible_positions:\n                if self._is_valid_placement((x, y, z), item_dims, truck_type, occupied_volumes):\n                    support_area = self._calculate_support_area((x, y, z), item_dims, occupied_volumes)\n\n                    if best_x == -1 or z < best_z or (z == best_z and support_area > best_support_area):\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n                        best_support_area = support_area\n\n        return best_x, best_y, best_z, best_orientation, best_support_area\n\n    def _generate_possible_positions(self, truck_dims, occupied_volumes, item_dims):\n        positions = []\n        if not occupied_volumes:\n            positions.append((0.0, 0.0, 0.0))\n            return positions\n\n        for item in occupied_volumes:\n            positions.append((item['x'] + item['length'], item['y'], item['z']))\n            positions.append((item['x'], item['y'] + item['width'], item['z']))\n            positions.append((item['x'], item['y'], item['z'] + item['height']))\n\n        valid_positions = []\n\n        for x, y, z in positions:\n            is_valid = True\n            for placed_item in occupied_volumes:\n                 placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n                 placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n                 if self._check_overlap_3d((x, y, z), item_dims, placed_item_pos, placed_item_dims):\n                      is_valid = False\n                      break\n            if is_valid:\n                valid_positions.append((x, y, z))\n\n        return valid_positions\n    \n    def _calculate_support_area(self, item_to_place_pos, item_to_place_dims, occupied_volumes):\n        px, py, pz = item_to_place_pos\n        pl, pw, _ = item_to_place_dims\n        if abs(pz) < self.epsilon:\n            return pl * pw\n\n        total_support_area = 0.0\n        for placed_item in occupied_volumes:\n            placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n            placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n\n            if abs((placed_item_pos[2] + placed_item_dims[2]) - pz) < self.epsilon:\n                overlap_x = max(0, min(px + pl, placed_item_pos[0] + placed_item_dims[0]) - max(px, placed_item_pos[0]))\n                overlap_y = max(0, min(py + pw, placed_item_pos[1] + placed_item_dims[1]) - max(py, placed_item_pos[1]))\n                total_support_area += overlap_x * overlap_y\n\n        return total_support_area",
     "objective": 23.7,
     "other_inf": null,
     "class_name": "Algorithm"
}