[
     {
          "algorithm": "Select the item with the largest volume, then iterates through orientations and positions to find a valid placement, opening a new truck if necessary.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n        # {Select the item with the largest volume, then iterates through orientations and positions to find a valid placement, opening a new truck if necessary.}\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n\n        item_index = self._select_item(unplaced_items)\n\n        if item_index == -1:\n            return -1, -1, -1, -1, -1, -1\n\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            x, y, z, orientation = self._find_placement_in_truck(item_type, truck['occupied_volumes'], truck_type)\n            if x != -1:\n                return truck_index, item_index, x, y, z, orientation\n\n        x, y, z, orientation = self._find_placement_new_truck(item_type, truck_type)\n        if x != -1:\n            return -1, item_index, x, y, z, orientation\n\n        return -1, -1, -1, -1, -1, -1\n\n    def _find_placement_in_truck(self, item_type, occupied_volumes, truck_type):\n        for orientation, dims in self._get_orientations(item_type):\n            length, width, height = dims\n            for x in np.arange(0, truck_type[0], 1):\n                for y in np.arange(0, truck_type[1], 1):\n                    z = self._calculate_z(occupied_volumes, x, y, length, width)\n                    if z != -1:\n                        if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                            return x, y, z, orientation\n        return -1, -1, -1, -1\n\n    def _calculate_z(self, occupied_volumes, x, y, length, width):\n        z = 0\n        for placed_item in occupied_volumes:\n            placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n            placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n            if (x < placed_item_pos[0] + placed_item_dims[0] and x + length > placed_item_pos[0] and\n                    y < placed_item_pos[1] + placed_item_dims[1] and y + width > placed_item_pos[1]):\n                z = max(z, placed_item_pos[2] + placed_item_dims[2])\n        return z\n\n    def _find_placement_new_truck(self, item_type, truck_type):\n        occupied_volumes = []\n        for orientation, dims in self._get_orientations(item_type):\n            length, width, height = dims\n            if self._is_valid_placement((0, 0, 0), (length, width, height), truck_type, occupied_volumes):\n                return 0, 0, 0, orientation\n        return -1, -1, -1, -1\nclass AlgorithmFIX1(Algorithm):\n    def _find_placement_in_truck(self, item_type, occupied_volumes, truck_type):\n        for orientation, dims in self._get_orientations(item_type):\n            length, width, height = dims\n            max_x = truck_type[0] - length + self.epsilon\n            max_y = truck_type[1] - width + self.epsilon\n            \n            x_values = np.arange(0, max_x, 1)\n            y_values = np.arange(0, max_y, 1)\n\n            if not x_values.size or not y_values.size:\n                continue\n                            \n            for x in x_values:\n                for y in y_values:\n                    z = self._calculate_z(occupied_volumes, x, y, length, width)\n                    if z != -1:\n                        if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                            return x, y, z, orientation\n        return -1, -1, -1, -1",
          "objective": 24.8,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     },
     {
          "algorithm": "Selects the item with the largest volume to place, iterates through orientations and positions to find a valid placement in an existing or new truck, prioritizing placements in existing trucks.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item with the largest volume to place, iterates through orientations and positions to find a valid placement in an existing or new truck, prioritizing placements in existing trucks.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n    \n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        best_volume = -1\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > best_volume:\n                    best_volume = volume\n                    best_item_index = i\n        return best_item_index\n\n    def _find_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n\n        # Try placing in existing trucks\n        for truck_index in range(len(trucks_in_use)):\n            x, y, z, orientation = self._find_position_in_truck(unplaced_items, trucks_in_use, truck_type, item_index, truck_index)\n            if x is not None:\n                return truck_index, x, y, z, orientation\n\n        # If no placement in existing trucks, create a new truck\n        new_truck_index = -1\n        x, y, z, orientation = self._find_position_in_truck(unplaced_items, trucks_in_use, truck_type, item_index, new_truck_index)\n        if x is not None:\n             return new_truck_index, x, y, z, orientation  \n        \n        return None, None, None, None, None\n\n    def _find_position_in_truck(self, unplaced_items, trucks_in_use, truck_type, item_index, truck_index):\n        item_type = unplaced_items[item_index]\n        container_dims = truck_type\n        occupied_volumes = []\n        if truck_index != -1:\n            occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n        orientations = self._get_orientations(item_type)\n        for orientation_index, (orientation_id, item_dims) in enumerate(orientations):\n            L, W, H = item_dims\n            \n            positions = self._generate_potential_positions(container_dims, L, W, H, occupied_volumes)          \n\n            for px, py, pz in positions:\n                if self._is_valid_placement((px, py, pz), (L, W, H), container_dims, occupied_volumes):\n                    return px, py, pz, orientation_id\n\n        return None, None, None, None\n\n    def _generate_potential_positions(self, container_dims, L, W, H, occupied_volumes):\n        cl, cw, ch = container_dims\n        positions = [(0, 0, 0)]\n        for placed_item in occupied_volumes:\n              yield placed_item['x'] + placed_item['length'], placed_item['y'], placed_item['z']\n              yield placed_item['x'], placed_item['y'] + placed_item['width'], placed_item['z']\n              yield placed_item['x'], placed_item['y'], placed_item['z'] + placed_item['height']\n              \n        yield 0,0,0\n        return positions",
          "objective": 24.85,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "The algorithm prioritizes filling existing trucks using a \"best-fit\" approach, evaluating all orientations and positions of each available item to minimize remaining space in the current truck or create a new truck if no suitable fit is found.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n        # {The algorithm prioritizes filling existing trucks using a \"best-fit\" approach, evaluating all orientations and positions of each available item to minimize remaining space in the current truck or create a new truck if no suitable fit is found.}\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):        \n        best_placement = None\n        best_truck_index = -1\n        min_remaining_volume = float('inf')\n\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                for truck_index in range(-1, len(trucks_in_use)):\n                    if truck_index == -1:\n                        occupied_volumes = []\n                    else:\n                        occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n                    placement = self._find_placement_in_truck(item_type, item_index, truck_type, occupied_volumes)\n\n                    if placement:\n                        px, py, pz, orientation = placement\n                        l, w, h = self._get_orientations(item_type)[orientation][1]\n                        \n                        if truck_index == -1:\n                            remaining_volume = truck_type[0] * truck_type[1] * truck_type[2] - l * w * h\n                        else:\n                            truck = trucks_in_use[truck_index]\n                            new_volumes = truck['occupied_volumes'] + [{'item_type_id': item_type['item_id'], 'x': px, 'y': py, 'z': pz, 'length': l, 'width': w, 'height': h}]\n                            used_volume = sum(vol['length'] * vol['width'] * vol['height'] for vol in new_volumes)\n                            remaining_volume = truck_type[0] * truck_type[1] * truck_type[2] - used_volume\n\n                        if remaining_volume < min_remaining_volume:\n                            min_remaining_volume = remaining_volume\n                            best_truck_index = truck_index\n                            best_placement = (item_index, px, py, pz, orientation)\n\n        if best_placement:\n            item_index, x, y, z, orientation = best_placement\n            return best_truck_index, item_index, x, y, z, orientation\n        else:\n            return -1, 0, 0, 0, 0, 0\n\n    def _find_placement_in_truck(self, item_type, item_index, truck_dims, occupied_volumes):\n        for orientation_index, (orientation_id, (length, width, height)) in enumerate(self._get_orientations(item_type)):\n            positions = self._generate_candidate_positions(truck_dims, length, width, height, occupied_volumes)\n            \n            for pos_x, pos_y, pos_z in positions:\n                if self._is_valid_placement((pos_x, pos_y, pos_z), (length, width, height), truck_dims, occupied_volumes):\n                    return pos_x, pos_y, pos_z, orientation_index\n        return None\n    \n    def _generate_candidate_positions(self, truck_dims, length, width, height, occupied_volumes):\n        positions = set()\n        positions.add((0.0, 0.0, 0.0))\n        \n        for item in occupied_volumes:\n            positions.add((item['x'] + item['length'], item['y'], item['z']))\n            positions.add((item['x'], item['y'] + item['width'], item['z']))\n            positions.add((item['x'], item['y'], item['z'] + item['height']))\n            \n            positions.add((item['x'] + item['length'] - length if item['x'] + item['length'] - length >= 0 else 0, item['y'], item['z']))\n            positions.add((item['x'], item['y'] + item['width'] - width if item['y'] + item['width'] - width >= 0 else 0, item['z']))\n            positions.add((item['x'], item['y'], item['z'] + item['height'] - height if item['z'] + item['height'] - height >= 0 else 0))\n\n        \n        valid_positions = []\n        for x, y, z in positions:\n            if (x >= 0 and x + length <= truck_dims[0] and\n                y >= 0 and y + width <= truck_dims[1] and\n                z >= 0 and z + height <= truck_dims[2]):\n                valid_positions.append((x, y, z))\n        \n        return valid_positions",
          "objective": 24.9,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Select an item randomly, then find the lowest available z-coordinate for each orientation at each possible x and y coordinate, and place the item if a valid position is found, otherwise, try a new truck.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n        # {Select an item randomly, then find the lowest available z-coordinate for each orientation at each possible x and y coordinate, and place the item if a valid position is found, otherwise, try a new truck.}\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n    \n    def _select_item(self, unplaced_items):\n        available_items = [i for i, item in enumerate(unplaced_items) if item['quantity'] > 0]\n        if not available_items:\n            return -1\n        return np.random.choice(available_items)\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n\n        if item_index == -1:\n            return -1, -1, -1, -1, -1, -1\n        \n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            x, y, z, orientation = self._find_placement_in_truck(item_type, truck['occupied_volumes'], truck_type)\n            if x != -1:\n                return truck_index, item_index, x, y, z, orientation\n        \n        x, y, z, orientation = self._find_placement_new_truck(item_type, truck_type)\n        if x != -1:\n            return -1, item_index, x, y, z, orientation\n\n        return -1, -1, -1, -1, -1, -1\n\n    def _find_placement_in_truck(self, item_type, occupied_volumes, truck_type):\n        for orientation, dims in self._get_orientations(item_type):\n            length, width, height = dims\n            max_x = truck_type[0] - length + self.epsilon\n            max_y = truck_type[1] - width + self.epsilon\n            \n            x_values = np.arange(0, max_x, 1)\n            y_values = np.arange(0, max_y, 1)\n\n            if not x_values.size or not y_values.size:\n                continue\n                            \n            for x in x_values:\n                for y in y_values:\n                    z = self._calculate_lowest_z(occupied_volumes, x, y, length, width)\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                        return x, y, z, orientation\n        return -1, -1, -1, -1\n\n    def _calculate_lowest_z(self, occupied_volumes, x, y, length, width):\n        z = 0\n        for placed_item in occupied_volumes:\n            placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n            placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n            if (x < placed_item_pos[0] + placed_item_dims[0] and x + length > placed_item_pos[0] and\n                    y < placed_item_pos[1] + placed_item_dims[1] and y + width > placed_item_pos[1]):\n                z = max(z, placed_item_pos[2] + placed_item_dims[2])\n        return z\n\n    def _find_placement_new_truck(self, item_type, truck_type):\n        occupied_volumes = []\n        for orientation, dims in self._get_orientations(item_type):\n            length, width, height = dims\n            if self._is_valid_placement((0, 0, 0), (length, width, height), truck_type, occupied_volumes):\n                return 0, 0, 0, orientation\n        return -1, -1, -1, -1\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_placement_in_truck(self, item_type, occupied_volumes, truck_type):\n        for orientation, dims in self._get_orientations(item_type):\n            length, width, height = dims\n            max_x = truck_type[0] - length + self.epsilon\n            max_y = truck_type[1] - width + self.epsilon\n            \n            x_values = np.arange(0, max_x, 1)\n            y_values = np.arange(0, max_y, 1)\n\n            if not x_values.size or not y_values.size:\n                continue\n                            \n            for x in x_values:\n                for y in y_values:\n                    z = self._calculate_lowest_z(occupied_volumes, x, y, length, width)\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                        return int(x), int(y), int(z), int(orientation)\n        return -1, -1, -1, -1\n\n    def _find_placement_new_truck(self, item_type, truck_type):\n        occupied_volumes = []\n        for orientation, dims in self._get_orientations(item_type):\n            length, width, height = dims\n            if self._is_valid_placement((0, 0, 0), (length, width, height), truck_type, occupied_volumes):\n                return 0, 0, 0, int(orientation)\n        return -1, -1, -1, -1\nimport numpy as np\n\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n\n        if item_index == -1:\n            return -1, -1, -1, -1, -1, -1\n        \n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            x, y, z, orientation = self._find_placement_in_truck(item_type, truck['occupied_volumes'], truck_type)\n            if x != -1:\n                return int(truck_index), int(item_index), int(x), int(y), int(z), int(orientation)\n        \n        x, y, z, orientation = self._find_placement_new_truck(item_type, truck_type)\n        if x != -1:\n            return -1, int(item_index), int(x), int(y), int(z), int(orientation)\n\n        return -1, -1, -1, -1, -1, -1",
          "objective": 25.15,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     },
     {
          "algorithm": "Iteratively place items by selecting the item that best fills the largest void space in existing trucks or a new truck, prioritizing stability and minimizing wasted space via a void-filling heuristic.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Iteratively place items by selecting the item that best fills the largest void space in existing trucks or a new truck, prioritizing stability and minimizing wasted space via a void-filling heuristic.}\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_void_fill(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_void_fill(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x, best_y, best_z = -1, -1, -1\n        best_orientation = -1\n        best_score = -1.0\n\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                for truck_index in range(-1, len(trucks_in_use)):\n                    if truck_index == -1:\n                        occupied_volumes = []\n                    else:\n                        occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n                    x, y, z, orientation, score = self._find_best_fit_in_void(item_type, truck_type, occupied_volumes)\n                    if x != -1 and score > best_score:\n                        best_truck_index = truck_index\n                        best_item_index = item_index\n                        best_x, best_y, best_z = x, y, z\n                        best_orientation = orientation\n                        best_score = score\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_fit_in_void(self, item_type, truck_type, occupied_volumes):\n        best_x, best_y, best_z = -1, -1, -1\n        best_orientation = -1\n        best_score = -1.0\n\n        voids = self._find_void_spaces(truck_type, occupied_volumes)\n\n        for orientation, dims in self._get_orientations(item_type):\n            length, width, height = dims\n\n            for void in voids:\n                vx_start, vy_start, vz_start, vx_end, vy_end, vz_end = void\n                \n                max_x = min(vx_end, truck_type[0]) - length\n                max_y = min(vy_end, truck_type[1]) - width\n                max_z = min(vz_end, truck_type[2]) - height\n\n                if max_x < vx_start or max_y < vy_start or max_z < vz_start:\n                    continue\n\n                x_values = [vx_start]\n                y_values = [vy_start]\n                z_values = [vz_start]\n\n                for x in x_values:\n                    for y in y_values:\n                        for z in z_values:\n                            if x + length <= min(vx_end, truck_type[0]) and y + width <= min(vy_end, truck_type[1]) and z + height <= min(vz_end, truck_type[2]):\n                                if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                                    score = self._evaluate_void_fill((x, y, z), (length, width, height), void)\n                                    if score > best_score:\n                                        best_x, best_y, best_z = x, y, z\n                                        best_orientation = orientation\n                                        best_score = score\n\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_void_spaces(self, truck_dims, occupied_volumes):\n        voids = [(0, 0, 0, truck_dims[0], truck_dims[1], truck_dims[2])]\n        for item in occupied_volumes:\n            item_x, item_y, item_z = item['x'], item['y'], item['z']\n            item_l, item_w, item_h = item['length'], item['width'], item['height']\n            \n            new_voids = []\n            for vx_start, vy_start, vz_start, vx_end, vy_end, vz_end in voids:\n                \n                if item_x < vx_end and item_x + item_l > vx_start and \\\n                   item_y < vy_end and item_y + item_w > vy_start and \\\n                   item_z < vz_end and item_z + item_h > vz_start:\n                    \n                    new_voids_from_split = self._split_void((vx_start, vy_start, vz_start, vx_end, vy_end, vz_end), (item_x, item_y, item_z, item_l, item_w, item_h))\n                    new_voids.extend(new_voids_from_split)\n                else:\n                    new_voids.append((vx_start, vy_start, vz_start, vx_end, vy_end, vz_end))\n            voids = new_voids\n\n        return voids\n\n    def _split_void(self, void, item):\n        vx_start, vy_start, vz_start, vx_end, vy_end, vz_end = void\n        ix, iy, iz, il, iw, ih = item\n        \n        new_voids = []\n\n        if ix > vx_start:\n            new_voids.append((vx_start, vy_start, vz_start, ix, vy_end, vz_end))\n        if ix + il < vx_end:\n            new_voids.append((ix + il, vy_start, vz_start, vx_end, vy_end, vz_end))\n        \n        if iy > vy_start:\n            new_voids.append((max(vx_start, ix), vy_start, vz_start, min(vx_end, ix + il), iy, vz_end))\n        if iy + iw < vy_end:\n            new_voids.append((max(vx_start, ix), iy + iw, vz_start, min(vx_end, ix + il), vy_end, vz_end))\n\n        if iz > vz_start:\n            new_voids.append((max(vx_start, ix), max(vy_start, iy), vz_start, min(vx_end, ix + il), min(vy_end, iy + iw), iz))\n        if iz + ih < vz_end:\n            new_voids.append((max(vx_start, ix), max(vy_start, iy), iz + ih, min(vx_end, ix + il), min(vy_end, iy + iw), vz_end))\n\n        return new_voids\n\n    def _evaluate_void_fill(self, item_pos, item_dims, void):\n        ix, iy, iz = item_pos\n        il, iw, ih = item_dims\n        vx_start, vy_start, vz_start, vx_end, vy_end, vz_end = void\n\n        item_volume = il * iw * ih\n        void_volume = (vx_end - vx_start) * (vy_end - vy_start) * (vz_end - vz_start)\n        \n        filled_volume = min(il, vx_end - ix) * min(iw, vy_end - iy) * min(ih, vz_end - iz)\n\n        return filled_volume / void_volume",
          "objective": 25.45,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]