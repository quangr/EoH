[
     {
          "algorithm": "This algorithm prioritizes filling trucks by volume utilization, placing items based on a volume-to-quantity ratio, and uses a best-fit approach considering multiple criteria.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes filling trucks by volume utilization, placing items based on a volume-to-quantity ratio, and uses a best-fit approach considering multiple criteria.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        best_score = -1\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                quantity = item['quantity']\n                score = volume / quantity if quantity > 0 else 0\n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_placement_score = -1\n\n        for truck_index in range(len(trucks_in_use)):\n            x, y, z, orientation, placement_score = self._find_placement_in_truck(unplaced_items, trucks_in_use, truck_type, item_index, truck_index)\n            if x is not None and placement_score > best_placement_score:\n                best_placement_score = placement_score\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        x, y, z, orientation, placement_score = self._find_placement_in_truck(unplaced_items, trucks_in_use, truck_type, item_index, -1)\n        if x is not None and placement_score > best_placement_score:\n            best_truck_index = -1\n            best_x = x\n            best_y = y\n            best_z = z\n            best_orientation = orientation\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_placement_in_truck(self, unplaced_items, trucks_in_use, truck_type, item_index, truck_index):\n        item_type = unplaced_items[item_index]\n        container_dims = truck_type\n        occupied_volumes = []\n        if truck_index != -1:\n            occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n        best_x, best_y, best_z, best_orientation = None, None, None, None\n        best_placement_score = -1\n\n        for orientation_index, (orientation_id, item_dims) in enumerate(orientations):\n            L, W, H = item_dims\n            positions = self._generate_potential_positions(container_dims, L, W, H, occupied_volumes)\n            for px, py, pz in positions:\n                if self._is_valid_placement((px, py, pz), (L, W, H), container_dims, occupied_volumes):\n                    placement_score = self._evaluate_placement(container_dims, occupied_volumes, (px, py, pz), (L, W, H))\n                    if placement_score > best_placement_score:\n                        best_placement_score = placement_score\n                        best_x = px\n                        best_y = py\n                        best_z = pz\n                        best_orientation = orientation_id\n        return best_x, best_y, best_z, best_orientation, best_placement_score\n\n    def _generate_potential_positions(self, container_dims, L, W, H, occupied_volumes):\n        positions = set()\n        cl, cw, ch = container_dims\n        for item in occupied_volumes:\n            positions.add((item['x'] + item['length'], item['y'], item['z']))\n            positions.add((item['x'], item['y'] + item['width'], item['z']))\n            positions.add((item['x'], item['y'], item['z'] + item['height']))\n        positions.add((0, 0, 0))\n        valid_positions = []\n        for x, y, z in positions:\n            if (x + L <= cl + self.epsilon and\n                y + W <= cw + self.epsilon and\n                z + H <= ch + self.epsilon):\n                 valid_positions.append((x, y, z))\n        return valid_positions\n\n    def _evaluate_placement(self, container_dims, occupied_volumes, item_pos, item_dims):\n        volume_utilization = self._calculate_volume_utilization(container_dims, occupied_volumes, item_pos, item_dims)\n        height_score = 1 - (item_pos[2] + item_dims[2]) / container_dims[2]\n        num_supports = self._calculate_num_supports(item_pos, item_dims, occupied_volumes)\n        return 0.6 * volume_utilization + 0.2 * height_score + 0.2 * num_supports\n\n    def _calculate_volume_utilization(self, container_dims, occupied_volumes, item_pos, item_dims):\n        container_volume = container_dims[0] * container_dims[1] * container_dims[2]\n        new_item_volume = item_dims[0] * item_dims[1] * item_dims[2]\n        occupied_volume = 0\n        for item in occupied_volumes:\n            occupied_volume += item['length'] * item['width'] * item['height']\n        return (occupied_volume + new_item_volume) / container_volume\n\n    def _calculate_num_supports(self, item_pos, item_dims, occupied_volumes):\n        px, py, pz = item_pos\n        pl, pw, _ = item_dims\n        num_supports = 0\n        for placed_item in occupied_volumes:\n            placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n            placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n            if abs((placed_item_pos[2] + placed_item_dims[2]) - pz) < self.epsilon:\n                overlap_x = max(0, min(px + pl, placed_item_pos[0] + placed_item_dims[0]) - max(px, placed_item_pos[0]))\n                overlap_y = max(0, min(py + pw, placed_item_pos[1] + placed_item_dims[1]) - max(py, placed_item_pos[1]))\n                if overlap_x > 0 and overlap_y > 0:\n                    num_supports += 1\n        return num_supports",
          "objective": 21.95,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm prioritizes placing items by minimizing the remaining space in the truck and favoring lower placement heights.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes placing items by minimizing the remaining space in the truck and favoring lower placement heights.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items, truck_type, trucks_in_use)\n        if item_index is None:\n            return None, None, None, None, None, None\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items, truck_type, trucks_in_use):\n        best_item_index = None\n        best_score = -1\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                score = self._evaluate_item(item, truck_type, trucks_in_use)\n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n        return best_item_index\n\n    def _evaluate_item(self, item, truck_type, trucks_in_use):\n        volume = item['length'] * item['width'] * item['height']\n        return volume\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_score = -1\n\n        for truck_index in range(len(trucks_in_use)):\n            x, y, z, orientation, score = self._find_placement_in_truck(unplaced_items, trucks_in_use, truck_type, item_index, truck_index)\n            if x is not None and score > best_score:\n                best_score = score\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        x, y, z, orientation, score = self._find_placement_in_truck(unplaced_items, trucks_in_use, truck_type, item_index, -1)\n        if x is not None and score > best_score:\n            best_truck_index = -1\n            best_x = x\n            best_y = y\n            best_z = z\n            best_orientation = orientation\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_placement_in_truck(self, unplaced_items, trucks_in_use, truck_type, item_index, truck_index):\n        item_type = unplaced_items[item_index]\n        container_dims = truck_type\n        occupied_volumes = []\n        if truck_index != -1:\n            occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n        best_x, best_y, best_z, best_orientation = None, None, None, None\n        best_score = -1\n        for orientation_index, (orientation_id, item_dims) in enumerate(orientations):\n            L, W, H = item_dims\n            positions = self._generate_potential_positions(container_dims, L, W, H, occupied_volumes)\n            for px, py, pz in positions:\n                if self._is_valid_placement((px, py, pz), (L, W, H), container_dims, occupied_volumes):\n                    score = self._calculate_placement_score(container_dims, occupied_volumes, (px, py, pz), (L, W, H))\n                    if score > best_score:\n                        best_score = score\n                        best_x = px\n                        best_y = py\n                        best_z = pz\n                        best_orientation = orientation_id\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _generate_potential_positions(self, container_dims, L, W, H, occupied_volumes):\n        positions = set()\n        cl, cw, ch = container_dims\n        if not occupied_volumes:\n            return [(0,0,0)]\n        for item in occupied_volumes:\n            positions.add((item['x'] + item['length'], item['y'], item['z']))\n            positions.add((item['x'], item['y'] + item['width'], item['z']))\n            positions.add((item['x'], item['y'], item['z'] + item['height']))\n        positions.add((0, 0, 0))\n        valid_positions = []\n        for x, y, z in positions:\n            if (x + L <= cl + self.epsilon and\n                y + W <= cw + self.epsilon and\n                z + H <= ch + self.epsilon):\n                 valid_positions.append((x, y, z))\n        return valid_positions\n\n    def _calculate_placement_score(self, container_dims, occupied_volumes, item_pos, item_dims):\n        space_utilization = self._calculate_space_utilization(container_dims, occupied_volumes, item_pos, item_dims)\n        height_factor = 1 - (item_pos[2] + item_dims[2]) / container_dims[2]\n        return 0.8 * space_utilization + 0.2 * height_factor\n\n    def _calculate_space_utilization(self, container_dims, occupied_volumes, item_pos, item_dims):\n        total_volume = container_dims[0] * container_dims[1] * container_dims[2]\n        occupied_volume = 0\n        for item in occupied_volumes:\n            occupied_volume += item['length'] * item['width'] * item['height']\n        occupied_volume += item_dims[0] * item_dims[1] * item_dims[2]\n        return occupied_volume / total_volume",
          "objective": 22.2,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm prioritizes filling trucks by area utilization, placing larger items first, and explores best-fit positioning within each truck and available orientations.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes filling trucks by area utilization, placing larger items first, and explores best-fit positioning within each truck and available orientations.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        best_area = -1\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                area = item['length'] * item['width']\n                if area > best_area:\n                    best_area = area\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        max_area_utilization = -1\n\n        for truck_index in range(len(trucks_in_use)):\n            x, y, z, orientation, area_utilization = self._find_placement_in_truck(unplaced_items, trucks_in_use, truck_type, item_index, truck_index)\n            if x is not None and area_utilization > max_area_utilization:\n                max_area_utilization = area_utilization\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        x, y, z, orientation, area_utilization = self._find_placement_in_truck(unplaced_items, trucks_in_use, truck_type, item_index, -1)\n        if x is not None and area_utilization > max_area_utilization:\n            best_truck_index = -1\n            best_x = x\n            best_y = y\n            best_z = z\n            best_orientation = orientation\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_placement_in_truck(self, unplaced_items, trucks_in_use, truck_type, item_index, truck_index):\n        item_type = unplaced_items[item_index]\n        container_dims = truck_type\n        occupied_volumes = []\n        if truck_index != -1:\n            occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n        best_x, best_y, best_z, best_orientation = None, None, None, None\n        max_area_utilization = -1\n        for orientation_index, (orientation_id, item_dims) in enumerate(orientations):\n            L, W, H = item_dims\n            positions = self._generate_potential_positions(container_dims, L, W, H, occupied_volumes)\n            for px, py, pz in positions:\n                if self._is_valid_placement((px, py, pz), (L, W, H), container_dims, occupied_volumes):\n                    area_utilization = self._calculate_area_utilization(container_dims, occupied_volumes, (px, py, pz), (L, W, H))\n                    if area_utilization > max_area_utilization:\n                        max_area_utilization = area_utilization\n                        best_x = px\n                        best_y = py\n                        best_z = pz\n                        best_orientation = orientation_id\n        return best_x, best_y, best_z, best_orientation, max_area_utilization\n\n    def _generate_potential_positions(self, container_dims, L, W, H, occupied_volumes):\n        positions = set()\n        cl, cw, ch = container_dims\n        for item in occupied_volumes:\n            positions.add((item['x'] + item['length'], item['y'], item['z']))\n            positions.add((item['x'], item['y'] + item['width'], item['z']))\n            positions.add((item['x'], item['y'], item['z'] + item['height']))\n        positions.add((0, 0, 0))\n        valid_positions = []\n        for x, y, z in positions:\n            if (x + L <= cl + self.epsilon and\n                y + W <= cw + self.epsilon and\n                z + H <= ch + self.epsilon):\n                 valid_positions.append((x, y, z))\n        return valid_positions\n\n    def _calculate_area_utilization(self, container_dims, occupied_volumes, item_pos, item_dims):\n        total_area = container_dims[0] * container_dims[1]\n        occupied_area = 0\n        for item in occupied_volumes:\n            occupied_area += item['length'] * item['width']\n        occupied_area += item_dims[0] * item_dims[1]\n        return occupied_area / total_area",
          "objective": 22.55,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm prioritizes filling trucks minimizing wasted space by selecting items based on a volume-based score and evaluating placements using a combined space utilization and height factor.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes filling trucks minimizing wasted space by selecting items based on a volume-based score and evaluating placements using a combined space utilization and height factor.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        best_volume = -1\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > best_volume:\n                    best_volume = volume\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_score = -1\n\n        for truck_index in range(len(trucks_in_use)):\n            x, y, z, orientation, score = self._find_placement_in_truck(unplaced_items, trucks_in_use, truck_type, item_index, truck_index)\n            if x is not None and score > best_score:\n                best_score = score\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        x, y, z, orientation, score = self._find_placement_in_truck(unplaced_items, trucks_in_use, truck_type, item_index, -1)\n        if x is not None and score > best_score:\n            best_truck_index = -1\n            best_x = x\n            best_y = y\n            best_z = z\n            best_orientation = orientation\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_placement_in_truck(self, unplaced_items, trucks_in_use, truck_type, item_index, truck_index):\n        item_type = unplaced_items[item_index]\n        container_dims = truck_type\n        occupied_volumes = []\n        if truck_index != -1:\n            occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n        best_x, best_y, best_z, best_orientation = None, None, None, None\n        best_score = -1\n        for orientation_index, (orientation_id, item_dims) in enumerate(orientations):\n            L, W, H = item_dims\n            positions = self._generate_potential_positions(container_dims, L, W, H, occupied_volumes)\n            for px, py, pz in positions:\n                if self._is_valid_placement((px, py, pz), (L, W, H), container_dims, occupied_volumes):\n                    score = self._calculate_placement_score(container_dims, occupied_volumes, (px, py, pz), (L, W, H))\n                    if score > best_score:\n                        best_score = score\n                        best_x = px\n                        best_y = py\n                        best_z = pz\n                        best_orientation = orientation_id\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _generate_potential_positions(self, container_dims, L, W, H, occupied_volumes):\n        positions = set()\n        cl, cw, ch = container_dims\n        for item in occupied_volumes:\n            positions.add((item['x'] + item['length'], item['y'], item['z']))\n            positions.add((item['x'], item['y'] + item['width'], item['z']))\n            positions.add((item['x'], item['y'], item['z'] + item['height']))\n        positions.add((0, 0, 0))\n        valid_positions = []\n        for x, y, z in positions:\n            if (x + L <= cl + self.epsilon and\n                y + W <= cw + self.epsilon and\n                z + H <= ch + self.epsilon):\n                 valid_positions.append((x, y, z))\n        return valid_positions\n\n    def _calculate_placement_score(self, container_dims, occupied_volumes, item_pos, item_dims):\n        space_utilization = self._calculate_space_utilization(container_dims, occupied_volumes, item_pos, item_dims)\n        height_factor = 1 - (item_pos[2] + item_dims[2]) / container_dims[2]\n        return 0.7 * space_utilization + 0.3 * height_factor\n\n    def _calculate_space_utilization(self, container_dims, occupied_volumes, item_pos, item_dims):\n        total_volume = container_dims[0] * container_dims[1] * container_dims[2]\n        occupied_volume = 0\n        for item in occupied_volumes:\n            occupied_volume += item['length'] * item['width'] * item['height']\n        occupied_volume += item_dims[0] * item_dims[1] * item_dims[2]\n        return occupied_volume / total_volume",
          "objective": 24.2,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm prioritizes filling trucks by volume utilization, placing items based on a combined score of volume and aspect ratio, and selects placements that minimize wasted space around the item.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes filling trucks by volume utilization, placing items based on a combined score of volume and aspect ratio, and selects placements that minimize wasted space around the item.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        best_score = -1\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                aspect_ratio = max(item['length'], item['width'], item['height']) / min(item['length'], item['width'], item['height'])\n                score = volume / aspect_ratio\n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_wasted_space = float('inf')\n\n        for truck_index in range(len(trucks_in_use)):\n            x, y, z, orientation, wasted_space = self._find_placement_in_truck(unplaced_items, trucks_in_use, truck_type, item_index, truck_index)\n            if x is not None and wasted_space < best_wasted_space:\n                best_wasted_space = wasted_space\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        x, y, z, orientation, wasted_space = self._find_placement_in_truck(unplaced_items, trucks_in_use, truck_type, item_index, -1)\n        if x is not None and wasted_space < best_wasted_space:\n            best_truck_index = -1\n            best_x = x\n            best_y = y\n            best_z = z\n            best_orientation = orientation\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_placement_in_truck(self, unplaced_items, trucks_in_use, truck_type, item_index, truck_index):\n        item_type = unplaced_items[item_index]\n        container_dims = truck_type\n        occupied_volumes = []\n        if truck_index != -1:\n            occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n        best_x, best_y, best_z, best_orientation = None, None, None, None\n        min_wasted_space = float('inf')\n        for orientation_index, (orientation_id, item_dims) in enumerate(orientations):\n            L, W, H = item_dims\n            positions = self._generate_potential_positions(container_dims, L, W, H, occupied_volumes)\n            for px, py, pz in positions:\n                if self._is_valid_placement((px, py, pz), (L, W, H), container_dims, occupied_volumes):\n                    wasted_space = self._calculate_wasted_space(container_dims, (px, py, pz), (L, W, H))\n                    if wasted_space < min_wasted_space:\n                        min_wasted_space = wasted_space\n                        best_x = px\n                        best_y = py\n                        best_z = pz\n                        best_orientation = orientation_id\n        return best_x, best_y, best_z, best_orientation, min_wasted_space\n\n    def _generate_potential_positions(self, container_dims, L, W, H, occupied_volumes):\n        positions = set()\n        cl, cw, ch = container_dims\n        for item in occupied_volumes:\n            positions.add((item['x'] + item['length'], item['y'], item['z']))\n            positions.add((item['x'], item['y'] + item['width'], item['z']))\n            positions.add((item['x'], item['y'], item['z'] + item['height']))\n        positions.add((0, 0, 0))\n        valid_positions = []\n        for x, y, z in positions:\n            if (x + L <= cl + self.epsilon and\n                y + W <= cw + self.epsilon and\n                z + H <= ch + self.epsilon):\n                 valid_positions.append((x, y, z))\n        return valid_positions\n\n    def _calculate_wasted_space(self, container_dims, item_pos, item_dims):\n        cl, cw, ch = container_dims\n        px, py, pz = item_pos\n        L, W, H = item_dims\n        wasted_space_x = cl - (px + L)\n        wasted_space_y = cw - (py + W)\n        wasted_space_z = ch - (pz + H)\n        return wasted_space_x + wasted_space_y + wasted_space_z",
          "objective": 24.65,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]