{
     "algorithm": "This algorithm selects the item type with the largest volume and places it using a best-fit heuristic, prioritizing positions that minimize wasted space and considering all orientations.",
     "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm selects the item type with the largest volume and places it using a best-fit heuristic, prioritizing positions that minimize wasted space and considering all orientations.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n\n        best_truck_index = -1\n        best_x = 0\n        best_y = 0\n        best_z = 0\n        best_orientation = 0\n        min_waste = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            x, y, z, orientation, waste = self._find_best_position_in_truck(unplaced_items, item_index, truck['occupied_volumes'], truck_type)\n            if x is not None and waste < min_waste:\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                min_waste = waste\n\n        if best_truck_index == -1:\n            best_x, best_y, best_z, best_orientation, waste = self._find_best_position_new_truck(unplaced_items, item_index, truck_type)\n            if best_orientation is not None:\n              best_truck_index = -1\n            else:\n              return -1, -1, 0, 0, 0, 0\n            \n\n        return best_truck_index, item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        max_volume = -1\n        for i, item in enumerate(unplaced_items):\n            volume = item['length'] * item['width'] * item['height']\n            if volume > max_volume and item['quantity'] > 0:\n                max_volume = volume\n                best_item_index = i\n        return best_item_index\n\n    def _find_best_position_in_truck(self, unplaced_items, item_index, occupied_volumes, truck_type):\n        item_type = unplaced_items[item_index]\n        orientations = self._get_orientations(item_type)\n\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        min_waste = float('inf')\n\n        for orientation_index, (L, W, H) in orientations:\n            x, y, z, waste = self._find_position_with_waste(item_type, (L, W, H), occupied_volumes, truck_type)\n            if x is not None and waste < min_waste:\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation_index\n                min_waste = waste\n\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _find_best_position_new_truck(self, unplaced_items, item_index, truck_type):\n        item_type = unplaced_items[item_index]\n        orientations = self._get_orientations(item_type)\n\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        min_waste = float('inf')\n\n        for orientation_index, (L, W, H) in orientations:\n            if self._is_within_container_bounds((0, 0, 0), (L, W, H), truck_type):\n                waste = self._calculate_waste((0,0,0),(L,W,H),[],truck_type)\n                if waste < min_waste:\n                  best_x = 0\n                  best_y = 0\n                  best_z = 0\n                  best_orientation = orientation_index\n                  min_waste = waste\n\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _find_position_with_waste(self, item_type, item_dims, occupied_volumes, truck_type):\n        L, W, H = item_dims\n        tl, tw, th = truck_type\n\n        best_x = None\n        best_y = None\n        best_z = None\n        min_waste = float('inf')\n\n        for x in np.arange(0, tl - L + self.epsilon, 1):\n            for y in np.arange(0, tw - W + self.epsilon, 1):\n                for z in np.arange(0, th - H + self.epsilon, 1):\n                    x, y, z = round(x, 6), round(y, 6), round(z, 6)\n                    if self._is_valid_placement((x,y,z), (L, W, H), truck_type, occupied_volumes):\n                        waste = self._calculate_waste((x, y, z), (L, W, H), occupied_volumes, truck_type)\n                        if waste < min_waste:\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            min_waste = waste\n\n        return best_x, best_y, best_z, min_waste\n\n    def _calculate_waste(self, item_pos, item_dims, occupied_volumes, truck_dims):\n        px, py, pz = item_pos\n        pl, pw, ph = item_dims\n        tl, tw, th = truck_dims\n\n        total_waste = 0\n        # Waste above\n        total_waste += pl * pw * (tl - pl) * (tw-pw) * (th - ph)\n        return total_waste\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_position_with_waste(self, item_type, item_dims, occupied_volumes, truck_type):\n        L, W, H = item_dims\n        tl, tw, th = truck_type\n\n        best_x = None\n        best_y = None\n        best_z = None\n        min_waste = float('inf')\n\n        step_size = max(L, W, H) / 2.0\n        step_size = min(step_size, 5.0)\n\n        for x in np.arange(0, tl - L + self.epsilon, step_size):\n            for y in np.arange(0, tw - W + self.epsilon, step_size):\n                for z in np.arange(0, th - H + self.epsilon, step_size):\n                    x, y, z = round(x, 6), round(y, 6), round(z, 6)\n                    if self._is_valid_placement((x,y,z), (L, W, H), truck_type, occupied_volumes):\n                        waste = self._calculate_waste((x, y, z), (L, W, H), occupied_volumes, truck_type)\n                        if waste < min_waste:\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            min_waste = waste\n\n        return best_x, best_y, best_z, min_waste\nimport numpy as np\n\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_position_with_waste(self, item_type, item_dims, occupied_volumes, truck_type):\n        L, W, H = item_dims\n        tl, tw, th = truck_type\n\n        best_x = None\n        best_y = None\n        best_z = None\n        min_waste = float('inf')\n\n        \n        positions = []\n        if not occupied_volumes:\n            positions.append((0, 0, 0))\n        else:\n            for placed_item in occupied_volumes:\n                px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n                pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n\n                positions.append((px + pl, py, pz))\n                positions.append((px, py + pw, pz))\n                positions.append((px, py, pz + ph))\n\n        for x, y, z in positions:\n            x, y, z = round(x, 6), round(y, 6), round(z, 6)\n            if self._is_valid_placement((x,y,z), (L, W, H), truck_type, occupied_volumes):\n                waste = self._calculate_waste((x, y, z), (L, W, H), occupied_volumes, truck_type)\n                if waste < min_waste:\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    min_waste = waste\n\n        return best_x, best_y, best_z, min_waste",
     "objective": 23.95,
     "other_inf": null,
     "class_name": "AlgorithmFIX2"
}