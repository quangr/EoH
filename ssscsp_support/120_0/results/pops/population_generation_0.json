[
     {
          "algorithm": "This algorithm iterates through items, tries different orientations and positions in existing trucks based on a best-fit heuristic, falling back to a new truck if no placements are possible.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm iterates through items, tries different orientations and positions in existing trucks based on a best-fit heuristic, falling back to a new truck if no placements are possible.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def _select_item(self, unplaced_items):\n        # Selects the item type with the largest volume to pack first.\n        if not unplaced_items:\n            return None\n        \n        best_item_index = 0\n        best_item_volume = 0\n        \n        for i, item in enumerate(unplaced_items):\n            volume = item['length'] * item['width'] * item['height']\n            if volume > best_item_volume:\n                best_item_volume = volume\n                best_item_index = i\n        return best_item_index\n\n    def _find_best_position(self, item_dims, truck, truck_type):\n        # Finds the best position for an item in a truck based on a bottom-left-fill heuristic.\n        best_position = None\n        truck_length, truck_width, truck_height = truck_type\n        \n        # Iterate through potential positions in the truck\n        potential_positions = []\n\n        occupied_volumes = truck['occupied_volumes']\n        if not occupied_volumes:\n          potential_positions.append((0,0,0))\n        else:\n          for item in occupied_volumes:\n            potential_positions.append((item['x'] + item['length'], item['y'], item['z']))\n            potential_positions.append((item['x'], item['y'] + item['width'], item['z']))\n            potential_positions.append((item['x'], item['y'], item['z'] + item['height']))\n\n        for px, py, pz in potential_positions:\n            position = (px, py, pz)\n            if self._is_valid_placement(position, item_dims, truck_type, occupied_volumes):                               \n                return position\n\n        return None\n\n    def _evaluate_placement(self, position, item_dims, truck_type):\n          #Placeholder for future use\n          return 0\n          \n    def _find_placement_in_truck(self, item_type, truck, truck_index, truck_type):\n        # Tries to find a valid placement for an item in a given truck.\n        \n        for orientation_index, item_dims in self._get_orientations(item_type):\n            position = self._find_best_position(item_dims, truck, truck_type)\n\n            if position:\n                x, y, z = position\n                return truck_index, x, y, z, orientation_index, item_dims\n        return None, None, None, None, None, None\n        \n    def _create_new_truck(self, item_type, truck_type):\n        # Creates a new truck and attempts to place the item in it.\n        for orientation_index, item_dims in self._get_orientations(item_type):\n            if self._is_valid_placement((0, 0, 0), item_dims, truck_type, []):\n                return -1, 0, 0, 0, orientation_index, item_dims\n        return None, None, None, None, None, None\n        \n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return -1, 0, 0, 0, 0 , 0\n\n        item_type = unplaced_items[item_index]\n        \n        # Try placing the item in existing trucks\n        for truck_index, truck in enumerate(trucks_in_use):\n            truck_index_r, x, y, z, orientation, item_dims = self._find_placement_in_truck(item_type, truck, truck_index, truck_type)\n            if truck_index_r is not None:\n                return truck_index_r, item_index, x, y, z, orientation\n\n        # If no placement in existing trucks, create a new truck\n        truck_index_r, x, y, z, orientation, item_dims = self._create_new_truck(item_type, truck_type)\n\n        if truck_index_r is not None:\n            return truck_index_r, item_index, x, y, z, orientation\n\n        return None, None, None, None, None, None\nclass AlgorithmFIX1(Algorithm):\n    def _select_item(self, unplaced_items):\n        # Selects the item type with the largest volume to pack first, ensuring quantity > 0.\n        if not unplaced_items:\n            return None\n        \n        best_item_index = None\n        best_item_volume = 0\n        \n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > best_item_volume:\n                    best_item_volume = volume\n                    best_item_index = i\n        return best_item_index",
          "objective": 24.85,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     },
     {
          "algorithm": "The algorithm selects an item based on a scoring function, finds a valid placement for its best orientation in either an existing or new truck, and returns the placement details.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {The algorithm selects an item based on a scoring function, finds a valid placement for its best orientation in either an existing or new truck, and returns the placement details.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items, trucks_in_use, truck_type)\n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n\n        truck_index, x, y, z, orientation = self._find_best_placement(item_index, unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_item_index = None\n        best_score = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                score = self._evaluate_item(i, unplaced_items, trucks_in_use, truck_type)\n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n\n        return best_item_index\n\n    def _evaluate_item(self, item_index, unplaced_items, trucks_in_use, truck_type):\n        item = unplaced_items[item_index]\n        total_volume = item['length'] * item['width'] * item['height'] * item['quantity']\n        return total_volume\n\n    def _find_best_placement(self, item_index, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x = 0\n        best_y = 0\n        best_z = 0\n        best_orientation = 0\n        best_volume_utilization = -1\n        item = unplaced_items[item_index]\n\n        # Try placing in existing trucks\n        for truck_index in range(len(trucks_in_use)):\n            x, y, z, orientation, volume_utilization = self._find_placement_in_truck(item_index, unplaced_items, trucks_in_use, truck_type, truck_index)\n            if volume_utilization > best_volume_utilization:\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_volume_utilization = volume_utilization\n\n        # Try placing in a new truck\n        x, y, z, orientation, volume_utilization = self._find_placement_in_truck(item_index, unplaced_items, trucks_in_use, truck_type, -1)\n        if volume_utilization > best_volume_utilization:\n            best_truck_index = -1\n            best_x = x\n            best_y = y\n            best_z = z\n            best_orientation = orientation\n            best_volume_utilization = volume_utilization\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_placement_in_truck(self, item_index, unplaced_items, trucks_in_use, truck_type, truck_index):\n        best_x = 0\n        best_y = 0\n        best_z = 0\n        best_orientation = 0\n        best_volume_utilization = -1\n        item = unplaced_items[item_index]\n        container_dims = truck_type\n\n        if truck_index == -1:\n            occupied_volumes = []\n        else:\n            occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n        for orientation_index, (orientation_code, item_dims) in enumerate(self._get_orientations(item)):\n            length, width, height = item_dims\n\n            # Iterate over potential placement positions in the truck\n            if truck_index == -1:\n                positions = [(0, 0, 0)]\n            else:\n                positions = self._generate_potential_positions(occupied_volumes, container_dims, length, width, height)\n\n            for x, y, z in positions:\n                if self._is_valid_placement((x, y, z), (length, width, height), container_dims, occupied_volumes):\n                    volume_utilization = self._calculate_volume_utilization((x, y, z), (length, width, height), container_dims)\n\n                    if volume_utilization > best_volume_utilization:\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n                        best_volume_utilization = volume_utilization\n\n        return best_x, best_y, best_z, best_orientation, best_volume_utilization\n\n    def _generate_potential_positions(self, occupied_volumes, container_dims, item_length, item_width, item_height):\n        positions = [(0, 0, 0)]\n        for placed_item in occupied_volumes:\n            x = placed_item['x']\n            y = placed_item['y']\n            z = placed_item['z']\n            l = placed_item['length']\n            w = placed_item['width']\n            h = placed_item['height']\n\n            positions.append((x + l, y, z))\n            positions.append((x, y + w, z))\n            positions.append((x, y, z + h))\n\n        # Filter out positions that are clearly outside the container and close to borders.\n        filtered_positions = []\n        for px, py, pz in positions:\n            if (px + item_length <= container_dims[0] + self.epsilon and\n                py + item_width <= container_dims[1] + self.epsilon and\n                pz + item_height <= container_dims[2] + self.epsilon):\n                filtered_positions.append((px, py, pz))\n\n        return filtered_positions\n\n    def _calculate_volume_utilization(self, item_pos, item_dims, container_dims):\n        item_volume = item_dims[0] * item_dims[1] * item_dims[2]\n        container_volume = container_dims[0] * container_dims[1] * container_dims[2]\n        return item_volume / container_volume",
          "objective": 25.05,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "The algorithm prioritizes item selection by remaining quantity and attempts to place it using a bottom-left-fill heuristic, considering all orientations and existing truck configurations, or creates a new truck if necessary.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {The algorithm prioritizes item selection by remaining quantity and attempts to place it using a bottom-left-fill heuristic, considering all orientations and existing truck configurations, or creates a new truck if necessary.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_placement(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n\n        best_truck_index = -1\n        best_x = 0\n        best_y = 0\n        best_z = 0\n        best_orientation = 0\n\n        for ti, truck in enumerate(trucks_in_use):\n            x, y, z, orientation = self._find_position_in_truck(unplaced_items, item_index, truck['occupied_volumes'], truck_type)\n            if x is not None:\n                best_truck_index = ti\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                break\n\n        if best_truck_index == -1:\n            best_x, best_y, best_z, best_orientation = self._find_position_new_truck(unplaced_items, item_index, truck_type)\n\n        return best_truck_index, item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        max_quantity = -1\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > max_quantity:\n                max_quantity = item['quantity']\n                best_item_index = i\n        return best_item_index\n            \n    def _find_position_in_truck(self, unplaced_items, item_index, occupied_volumes, truck_type):\n        item_type = unplaced_items[item_index]\n        orientations = self._get_orientations(item_type)\n        \n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n\n        for orientation_index, (L, W, H) in orientations:\n            x, y, z = self._bottom_left_fill(item_type, (L, W, H), occupied_volumes, truck_type)\n            if x is not None:\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation_index\n                break\n        return best_x, best_y, best_z, best_orientation\n    \n    def _find_position_new_truck(self, unplaced_items, item_index, truck_type):\n        item_type = unplaced_items[item_index]\n        orientations = self._get_orientations(item_type)\n        \n        x = None\n        y = None\n        z = None\n        orientation_index = None\n\n        for orientation_index, (L, W, H) in orientations:\n            if self._is_within_container_bounds((0, 0, 0), (L, W, H), truck_type):\n                x = 0\n                y = 0\n                z = 0\n                break\n        \n        return x, y, z, orientation_index\n\n    def _bottom_left_fill(self, item_type, item_dims, occupied_volumes, truck_type):\n        L, W, H = item_dims\n        tl, tw, th = truck_type\n        \n        possible_positions = []\n        \n        # Check for placing at the bottom-left corner of the truck\n        if len(occupied_volumes) == 0:\n            if self._is_valid_placement((0, 0, 0), (L, W, H), truck_type, occupied_volumes):\n                return 0, 0, 0\n        \n        # Check for positions adjacent to existing items\n        for placed_item in occupied_volumes:\n            px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n            pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n            \n            # Check right side of the item\n            x, y, z = px + pl, py, pz\n            if self._is_valid_placement((x, y, z), (L, W, H), truck_type, occupied_volumes):\n                position = (x, y, z)\n                possible_positions.append(position)\n\n            # Check front of the item\n            x, y, z = px, py + pw, pz\n            if self._is_valid_placement((x, y, z), (L, W, H), truck_type, occupied_volumes):\n                position = (x, y, z)\n                possible_positions.append(position)\n            \n            # Check top of the item\n            x, y, z = px, py, pz + ph\n            if self._is_valid_placement((x, y, z), (L, W, H), truck_type, occupied_volumes):\n                position = (x, y, z)\n                possible_positions.append(position)   \n\n        if len(possible_positions) > 0:\n            best_x, best_y, best_z = possible_positions[0]\n\n            return best_x, best_y, best_z\n        else:\n            return None, None, None",
          "objective": 25.3,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "The algorithm prioritizes filling existing trucks by iterating through unplaced items, orientations, and positions, placing the first valid item and creating a new truck only if no placement is found.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {The algorithm prioritizes filling existing trucks by iterating through unplaced items, orientations, and positions, placing the first valid item and creating a new truck only if no placement is found.}\n    \n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_placement(unplaced_items, trucks_in_use, truck_type)\n        if truck_index == -2:\n            truck_index, item_index, x, y, z, orientation = self._create_new_truck_placement(unplaced_items, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n    \n    def _find_placement(self, unplaced_items, trucks_in_use, truck_type):\n        for truck_index, truck in enumerate(trucks_in_use):\n            for item_index, item_type in enumerate(unplaced_items):\n                if item_type['quantity'] > 0:\n                    x, y, z, orientation = self._find_position_for_item(item_type, truck, truck_type)\n                    if x is not None:\n                        return truck_index, item_index, x, y, z, orientation\n        return -2, None, None, None, None, None\n    \n    def _find_position_for_item(self, item_type, truck, truck_type):\n        occupied_volumes = truck['occupied_volumes']\n        for orientation_index, (orientation, (length, width, height)) in self._get_orientations(item_type):\n            possible_positions = self._generate_possible_positions(truck_type, length, width, height, occupied_volumes)\n            for x, y, z in possible_positions:\n                if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                    return x, y, z, orientation_index\n        return None, None, None, None\n    \n    def _generate_possible_positions(self, truck_type, length, width, height, occupied_volumes):\n        possible_positions = [(0, 0, 0)]\n        for item in occupied_volumes:\n            possible_positions.append((item['x'] + item['length'], item['y'], item['z']))\n            possible_positions.append((item['x'], item['y'] + item['width'], item['z']))\n            possible_positions.append((item['x'], item['y'], item['z'] + item['height']))\n        \n        cl, cw, ch = truck_type\n        filtered_positions = []\n        for x, y, z in possible_positions:\n            if (x + length <= cl + self.epsilon and\n                y + width <= cw + self.epsilon and\n                z + height <= ch + self.epsilon):\n                filtered_positions.append((x, y, z))\n        \n        return filtered_positions\n    \n    def _create_new_truck_placement(self, unplaced_items, truck_type):\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                for orientation_index, (orientation, (length, width, height)) in self._get_orientations(item_type):\n                    if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                        return -1, item_index, 0, 0, 0, orientation_index\n        return None, None, None, None, None, None\nclass AlgorithmFIX1(Algorithm):\n    def _create_new_truck_placement(self, unplaced_items, truck_type):\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                orientations = self._get_orientations(item_type)\n                for orientation_index, (orientation_id, (length, width, height)) in enumerate(orientations):\n                    if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                        return -1, item_index, 0, 0, 0, orientation_index\n        return None, None, None, None, None, None\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_position_for_item(self, item_type, truck, truck_type):\n        occupied_volumes = truck['occupied_volumes']\n        for orientation_index, (orientation_id, (length, width, height)) in enumerate(self._get_orientations(item_type)):\n            possible_positions = self._generate_possible_positions(truck_type, length, width, height, occupied_volumes)\n            for x, y, z in possible_positions:\n                if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                    return x, y, z, orientation_index\n        return None, None, None, None",
          "objective": 27.35,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     },
     {
          "algorithm": "Tries to place items using a best-fit approach, prioritizing items with larger volumes and lower z-coordinate placements, and opening new trucks only when necessary.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Tries to place items using a best-fit approach, prioritizing items with larger volumes and lower z-coordinate placements, and opening new trucks only when necessary.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_placement = None\n        best_volume = -1\n\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                for truck_index, truck in enumerate(trucks_in_use):\n                    placement = self._find_placement_in_truck(item_type, truck, truck_type)\n                    if placement:\n                        x, y, z, orientation = placement\n                        l, w, h = self._get_orientations(item_type)[orientation][1]\n                        volume = l * w * h\n\n                        if best_placement is None or z < best_placement[2] or (z == best_placement[2] and volume > best_volume):\n                            best_placement = (truck_index, item_index, x, y, z, orientation)\n                            best_volume = volume\n\n        if best_placement is None:\n            truck_index, item_index, x, y, z, orientation = self._place_in_new_truck(unplaced_items, truck_type)\n            return truck_index, item_index, x, y, z, orientation\n        else:\n            truck_index, item_index, x, y, z, orientation = best_placement\n            return truck_index, item_index, x, y, z, orientation\n\n    def _place_in_new_truck(self, unplaced_items, truck_type):\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                orientations = self._get_orientations(item_type)\n                for orientation, dims in orientations:\n                    if self._is_within_container_bounds((0.0, 0.0, 0.0), dims, truck_type):\n                        return -1, item_index, 0.0, 0.0, 0.0, orientation\n        return -1, 0, 0.0, 0.0, 0.0, 0\n\n    def _find_placement_in_truck(self, item_type, truck, truck_type):\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n        for orientation, dims in orientations:\n            x, y, z = self._find_valid_position(dims, truck_type, occupied_volumes)\n            if x is not None:\n                return x, y, z, orientation\n        return None\n\n    def _find_valid_position(self, item_dims, container_dims, occupied_volumes):\n        cl, cw, ch = container_dims\n        il, iw, ih = item_dims\n        step_size = min(il, iw, ih) / 2.0\n        \n        x = 0.0\n        while x + il <= cl + self.epsilon:\n            y = 0.0\n            while y + iw <= cw + self.epsilon:\n                z = 0.0\n                while z + ih <= ch + self.epsilon:\n                    if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                        return x, y, z\n                    z += step_size\n                y += step_size\n            x += step_size\n        return None, None, None",
          "objective": 28.3,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]