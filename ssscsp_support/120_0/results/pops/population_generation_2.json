[
     {
          "algorithm": "This algorithm prioritizes items with higher volume, tries to place them lower in the container, and selects the position with the least remaining horizontal space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes items with higher volume, tries to place them lower in the container, and selects the position with the least remaining horizontal space.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n\n        best_truck_index = -1\n        best_x = 0\n        best_y = 0\n        best_z = 0\n        best_orientation = 0\n        best_score = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            x, y, z, orientation, score = self._find_best_position_in_truck(unplaced_items, item_index, truck['occupied_volumes'], truck_type)\n            if x is not None and score < best_score:\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_score = score\n\n        if best_truck_index == -1:\n            x, y, z, orientation, score = self._find_best_position_new_truck(unplaced_items, item_index, truck_type)\n            if orientation is not None:\n                best_truck_index = -1\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_score = score\n            else:\n                return -1, -1, 0, 0, 0, 0\n\n        return best_truck_index, item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        max_volume = -1\n        for i, item in enumerate(unplaced_items):\n            volume = item['length'] * item['width'] * item['height']\n            if volume > max_volume and item['quantity'] > 0:\n                max_volume = volume\n                best_item_index = i\n        return best_item_index\n\n    def _find_best_position_in_truck(self, unplaced_items, item_index, occupied_volumes, truck_type):\n        item_type = unplaced_items[item_index]\n        orientations = self._get_orientations(item_type)\n\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_score = float('inf')\n\n        for orientation_index, (L, W, H) in orientations:\n            x, y, z, score = self._find_position_with_score(item_type, (L, W, H), occupied_volumes, truck_type)\n            if x is not None and score < best_score:\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation_index\n                best_score = score\n\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_best_position_new_truck(self, unplaced_items, item_index, truck_type):\n        item_type = unplaced_items[item_index]\n        orientations = self._get_orientations(item_type)\n\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_score = float('inf')\n\n        for orientation_index, (L, W, H) in orientations:\n            if self._is_within_container_bounds((0, 0, 0), (L, W, H), truck_type):\n                score = H\n                if score < best_score:\n                    best_x = 0\n                    best_y = 0\n                    best_z = 0\n                    best_orientation = orientation_index\n                    best_score = score\n\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_position_with_score(self, item_type, item_dims, occupied_volumes, truck_type):\n        L, W, H = item_dims\n        tl, tw, th = truck_type\n\n        best_x = None\n        best_y = None\n        best_z = None\n        best_score = float('inf')\n\n        potential_positions = []\n        if not occupied_volumes:\n            if self._is_valid_placement((0, 0, 0), (L, W, H), truck_type, occupied_volumes):\n                potential_positions.append((0,0,0))\n        else:\n            for placed_item in occupied_volumes:\n                px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n                pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n\n                possible_positions = [(px + pl, py, pz), (px, py + pw, pz), (px, py, pz + ph)]\n\n                for x, y, z in possible_positions:\n                    if self._is_valid_placement((x, y, z), (L, W, H), truck_type, occupied_volumes):\n                        potential_positions.append((x,y,z))\n\n        for x, y, z in potential_positions:\n          remaining_space = (tl - (x + L)) * (tw - (y + W))\n          score = z + remaining_space\n          if score < best_score:\n            best_x = x\n            best_y = y\n            best_z = z\n            best_score = score\n\n        return best_x, best_y, best_z, best_score",
          "objective": 22.4,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm prioritizes placing items on the floor, then tries to stack them, minimizing the height of the occupied space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes placing items on the floor, then tries to stack them, minimizing the height of the occupied space.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n\n        best_truck_index = -1\n        best_x = 0\n        best_y = 0\n        best_z = 0\n        best_orientation = 0\n        min_height = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            x, y, z, orientation, height = self._find_best_position_in_truck(unplaced_items, item_index, truck['occupied_volumes'], truck_type)\n            if x is not None and height < min_height:\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                min_height = height\n\n        if best_truck_index == -1:\n            best_x, best_y, best_z, best_orientation, height = self._find_best_position_new_truck(unplaced_items, item_index, truck_type)\n            if best_orientation is not None:\n              best_truck_index = -1\n            else:\n              return -1, -1, 0, 0, 0, 0\n\n        return best_truck_index, item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        max_area = -1\n        for i, item in enumerate(unplaced_items):\n            area = item['length'] * item['width']\n            if area > max_area and item['quantity'] > 0:\n                max_area = area\n                best_item_index = i\n        return best_item_index\n\n    def _find_best_position_in_truck(self, unplaced_items, item_index, occupied_volumes, truck_type):\n        item_type = unplaced_items[item_index]\n        orientations = self._get_orientations(item_type)\n\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        min_height = float('inf')\n\n        for orientation_index, (L, W, H) in orientations:\n            x, y, z, height = self._find_position_with_height(item_type, (L, W, H), occupied_volumes, truck_type)\n            if x is not None and height < min_height:\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation_index\n                min_height = height\n\n        return best_x, best_y, best_z, best_orientation, min_height\n\n    def _find_best_position_new_truck(self, unplaced_items, item_index, truck_type):\n        item_type = unplaced_items[item_index]\n        orientations = self._get_orientations(item_type)\n\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        min_height = float('inf')\n\n        for orientation_index, (L, W, H) in orientations:\n            if self._is_within_container_bounds((0, 0, 0), (L, W, H), truck_type):\n                height = H\n                if height < min_height:\n                  best_x = 0\n                  best_y = 0\n                  best_z = 0\n                  best_orientation = orientation_index\n                  min_height = height\n\n        return best_x, best_y, best_z, best_orientation, min_height\n\n    def _find_position_with_height(self, item_type, item_dims, occupied_volumes, truck_type):\n        L, W, H = item_dims\n        tl, tw, th = truck_type\n\n        best_x = None\n        best_y = None\n        best_z = None\n        min_height = float('inf')\n\n        if not occupied_volumes:\n          x, y, z = 0, 0, 0\n          if self._is_valid_placement((x,y,z), (L, W, H), truck_type, occupied_volumes):\n            min_height = H\n            best_x = x\n            best_y = y\n            best_z = z\n          return best_x, best_y, best_z, min_height\n\n\n        for placed_item in occupied_volumes:\n            px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n            pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n\n            x, y, z = px + pl, py, pz\n            if self._is_valid_placement((x,y,z), (L, W, H), truck_type, occupied_volumes):\n              max_z = 0\n              for occupied_item in occupied_volumes:\n                ix, iy, iz = occupied_item['x'], occupied_item['y'], occupied_item['z']\n                il, iw, ih = occupied_item['length'], occupied_item['width'], occupied_item['height']\n                if ix + il > x and ix < x + L and iy+iw > y and iy < y+W:\n                    max_z = max(max_z, iz+ih)\n\n              if z >= max_z:\n                height = H + max_z\n                if height < min_height:\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    min_height = height\n\n            x, y, z = px , py+ pw, pz\n            if self._is_valid_placement((x,y,z), (L, W, H), truck_type, occupied_volumes):\n              max_z = 0\n              for occupied_item in occupied_volumes:\n                ix, iy, iz = occupied_item['x'], occupied_item['y'], occupied_item['z']\n                il, iw, ih = occupied_item['length'], occupied_item['width'], occupied_item['height']\n                if ix + il > x and ix < x + L and iy+iw > y and iy < y+W:\n                    max_z = max(max_z, iz+ih)\n              if z >= max_z:\n                height = H + max_z\n                if height < min_height:\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    min_height = height\n\n            x, y, z = px, py, pz + ph\n            if self._is_valid_placement((x,y,z), (L, W, H), truck_type, occupied_volumes):\n              max_z = 0\n              for occupied_item in occupied_volumes:\n                ix, iy, iz = occupied_item['x'], occupied_item['y'], occupied_item['z']\n                il, iw, ih = occupied_item['length'], occupied_item['width'], occupied_item['height']\n                if ix + il > x and ix < x + L and iy+iw > y and iy < y+W:\n                    max_z = max(max_z, iz+ih)\n              if z >= max_z:\n                height = H + max_z\n                if height < min_height:\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    min_height = height\n        return best_x, best_y, best_z, min_height",
          "objective": 22.75,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm selects the item type with the largest volume and places it using a best-fit heuristic, prioritizing positions that minimize wasted space and considering all orientations.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm selects the item type with the largest volume and places it using a best-fit heuristic, prioritizing positions that minimize wasted space and considering all orientations.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n\n        best_truck_index = -1\n        best_x = 0\n        best_y = 0\n        best_z = 0\n        best_orientation = 0\n        min_waste = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            x, y, z, orientation, waste = self._find_best_position_in_truck(unplaced_items, item_index, truck['occupied_volumes'], truck_type)\n            if x is not None and waste < min_waste:\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                min_waste = waste\n\n        if best_truck_index == -1:\n            best_x, best_y, best_z, best_orientation, waste = self._find_best_position_new_truck(unplaced_items, item_index, truck_type)\n            if best_orientation is not None:\n              best_truck_index = -1\n            else:\n              return -1, -1, 0, 0, 0, 0\n            \n\n        return best_truck_index, item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        max_volume = -1\n        for i, item in enumerate(unplaced_items):\n            volume = item['length'] * item['width'] * item['height']\n            if volume > max_volume and item['quantity'] > 0:\n                max_volume = volume\n                best_item_index = i\n        return best_item_index\n\n    def _find_best_position_in_truck(self, unplaced_items, item_index, occupied_volumes, truck_type):\n        item_type = unplaced_items[item_index]\n        orientations = self._get_orientations(item_type)\n\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        min_waste = float('inf')\n\n        for orientation_index, (L, W, H) in orientations:\n            x, y, z, waste = self._find_position_with_waste(item_type, (L, W, H), occupied_volumes, truck_type)\n            if x is not None and waste < min_waste:\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation_index\n                min_waste = waste\n\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _find_best_position_new_truck(self, unplaced_items, item_index, truck_type):\n        item_type = unplaced_items[item_index]\n        orientations = self._get_orientations(item_type)\n\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        min_waste = float('inf')\n\n        for orientation_index, (L, W, H) in orientations:\n            if self._is_within_container_bounds((0, 0, 0), (L, W, H), truck_type):\n                waste = self._calculate_waste((0,0,0),(L,W,H),[],truck_type)\n                if waste < min_waste:\n                  best_x = 0\n                  best_y = 0\n                  best_z = 0\n                  best_orientation = orientation_index\n                  min_waste = waste\n\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _find_position_with_waste(self, item_type, item_dims, occupied_volumes, truck_type):\n        L, W, H = item_dims\n        tl, tw, th = truck_type\n\n        best_x = None\n        best_y = None\n        best_z = None\n        min_waste = float('inf')\n\n        for x in np.arange(0, tl - L + self.epsilon, 1):\n            for y in np.arange(0, tw - W + self.epsilon, 1):\n                for z in np.arange(0, th - H + self.epsilon, 1):\n                    x, y, z = round(x, 6), round(y, 6), round(z, 6)\n                    if self._is_valid_placement((x,y,z), (L, W, H), truck_type, occupied_volumes):\n                        waste = self._calculate_waste((x, y, z), (L, W, H), occupied_volumes, truck_type)\n                        if waste < min_waste:\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            min_waste = waste\n\n        return best_x, best_y, best_z, min_waste\n\n    def _calculate_waste(self, item_pos, item_dims, occupied_volumes, truck_dims):\n        px, py, pz = item_pos\n        pl, pw, ph = item_dims\n        tl, tw, th = truck_dims\n\n        total_waste = 0\n        # Waste above\n        total_waste += pl * pw * (tl - pl) * (tw-pw) * (th - ph)\n        return total_waste\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_position_with_waste(self, item_type, item_dims, occupied_volumes, truck_type):\n        L, W, H = item_dims\n        tl, tw, th = truck_type\n\n        best_x = None\n        best_y = None\n        best_z = None\n        min_waste = float('inf')\n\n        step_size = max(L, W, H) / 2.0\n        step_size = min(step_size, 5.0)\n\n        for x in np.arange(0, tl - L + self.epsilon, step_size):\n            for y in np.arange(0, tw - W + self.epsilon, step_size):\n                for z in np.arange(0, th - H + self.epsilon, step_size):\n                    x, y, z = round(x, 6), round(y, 6), round(z, 6)\n                    if self._is_valid_placement((x,y,z), (L, W, H), truck_type, occupied_volumes):\n                        waste = self._calculate_waste((x, y, z), (L, W, H), occupied_volumes, truck_type)\n                        if waste < min_waste:\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            min_waste = waste\n\n        return best_x, best_y, best_z, min_waste\nimport numpy as np\n\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_position_with_waste(self, item_type, item_dims, occupied_volumes, truck_type):\n        L, W, H = item_dims\n        tl, tw, th = truck_type\n\n        best_x = None\n        best_y = None\n        best_z = None\n        min_waste = float('inf')\n\n        \n        positions = []\n        if not occupied_volumes:\n            positions.append((0, 0, 0))\n        else:\n            for placed_item in occupied_volumes:\n                px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n                pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n\n                positions.append((px + pl, py, pz))\n                positions.append((px, py + pw, pz))\n                positions.append((px, py, pz + ph))\n\n        for x, y, z in positions:\n            x, y, z = round(x, 6), round(y, 6), round(z, 6)\n            if self._is_valid_placement((x,y,z), (L, W, H), truck_type, occupied_volumes):\n                waste = self._calculate_waste((x, y, z), (L, W, H), occupied_volumes, truck_type)\n                if waste < min_waste:\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    min_waste = waste\n\n        return best_x, best_y, best_z, min_waste",
          "objective": 23.95,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     },
     {
          "algorithm": "This algorithm iterates through unplaced items, selecting the item with the largest volume, attempts to place it in existing trucks using a first-fit approach based on available space, and resorts to a new truck if no suitable placement is found.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm iterates through unplaced items, selecting the item with the largest volume, attempts to place it in existing trucks using a first-fit approach based on available space, and resorts to a new truck if no suitable placement is found.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def _select_item(self, unplaced_items):\n        if not unplaced_items:\n            return None\n\n        best_item_index = None\n        max_volume = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_position_for_item(self, item_type, truck, truck_type):\n        best_position = None\n        best_orientation = None\n        best_dims = None\n        min_z = float('inf')\n\n        for orientation_index, item_dims in self._get_orientations(item_type):\n            x, y, z = self._find_first_valid_position(item_dims, truck, truck_type)\n            if x is not None:\n                if z < min_z:\n                    min_z = z\n                    best_position = (x, y, z)\n                    best_orientation = orientation_index\n                    best_dims = item_dims\n\n        if best_position:\n            return best_position[0], best_position[1], best_position[2], best_orientation, best_dims\n        else:\n            return None, None, None, None, None\n\n    def _find_first_valid_position(self, item_dims, truck, truck_type):\n        truck_length, truck_width, truck_height = truck_type\n        occupied_volumes = truck['occupied_volumes']\n\n        for z in sorted({0} | {item['z'] + item['height'] for item in occupied_volumes}):\n            for y in sorted({0} | {item['y'] + item['width'] for item in occupied_volumes}):\n                for x in sorted({0} | {item['x'] + item['length'] for item in occupied_volumes}):\n                    position = (x, y, z)\n                    if self._is_valid_placement(position, item_dims, truck_type, occupied_volumes):\n                        return x, y, z\n        return None, None, None\n\n    def _place_in_existing_trucks(self, item_type, trucks_in_use, truck_type):\n        for truck_index in range(len(trucks_in_use)):\n            truck = trucks_in_use[truck_index]\n            x, y, z, orientation, item_dims = self._find_best_position_for_item(item_type, truck, truck_type)\n            if x is not None:\n                return truck_index, x, y, z, orientation\n        return None, None, None, None, None\n\n    def _place_in_new_truck(self, item_type, truck_type):\n        best_orientation = None\n        best_dims = None\n        for orientation_index, item_dims in self._get_orientations(item_type):\n            if self._is_valid_placement((0, 0, 0), item_dims, truck_type, []):\n                best_orientation = orientation_index\n                best_dims = item_dims\n                break\n        \n        if best_orientation is not None:\n            return -1, 0, 0, 0, best_orientation\n        else:\n            return None, None, None, None, None\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n\n        if item_index is None:\n            return -1, 0, 0, 0, 0, 0\n\n        item_type = unplaced_items[item_index]\n\n        truck_index, x, y, z, orientation = self._place_in_existing_trucks(item_type, trucks_in_use, truck_type)\n\n        if truck_index is not None:\n            return truck_index, item_index, x, y, z, orientation\n\n        truck_index, x, y, z, orientation = self._place_in_new_truck(item_type, truck_type)\n\n        if truck_index is not None:\n            return truck_index, item_index, x, y, z, orientation\n            \n        return None, None, None, None, None, None",
          "objective": 24.8,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm iterates through items, tries different orientations and positions in existing trucks based on a best-fit heuristic, falling back to a new truck if no placements are possible.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm iterates through items, tries different orientations and positions in existing trucks based on a best-fit heuristic, falling back to a new truck if no placements are possible.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def _select_item(self, unplaced_items):\n        # Selects the item type with the largest volume to pack first.\n        if not unplaced_items:\n            return None\n        \n        best_item_index = 0\n        best_item_volume = 0\n        \n        for i, item in enumerate(unplaced_items):\n            volume = item['length'] * item['width'] * item['height']\n            if volume > best_item_volume:\n                best_item_volume = volume\n                best_item_index = i\n        return best_item_index\n\n    def _find_best_position(self, item_dims, truck, truck_type):\n        # Finds the best position for an item in a truck based on a bottom-left-fill heuristic.\n        best_position = None\n        truck_length, truck_width, truck_height = truck_type\n        \n        # Iterate through potential positions in the truck\n        potential_positions = []\n\n        occupied_volumes = truck['occupied_volumes']\n        if not occupied_volumes:\n          potential_positions.append((0,0,0))\n        else:\n          for item in occupied_volumes:\n            potential_positions.append((item['x'] + item['length'], item['y'], item['z']))\n            potential_positions.append((item['x'], item['y'] + item['width'], item['z']))\n            potential_positions.append((item['x'], item['y'], item['z'] + item['height']))\n\n        for px, py, pz in potential_positions:\n            position = (px, py, pz)\n            if self._is_valid_placement(position, item_dims, truck_type, occupied_volumes):                               \n                return position\n\n        return None\n\n    def _evaluate_placement(self, position, item_dims, truck_type):\n          #Placeholder for future use\n          return 0\n          \n    def _find_placement_in_truck(self, item_type, truck, truck_index, truck_type):\n        # Tries to find a valid placement for an item in a given truck.\n        \n        for orientation_index, item_dims in self._get_orientations(item_type):\n            position = self._find_best_position(item_dims, truck, truck_type)\n\n            if position:\n                x, y, z = position\n                return truck_index, x, y, z, orientation_index, item_dims\n        return None, None, None, None, None, None\n        \n    def _create_new_truck(self, item_type, truck_type):\n        # Creates a new truck and attempts to place the item in it.\n        for orientation_index, item_dims in self._get_orientations(item_type):\n            if self._is_valid_placement((0, 0, 0), item_dims, truck_type, []):\n                return -1, 0, 0, 0, orientation_index, item_dims\n        return None, None, None, None, None, None\n        \n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return -1, 0, 0, 0, 0 , 0\n\n        item_type = unplaced_items[item_index]\n        \n        # Try placing the item in existing trucks\n        for truck_index, truck in enumerate(trucks_in_use):\n            truck_index_r, x, y, z, orientation, item_dims = self._find_placement_in_truck(item_type, truck, truck_index, truck_type)\n            if truck_index_r is not None:\n                return truck_index_r, item_index, x, y, z, orientation\n\n        # If no placement in existing trucks, create a new truck\n        truck_index_r, x, y, z, orientation, item_dims = self._create_new_truck(item_type, truck_type)\n\n        if truck_index_r is not None:\n            return truck_index_r, item_index, x, y, z, orientation\n\n        return None, None, None, None, None, None\nclass AlgorithmFIX1(Algorithm):\n    def _select_item(self, unplaced_items):\n        # Selects the item type with the largest volume to pack first, ensuring quantity > 0.\n        if not unplaced_items:\n            return None\n        \n        best_item_index = None\n        best_item_volume = 0\n        \n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                if volume > best_item_volume:\n                    best_item_volume = volume\n                    best_item_index = i\n        return best_item_index",
          "objective": 24.85,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     }
]