[
     {
          "algorithm": "This algorithm selects items based on a scoring system that prioritizes items with high volume and quantity, attempts to place them into existing trucks or a new truck based on a best-fit approach, and manages space efficiently by tracking occupied volumes.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm selects items based on a scoring system that prioritizes items with high volume and quantity, attempts to place them into existing trucks or a new truck based on a best-fit approach, and manages space efficiently by tracking occupied volumes.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation, best_score = None, None, None, None, None, None, -1\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] <= 0:\n                continue\n\n            for truck_index, truck in enumerate(trucks_in_use):\n                x, y, z, orientation, score = self._find_best_position_in_truck(item, truck['occupied_volumes'], truck_type, unplaced_items)\n                if score > best_score:\n                    best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation, best_score = truck_index, item_index, x, y, z, orientation, score\n\n        if best_truck_index is None:\n            item_index, x, y, z, orientation, score = self._find_best_position_new_truck(unplaced_items, truck_type)\n            if item_index is not None:\n                return -1, item_index, x, y, z, orientation\n            else:\n                return -1, -1, 0, 0, 0, 0\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item, occupied_volumes, truck_type, unplaced_items):\n        best_x, best_y, best_z, best_orientation, best_score = None, None, None, None, -1\n        for orientation_index, (length, width, height) in self._get_orientations(item):\n            x, y, z, score = self._find_position_with_best_score(item, (length, width, height), occupied_volumes, truck_type, unplaced_items)\n            if score > best_score:\n                best_x, best_y, best_z, best_orientation, best_score = x, y, z, orientation_index, score\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_best_position_new_truck(self, unplaced_items, truck_type):\n        best_item_index, best_x, best_y, best_z, best_orientation, best_score = None, None, None, None, None, -1\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] <= 0:\n                continue\n            for orientation_index, (length, width, height) in self._get_orientations(item):\n                if self._is_valid_placement((0, 0, 0), (length, width, height), truck_type, []):\n                    score = self._calculate_item_score(item, (length, width, height), 0, unplaced_items)\n                    if score > best_score:\n                        best_item_index, best_x, best_y, best_z, best_orientation, best_score = item_index, 0, 0, 0, orientation_index, score\n\n        return best_item_index, best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_position_with_best_score(self, item, item_dims, occupied_volumes, truck_type, unplaced_items):\n        best_x, best_y, best_z, best_score = None, None, None, -1\n\n        potential_positions = self._generate_potential_positions(occupied_volumes, truck_type)\n\n        for x, y, z in potential_positions:\n            if self._is_valid_placement((x, y, z), item_dims, truck_type, occupied_volumes):\n                score = self._calculate_item_score(item, item_dims, len(occupied_volumes), unplaced_items)\n                if score > best_score:\n                    best_x, best_y, best_z, best_score = x, y, z, score\n\n        return best_x, best_y, best_z, best_score\n\n    def _generate_potential_positions(self, occupied_volumes, truck_type):\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        potential_positions = []\n        for item in occupied_volumes:\n            potential_positions.append((item['x'] + item['length'], item['y'], item['z']))\n            potential_positions.append((item['x'], item['y'] + item['width'], item['z']))\n            potential_positions.append((item['x'], item['y'], item['z'] + item['height']))\n\n        return potential_positions\n\n    def _calculate_item_score(self, item, item_dims, num_items, unplaced_items):\n        length, width, height = item_dims\n        volume = length * width * height\n        quantity = item['quantity']\n        stability_factor = length * width\n        density_factor = volume / (length*width*height if length*width*height !=0 else 1)\n        utilization_factor = (num_items + 1) ** 0.5\n\n        return volume * quantity * stability_factor / utilization_factor * density_factor",
          "objective": 22.15,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm prioritizes filling the lowest available space in existing trucks, selecting items based on a score using volume, quantity, and a placement validation ratio, then allocating a new truck if necessary.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes filling the lowest available space in existing trucks, selecting items based on a score using volume, quantity, and a placement validation ratio, then allocating a new truck if necessary.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = None\n        best_item_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_score = -1\n\n        for item_index in range(len(unplaced_items)):\n            if unplaced_items[item_index]['quantity'] <= 0:\n                continue\n            for truck_index, truck in enumerate(trucks_in_use):\n                x, y, z, orientation, score = self._find_best_position_in_truck(unplaced_items, item_index, truck['occupied_volumes'], truck_type)\n                if score > best_score:\n                    best_score = score\n                    best_truck_index = truck_index\n                    best_item_index = item_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n\n        if best_truck_index is None:\n            item_index, x, y, z, orientation, score = self._find_best_position_new_truck(unplaced_items, truck_type)\n            if item_index is not None:\n                return -1, item_index, x, y, z, orientation\n            else:\n                return -1, -1, 0, 0, 0, 0\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, unplaced_items, item_index, occupied_volumes, truck_type):\n        item_type = unplaced_items[item_index]\n        orientations = self._get_orientations(item_type)\n        best_x, best_y, best_z, best_orientation, best_score = None, None, None, None, -1\n\n        for orientation_index, (L, W, H) in orientations:\n            x, y, z, score = self._find_position_with_best_score(item_type, (L, W, H), occupied_volumes, truck_type, unplaced_items)\n            if score > best_score:\n                best_x, best_y, best_z, best_orientation, best_score = x, y, z, orientation_index, score\n\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_best_position_new_truck(self, unplaced_items, truck_type):\n        best_item_index = None\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_score = -1\n\n        for item_index in range(len(unplaced_items)):\n            if unplaced_items[item_index]['quantity'] <= 0:\n                continue\n            item_type = unplaced_items[item_index]\n            orientations = self._get_orientations(item_type)\n\n            for orientation_index, (L, W, H) in orientations:\n                if self._is_valid_placement((0, 0, 0), (L, W, H), truck_type, []):\n                    score = self._calculate_item_score(item_type, (L, W, H), 0, unplaced_items)\n                    if score > best_score:\n                        best_item_index = item_index\n                        best_x = 0\n                        best_y = 0\n                        best_z = 0\n                        best_orientation = orientation_index\n                        best_score = score\n\n        return best_item_index, best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_position_with_best_score(self, item_type, item_dims, occupied_volumes, truck_type, unplaced_items):\n        L, W, H = item_dims\n        tl, tw, th = truck_type\n        best_x, best_y, best_z, best_score = None, None, None, -1\n\n        potential_positions = []\n        if not occupied_volumes:\n          potential_positions.append((0,0,0))\n        else:\n          min_z = float('inf')\n          for item in occupied_volumes:\n            min_z = min(min_z, item['z'] + item['height'])\n\n          for x in np.arange(0, tl, 1):\n              for y in np.arange(0, tw, 1):\n                for z in np.arange(0, min_z+1, 1):\n                  potential_positions.append((x,y,z))\n\n        for x, y, z in potential_positions:\n            if self._is_valid_placement((x,y,z), (L, W, H), truck_type, occupied_volumes):\n                score = self._calculate_item_score(item_type, item_dims, len(occupied_volumes), unplaced_items)\n                if score > best_score:\n                    best_x, best_y, best_z, best_score = x, y, z, score\n\n        return best_x, best_y, best_z, best_score\n\n    def _calculate_item_score(self, item_type, item_dims, num_items, unplaced_items):\n        L, W, H = item_dims\n        volume = L * W * H\n        quantity = item_type['quantity']\n        base_area = L * W\n\n        placement_ratio = 1.0 / (num_items + 1)\n\n        return volume * quantity * base_area * placement_ratio\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _calculate_item_score(self, item_type, item_dims, num_items, unplaced_items):\n        L, W, H = item_dims\n        volume = L * W * H\n        quantity = item_type['quantity']\n        base_area = L * W\n\n        placement_ratio = 1.0 / (np.sqrt(num_items) + 1)\n\n        return volume * quantity * base_area * placement_ratio\nimport numpy as np\n\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_position_with_best_score(self, item_type, item_dims, occupied_volumes, truck_type, unplaced_items):\n        L, W, H = item_dims\n        tl, tw, th = truck_type\n        best_x, best_y, best_z, best_score = None, None, None, -1\n\n        potential_positions = []\n        if not occupied_volumes:\n            potential_positions.append((0, 0, 0))\n        else:\n            max_items_to_consider = min(len(occupied_volumes), 10)\n            occupied_volumes_subset = occupied_volumes[:max_items_to_consider]\n            for item in occupied_volumes_subset:\n                potential_positions.append((item['x'] + item['length'], item['y'], item['z']))\n                potential_positions.append((item['x'], item['y'] + item['width'], item['z']))\n                potential_positions.append((item['x'], item['y'], item['z'] + item['height']))\n\n        for x, y, z in potential_positions:\n            if self._is_valid_placement((x, y, z), (L, W, H), truck_type, occupied_volumes):\n                score = self._calculate_item_score(item_type, item_dims, len(occupied_volumes), unplaced_items)\n                if score > best_score:\n                    best_x, best_y, best_z, best_score = x, y, z, score\n\n        return best_x, best_y, best_z, best_score",
          "objective": 22.25,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     },
     {
          "algorithm": "This algorithm prioritizes items with larger footprints to maximize space utilization in each truck using a dynamic first-fit decreasing height strategy.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes items with larger footprints to maximize space utilization in each truck using a dynamic first-fit decreasing height strategy.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation = None, None, None, None, None, None\n        best_score = -1\n\n        for item_index in self._sort_items_by_footprint(unplaced_items):\n            item = unplaced_items[item_index]\n            if item['quantity'] <= 0:\n                continue\n\n            for truck_index, truck in enumerate(trucks_in_use):\n                x, y, z, orientation, score = self._find_best_position_in_truck(item, truck['occupied_volumes'], truck_type, unplaced_items)\n                if score > best_score:\n                    best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation, best_score = truck_index, item_index, x, y, z, orientation, score\n\n        if best_truck_index is None:\n            item_index, x, y, z, orientation, score = self._find_best_position_new_truck(unplaced_items, truck_type)\n            if item_index is not None:\n                return -1, item_index, x, y, z, orientation\n            else:\n                return -1, -1, 0, 0, 0, 0\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item, occupied_volumes, truck_type, unplaced_items):\n        best_x, best_y, best_z, best_orientation, best_score = None, None, None, None, -1\n        for orientation_index, (length, width, height) in self._get_orientations(item):\n            x, y, z, score = self._find_position_with_best_score(item, (length, width, height), occupied_volumes, truck_type, unplaced_items)\n            if score > best_score:\n                best_x, best_y, best_z, best_orientation, best_score = x, y, z, orientation_index, score\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_best_position_new_truck(self, unplaced_items, truck_type):\n        best_item_index, best_x, best_y, best_z, best_orientation, best_score = None, None, None, None, None, -1\n\n        for item_index in self._sort_items_by_footprint(unplaced_items):\n            item = unplaced_items[item_index]\n            if item['quantity'] <= 0:\n                continue\n            for orientation_index, (length, width, height) in self._get_orientations(item):\n                if self._is_valid_placement((0, 0, 0), (length, width, height), truck_type, []):\n                    score = self._calculate_item_score(item, (length, width, height), 0, unplaced_items)\n                    if score > best_score:\n                        best_item_index, best_x, best_y, best_z, best_orientation, best_score = item_index, 0, 0, 0, orientation_index, score\n\n        return best_item_index, best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_position_with_best_score(self, item, item_dims, occupied_volumes, truck_type, unplaced_items):\n        best_x, best_y, best_z, best_score = None, None, None, -1\n        potential_positions = self._generate_potential_positions(occupied_volumes, truck_type)\n\n        for x, y, z in potential_positions:\n            if self._is_valid_placement((x, y, z), item_dims, truck_type, occupied_volumes):\n                score = self._calculate_item_score(item, item_dims, len(occupied_volumes), unplaced_items)\n                if score > best_score:\n                    best_x, best_y, best_z, best_score = x, y, z, score\n\n        return best_x, best_y, best_z, best_score\n\n    def _generate_potential_positions(self, occupied_volumes, truck_type):\n        tl, tw, th = truck_type\n        potential_positions = []\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        occupied_volumes = sorted(occupied_volumes, key=lambda k: k['z'] + k['height'])\n\n        for item in occupied_volumes:\n            potential_positions.append((item['x'] + item['length'], item['y'], item['z']))\n            potential_positions.append((item['x'], item['y'] + item['width'], item['z']))\n            potential_positions.append((item['x'], item['y'], item['z'] + item['height']))\n\n            if item['z'] >0 :\n                potential_positions.append((item['x'], item['y'], 0))\n\n        valid_positions = []\n        for x, y, z in potential_positions:\n            if 0 <= x <= tl and 0 <= y <= tw and 0 <= z <= th:\n                valid_positions.append((x, y, z))\n\n        return valid_positions\n\n    def _calculate_item_score(self, item, item_dims, num_items, unplaced_items):\n        length, width, height = item_dims\n        volume = length * width * height\n        quantity = item['quantity']\n        footprint = length * width\n        space_utilization = volume / (length*width*height if length*width*height != 0 else 1)\n        placement_priority = quantity / (num_items + 1)\n        return footprint * space_utilization * placement_priority\n\n    def _sort_items_by_footprint(self, unplaced_items):\n      item_footprints = []\n      for item_index, item in enumerate(unplaced_items):\n        item_footprints.append((item_index, item['length'] * item['width']))\n\n      sorted_indices = [item_index for item_index, footprint in sorted(item_footprints, key=lambda x: x[1], reverse=True)]\n      return sorted_indices",
          "objective": 22.35,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm prioritizes items with higher volume, tries to place them lower in the container, and selects the position with the least remaining horizontal space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes items with higher volume, tries to place them lower in the container, and selects the position with the least remaining horizontal space.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return -1, -1, 0, 0, 0, 0\n\n        best_truck_index = -1\n        best_x = 0\n        best_y = 0\n        best_z = 0\n        best_orientation = 0\n        best_score = float('inf')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            x, y, z, orientation, score = self._find_best_position_in_truck(unplaced_items, item_index, truck['occupied_volumes'], truck_type)\n            if x is not None and score < best_score:\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_score = score\n\n        if best_truck_index == -1:\n            x, y, z, orientation, score = self._find_best_position_new_truck(unplaced_items, item_index, truck_type)\n            if orientation is not None:\n                best_truck_index = -1\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                best_score = score\n            else:\n                return -1, -1, 0, 0, 0, 0\n\n        return best_truck_index, item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        max_volume = -1\n        for i, item in enumerate(unplaced_items):\n            volume = item['length'] * item['width'] * item['height']\n            if volume > max_volume and item['quantity'] > 0:\n                max_volume = volume\n                best_item_index = i\n        return best_item_index\n\n    def _find_best_position_in_truck(self, unplaced_items, item_index, occupied_volumes, truck_type):\n        item_type = unplaced_items[item_index]\n        orientations = self._get_orientations(item_type)\n\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_score = float('inf')\n\n        for orientation_index, (L, W, H) in orientations:\n            x, y, z, score = self._find_position_with_score(item_type, (L, W, H), occupied_volumes, truck_type)\n            if x is not None and score < best_score:\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation_index\n                best_score = score\n\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_best_position_new_truck(self, unplaced_items, item_index, truck_type):\n        item_type = unplaced_items[item_index]\n        orientations = self._get_orientations(item_type)\n\n        best_x = None\n        best_y = None\n        best_z = None\n        best_orientation = None\n        best_score = float('inf')\n\n        for orientation_index, (L, W, H) in orientations:\n            if self._is_within_container_bounds((0, 0, 0), (L, W, H), truck_type):\n                score = H\n                if score < best_score:\n                    best_x = 0\n                    best_y = 0\n                    best_z = 0\n                    best_orientation = orientation_index\n                    best_score = score\n\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_position_with_score(self, item_type, item_dims, occupied_volumes, truck_type):\n        L, W, H = item_dims\n        tl, tw, th = truck_type\n\n        best_x = None\n        best_y = None\n        best_z = None\n        best_score = float('inf')\n\n        potential_positions = []\n        if not occupied_volumes:\n            if self._is_valid_placement((0, 0, 0), (L, W, H), truck_type, occupied_volumes):\n                potential_positions.append((0,0,0))\n        else:\n            for placed_item in occupied_volumes:\n                px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n                pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n\n                possible_positions = [(px + pl, py, pz), (px, py + pw, pz), (px, py, pz + ph)]\n\n                for x, y, z in possible_positions:\n                    if self._is_valid_placement((x, y, z), (L, W, H), truck_type, occupied_volumes):\n                        potential_positions.append((x,y,z))\n\n        for x, y, z in potential_positions:\n          remaining_space = (tl - (x + L)) * (tw - (y + W))\n          score = z + remaining_space\n          if score < best_score:\n            best_x = x\n            best_y = y\n            best_z = z\n            best_score = score\n\n        return best_x, best_y, best_z, best_score",
          "objective": 22.4,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm prioritizes items with minimal height to improve layering and stability, using a modified scoring function that emphasizes height reduction and quantity.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes items with minimal height to improve layering and stability, using a modified scoring function that emphasizes height reduction and quantity.}\n    def __init__(self, epsilon=1e-6, alpha=1.0):\n        super().__init__(epsilon, alpha)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n    \n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation = None, None, None, None, None, None\n        best_score = -1\n\n        for item_index in self._sort_items_by_quantity(unplaced_items):\n            item = unplaced_items[item_index]\n            if item['quantity'] <= 0:\n                continue\n\n            for truck_index, truck in enumerate(trucks_in_use):\n                x, y, z, orientation, score = self._find_best_position_in_truck(item, truck['occupied_volumes'], truck_type, unplaced_items)\n                if score > best_score:\n                    best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation, best_score = truck_index, item_index, x, y, z, orientation, score\n\n        if best_truck_index is None:\n            item_index, x, y, z, orientation, score = self._find_best_position_new_truck(unplaced_items, truck_type)\n            if item_index is not None:\n                return -1, item_index, x, y, z, orientation\n            else:\n                return -1, -1, 0, 0, 0, 0\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_in_truck(self, item, occupied_volumes, truck_type, unplaced_items):\n        best_x, best_y, best_z, best_orientation, best_score = None, None, None, None, -1\n        for orientation_index, (length, width, height) in self._get_orientations(item):\n            x, y, z, score = self._find_position_with_best_score(item, (length, width, height), occupied_volumes, truck_type, unplaced_items)\n            if score > best_score:\n                best_x, best_y, best_z, best_orientation, best_score = x, y, z, orientation_index, score\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_best_position_new_truck(self, unplaced_items, truck_type):\n        best_item_index, best_x, best_y, best_z, best_orientation, best_score = None, None, None, None, None, -1\n\n        for item_index in self._sort_items_by_quantity(unplaced_items):\n            item = unplaced_items[item_index]\n            if item['quantity'] <= 0:\n                continue\n            for orientation_index, (length, width, height) in self._get_orientations(item):\n                if self._is_valid_placement((0, 0, 0), (length, width, height), truck_type, []):\n                    score = self._calculate_item_score(item, (length, width, height), 0, unplaced_items)\n                    if score > best_score:\n                        best_item_index, best_x, best_y, best_z, best_orientation, best_score = item_index, 0, 0, 0, orientation_index, score\n\n        return best_item_index, best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_position_with_best_score(self, item, item_dims, occupied_volumes, truck_type, unplaced_items):\n        best_x, best_y, best_z, best_score = None, None, None, -1\n        potential_positions = self._generate_potential_positions(occupied_volumes, truck_type)\n\n        for x, y, z in potential_positions:\n            if self._is_valid_placement((x, y, z), item_dims, truck_type, occupied_volumes):\n                score = self._calculate_item_score(item, item_dims, len(occupied_volumes), unplaced_items)\n                if score > best_score:\n                    best_x, best_y, best_z, best_score = x, y, z, score\n\n        return best_x, best_y, best_z, best_score\n\n    def _generate_potential_positions(self, occupied_volumes, truck_type):\n        tl, tw, th = truck_type\n        potential_positions = []\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        occupied_volumes = sorted(occupied_volumes, key=lambda k: k['z'] + k['height'])\n\n        for item in occupied_volumes:\n            potential_positions.append((item['x'] + item['length'], item['y'], item['z']))\n            potential_positions.append((item['x'], item['y'] + item['width'], item['z']))\n            potential_positions.append((item['x'], item['y'], item['z'] + item['height']))\n\n            if item['z'] >0 :\n                potential_positions.append((item['x'], item['y'], 0))\n\n        valid_positions = []\n        for x, y, z in potential_positions:\n            if 0 <= x <= tl and 0 <= y <= tw and 0 <= z <= th:\n                valid_positions.append((x, y, z))\n\n        return valid_positions\n\n    def _calculate_item_score(self, item, item_dims, num_items, unplaced_items):\n        length, width, height = item_dims\n        volume = length * width * height\n        quantity = item['quantity']\n        \n        height_penalty = 1 / (height + self.epsilon)\n        placement_priority = quantity / (num_items + 1)\n        return height_penalty * volume * placement_priority\n\n    def _sort_items_by_quantity(self, unplaced_items):\n        item_quantities = []\n        for item_index, item in enumerate(unplaced_items):\n            item_quantities.append((item_index, item['quantity']))\n\n        sorted_indices = [item_index for item_index, quantity in sorted(item_quantities, key=lambda x: x[1], reverse=True)]\n        return sorted_indices",
          "objective": 22.5,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]