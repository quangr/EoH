[
    [
        "This algorithm prioritizes filling existing trucks with items that fit well in the remaining space, considering weight and support constraints, and opens a new truck only when necessary, selecting the truck type that is large enough to accommodate the item but is as small as possible.",
        "import numpy as np\n\ndef place_item(unplaced_items, trucks_in_use, truck_types):\n    \"\"\"\n    Places an item into a truck, minimizing the number of trucks used.\n\n    {This algorithm prioritizes filling existing trucks with items that fit well in the remaining space, considering weight and support constraints, and opens a new truck only when necessary, selecting the truck type that is large enough to accommodate the item but is as small as possible.}\n    \"\"\"\n    truck_index = -1\n    item_index = -1\n    x = -1\n    y = -1\n    z = -1\n    truck_type_index = -1\n\n    # 1. Iterate through unplaced items and existing trucks to find the best fit.\n    for i, item in enumerate(unplaced_items):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n\n        for t_index, truck in enumerate(trucks_in_use):\n            truck_type = truck_types[truck['truck_type_index']]\n            if truck['current_weight'] + item['weight'] <= truck_type[0]:\n                # Try to find a suitable placement in the truck\n                found_spot = False\n                occupied_volumes = truck['occupied_volumes']\n                \n                #Try placing the item at z=0 first\n                for try_z in [0]:\n                    # Try different x and y coordinates\n                    for try_x in np.arange(0, truck_type[1] - item['length'] + 0.001, 0.1):  # Add small delta to include the right boundary\n                        for try_y in np.arange(0, truck_type[2] - item['width'] + 0.001, 0.1): # Add small delta to include the right boundary\n                            \n                            # Check if the item fits within the truck's dimensions\n                            if (try_x + item['length'] <= truck_type[1] and\n                                try_y + item['width'] <= truck_type[2] and\n                                item['height'] <= truck_type[3]):\n                                \n                                # Check for overlaps with existing items\n                                overlap = False\n                                for placed_item in occupied_volumes:\n                                    if (try_x < placed_item[1] + placed_item[4] and\n                                        try_x + item['length'] > placed_item[1] and\n                                        try_y < placed_item[2] + placed_item[5] and\n                                        try_y + item['width'] > placed_item[2] and\n                                        try_z < placed_item[3] + placed_item[6] and\n                                        try_z + item['height'] > placed_item[3]):\n                                        overlap = True\n                                        break\n                                \n                                if not overlap:\n                                    # Check for support\n                                    supported = False\n                                    if try_z == 0:\n                                        supported = True  # Supported by the floor\n                                    else:\n                                        supported_area = 0\n                                        total_area = item['length'] * item['width']\n                                        for placed_item in occupied_volumes:\n                                            if (try_x < placed_item[1] + placed_item[4] and\n                                                try_x + item['length'] > placed_item[1] and\n                                                try_y < placed_item[2] + placed_item[5] and\n                                                try_y + item['width'] > placed_item[2] and\n                                                try_z == placed_item[3] + placed_item[6]): # Item's bottom is on top of the other item\n                                                \n                                                x_overlap = max(0, min(try_x + item['length'], placed_item[1] + placed_item[4]) - max(try_x, placed_item[1]))\n                                                y_overlap = max(0, min(try_y + item['width'], placed_item[2] + placed_item[5]) - max(try_y, placed_item[2]))\n                                                supported_area += x_overlap * y_overlap\n                                        \n                                        if supported_area / total_area >= 0.8:\n                                            supported = True\n                                    \n                                    if supported:\n                                        best_truck_index = t_index\n                                        best_x = try_x\n                                        best_y = try_y\n                                        best_z = try_z\n                                        found_spot = True\n                                        break # found the spot, no need to continue this truck\n                            if found_spot:\n                                break\n                        if found_spot:\n                            break\n                if found_spot:\n                    break\n        # 2. If a suitable truck is found, use it\n        if best_truck_index != -1:\n            truck_index = best_truck_index\n            item_index = i\n            x = best_x\n            y = best_y\n            z = best_z\n            \n            break #found a place, no need to continue with the other items\n    # 3. If no suitable truck is found, open a new truck.\n    if truck_index == -1:\n        item = unplaced_items[0] #consider only the first item in unplaced_items to find a truck to place this item at first.\n\n        best_truck_type_index = -1\n        for tt_index, truck_type in enumerate(truck_types):\n            if (truck_type[0] >= item['weight'] and\n                truck_type[1] >= item['length'] and\n                truck_type[2] >= item['width'] and\n                truck_type[3] >= item['height']):\n                \n                if best_truck_type_index == -1 or truck_types[best_truck_type_index][1] > truck_type[1]:\n                    best_truck_type_index = tt_index\n        if best_truck_type_index != -1:\n\n            truck_index = -1\n            item_index = 0\n            x = 0\n            y = 0\n            z = 0\n            truck_type_index = best_truck_type_index\n        else:\n             # If no truck type can fit the item, return -1s to signal failure (shouldn't happen with a correct problem setup)\n            return -1, -1, -1, -1, -1, -1\n\n    return truck_index, item_index, x, y, z, truck_type_index"
    ],
    
    [
        "This algorithm first sorts unplaced items by volume, then iterates through existing trucks and potential locations within each truck to find the best fit for the current item, considering weight, dimensions, support, and overlap constraints; if no suitable truck is found, it selects a new truck type and places the item there.}\"\"\"\n\n    # Sort unplaced items by volume (descending)\n    item_indices = sorted(range(len(unplaced_items)), key=lambda i: unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height'], reverse=True)\n\n    for item_idx in item_indices:\n        item = unplaced_items[item_idx]\n        item_length = item['length']\n        item_width = item['width']\n        item_height = item['height']\n        item_weight = item['weight']\n\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_truck_type_index = -1\n\n        # Try to fit the item into existing trucks\n        for truck_index in range(len(trucks_in_use)):\n            truck = trucks_in_use[truck_index]\n            truck_type_index = truck['truck_type_index']\n            truck_capacity, truck_length, truck_width, truck_height = truck_types[truck_type_index]\n            current_weight = truck['current_weight']\n\n            if current_weight + item_weight <= truck_capacity:\n                occupied_volumes = truck['occupied_volumes']\n\n                # Find possible locations within the truck\n                for x in np.arange(0, truck_length - item_length + 0.001, 0.1):\n                    for y in np.arange(0, truck_width - item_width + 0.001, 0.1):\n                        \n                        # Find the highest possible z-coordinate for support\n                        z = 0\n                        if len(occupied_volumes) > 0:\n                            max_z = 0\n                            for occupied_item_id, ox, oy, oz, ol, ow, oh in occupied_volumes:\n                                if ox <= x < ox + ol or ox <= x + item_length < ox + ol or (x <= ox and ox+ol <= x + item_length):\n                                    if oy <= y < oy + ow or oy <= y + item_width < oy + ow or (y <= oy and oy+ow <= y + item_width):\n                                        max_z = max(max_z, oz + oh)\n\n                            z = max_z\n                        \n                        if z + item_height <= truck_height:\n                            # Check for overlap\n                            overlap = False\n                            for occupied_item_id, ox, oy, oz, ol, ow, oh in occupied_volumes:\n                                if (x < ox + ol and x + item_length > ox and\n                                    y < oy + ow and y + item_width > oy and\n                                    z < oz + oh and z + item_height > oz):\n                                    overlap = True\n                                    break\n\n                            if not overlap:\n                                # Check for support\n                                if z == 0:\n                                    support = True # Supported by the floor\n                                else:\n                                    supported_area = 0\n                                    total_area = item_length * item_width\n\n                                    for occupied_item_id, ox, oy, oz, ol, ow, oh in occupied_volumes:\n                                        if oz + oh == z:\n                                            x_overlap = max(0, min(x + item_length, ox + ol) - max(x, ox))\n                                            y_overlap = max(0, min(y + item_width, oy + ow) - max(y, oy))\n                                            supported_area += x_overlap * y_overlap\n\n                                    if supported_area / total_area >= 0.8:\n                                        support = True\n                                    else:\n                                        support = False\n\n                                if support:\n                                    best_truck_index = truck_index\n                                    best_x = x\n                                    best_y = y\n                                    best_z = z\n                                    break # Found a suitable location in this truck\n                    if best_truck_index != -1:\n                        break\n\n        if best_truck_index != -1:\n            # Place the item in the existing truck\n            trucks_in_use[best_truck_index]['occupied_volumes'].append((item['item_id'], best_x, best_y, best_z, item_length, item_width, item_height))\n            trucks_in_use[best_truck_index]['current_weight'] += item_weight\n\n            truck_index = best_truck_index\n            item_index = item_idx\n            x = best_x\n            y = best_y\n            z = best_z\n            truck_type_index = -1 # Not needed since we are using an existing truck\n            return truck_index, item_index, x, y, z, truck_type_index\n\n    # If no suitable truck is found, use a new truck\n    for truck_type_index in range(len(truck_types)):\n        truck_capacity, truck_length, truck_width, truck_height = truck_types[truck_type_index]\n\n        if item_weight <= truck_capacity:\n            # Create a new truck\n            new_truck = {\n                'truck_type_index': truck_type_index,\n                'occupied_volumes': [],\n                'current_weight': 0\n            ",
        "import numpy as np\n\ndef place_item(unplaced_items, trucks_in_use, truck_types):\n    \"\"\"{This algorithm first sorts unplaced items by volume, then iterates through existing trucks and potential locations within each truck to find the best fit for the current item, considering weight, dimensions, support, and overlap constraints; if no suitable truck is found, it selects a new truck type and places the item there.}\"\"\"\n\n    # Sort unplaced items by volume (descending)\n    item_indices = sorted(range(len(unplaced_items)), key=lambda i: unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height'], reverse=True)\n\n    for item_idx in item_indices:\n        item = unplaced_items[item_idx]\n        item_length = item['length']\n        item_width = item['width']\n        item_height = item['height']\n        item_weight = item['weight']\n\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_truck_type_index = -1\n\n        # Try to fit the item into existing trucks\n        for truck_index in range(len(trucks_in_use)):\n            truck = trucks_in_use[truck_index]\n            truck_type_index = truck['truck_type_index']\n            truck_capacity, truck_length, truck_width, truck_height = truck_types[truck_type_index]\n            current_weight = truck['current_weight']\n\n            if current_weight + item_weight <= truck_capacity:\n                occupied_volumes = truck['occupied_volumes']\n\n                # Find possible locations within the truck\n                for x in np.arange(0, truck_length - item_length + 0.001, 0.1):\n                    for y in np.arange(0, truck_width - item_width + 0.001, 0.1):\n                        \n                        # Find the highest possible z-coordinate for support\n                        z = 0\n                        if len(occupied_volumes) > 0:\n                            max_z = 0\n                            for occupied_item_id, ox, oy, oz, ol, ow, oh in occupied_volumes:\n                                if ox <= x < ox + ol or ox <= x + item_length < ox + ol or (x <= ox and ox+ol <= x + item_length):\n                                    if oy <= y < oy + ow or oy <= y + item_width < oy + ow or (y <= oy and oy+ow <= y + item_width):\n                                        max_z = max(max_z, oz + oh)\n\n                            z = max_z\n                        \n                        if z + item_height <= truck_height:\n                            # Check for overlap\n                            overlap = False\n                            for occupied_item_id, ox, oy, oz, ol, ow, oh in occupied_volumes:\n                                if (x < ox + ol and x + item_length > ox and\n                                    y < oy + ow and y + item_width > oy and\n                                    z < oz + oh and z + item_height > oz):\n                                    overlap = True\n                                    break\n\n                            if not overlap:\n                                # Check for support\n                                if z == 0:\n                                    support = True # Supported by the floor\n                                else:\n                                    supported_area = 0\n                                    total_area = item_length * item_width\n\n                                    for occupied_item_id, ox, oy, oz, ol, ow, oh in occupied_volumes:\n                                        if oz + oh == z:\n                                            x_overlap = max(0, min(x + item_length, ox + ol) - max(x, ox))\n                                            y_overlap = max(0, min(y + item_width, oy + ow) - max(y, oy))\n                                            supported_area += x_overlap * y_overlap\n\n                                    if supported_area / total_area >= 0.8:\n                                        support = True\n                                    else:\n                                        support = False\n\n                                if support:\n                                    best_truck_index = truck_index\n                                    best_x = x\n                                    best_y = y\n                                    best_z = z\n                                    break # Found a suitable location in this truck\n                    if best_truck_index != -1:\n                        break\n\n        if best_truck_index != -1:\n            # Place the item in the existing truck\n            trucks_in_use[best_truck_index]['occupied_volumes'].append((item['item_id'], best_x, best_y, best_z, item_length, item_width, item_height))\n            trucks_in_use[best_truck_index]['current_weight'] += item_weight\n\n            truck_index = best_truck_index\n            item_index = item_idx\n            x = best_x\n            y = best_y\n            z = best_z\n            truck_type_index = -1 # Not needed since we are using an existing truck\n            return truck_index, item_index, x, y, z, truck_type_index\n\n    # If no suitable truck is found, use a new truck\n    for truck_type_index in range(len(truck_types)):\n        truck_capacity, truck_length, truck_width, truck_height = truck_types[truck_type_index]\n\n        if item_weight <= truck_capacity:\n            # Create a new truck\n            new_truck = {\n                'truck_type_index': truck_type_index,\n                'occupied_volumes': [],\n                'current_weight': 0\n            }\n\n            # Place the item in the new truck at (0, 0, 0)\n            new_truck['occupied_volumes'].append((item['item_id'], 0, 0, 0, item_length, item_width, item_height))\n            new_truck['current_weight'] += item_weight\n            trucks_in_use.append(new_truck)\n            \n            truck_index = -1 # A new truck is being used.\n            item_index = item_idx\n            x = 0\n            y = 0\n            z = 0\n            return truck_index, item_index, x, y, z, truck_type_index\n\n    # If no truck type can accommodate the item, return -1 for truck_index\n    truck_index = -1\n    item_index = 0  # Return the first item, even though it couldn't be placed\n    x = 0\n    y = 0\n    z = 0\n    truck_type_index = 0\n    return truck_index, item_index, x, y, z, truck_type_index"
    ],
    [
        "This algorithm iterates through unplaced items and tries to fit each item into existing trucks, prioritizing smaller items and lower z-coordinate placement, and opens a new truck only when necessary, preferring truck types that best fit the remaining items.",
        "import numpy as np\n\ndef place_item(unplaced_items, trucks_in_use, truck_types):\n    \"\"\"\n    {This algorithm iterates through unplaced items and tries to fit each item into existing trucks, prioritizing smaller items and lower z-coordinate placement, and opens a new truck only when necessary, preferring truck types that best fit the remaining items.}\n    \"\"\"\n\n    truck_index = -1\n    item_index = -1\n    x = -1.0\n    y = -1.0\n    z = -1.0\n    truck_type_index = -1\n\n    # Prioritize smaller items\n    unplaced_items_sorted = sorted(enumerate(unplaced_items), key=lambda x: x[1]['length'] * x[1]['width'] * x[1]['height'])\n\n    for item_idx, item in unplaced_items_sorted:\n        item_length = item['length']\n        item_width = item['width']\n        item_height = item['height']\n        item_weight = item['weight']\n\n        # Try to fit the item into existing trucks\n        for truck_idx, truck in enumerate(trucks_in_use):\n            truck_type_index_local = truck['truck_type_index']\n            truck_capacity = truck_types[truck_type_index_local][0]\n            truck_length = truck_types[truck_type_index_local][1]\n            truck_width = truck_types[truck_type_index_local][2]\n            truck_height = truck_types[truck_type_index_local][3]\n            current_weight = truck['current_weight']\n            occupied_volumes = truck['occupied_volumes']\n\n            if current_weight + item_weight <= truck_capacity:\n                # Find a valid placement for the item in the current truck\n                x, y, z = find_valid_placement(item_length, item_width, item_height, truck_length, truck_width, truck_height, occupied_volumes)\n\n                if x != -1 and y != -1 and z != -1:\n                    # Found a valid placement\n                    truck_index = truck_idx\n                    item_index = item_idx\n                    break\n\n        if truck_index != -1:\n            # Item placed in an existing truck\n            break\n\n    if truck_index == -1:\n        # Need to open a new truck\n        \n        # Prioritize smaller truck types\n        truck_type_index_sorted = sorted(range(len(truck_types)), key=lambda i: truck_types[i][1] * truck_types[i][2] * truck_types[i][3])\n\n        for type_idx in truck_type_index_sorted:\n            truck_capacity = truck_types[type_idx][0]\n            truck_length = truck_types[type_idx][1]\n            truck_width = truck_types[type_idx][2]\n            truck_height = truck_types[type_idx][3]\n\n            if item_weight <= truck_capacity and item_length <= truck_length and item_width <= truck_width and item_height <= truck_height:\n                # Found a suitable truck type\n                x = 0.0\n                y = 0.0\n                z = 0.0\n                truck_type_index = type_idx\n                truck_index = -1  # Indicate new truck\n                item_index = item_idx\n                break\n\n        if truck_type_index == -1:\n             # If no small trucks fit, find any truck that fits\n             for type_idx in truck_type_index_sorted:\n                truck_capacity = truck_types[type_idx][0]\n                truck_length = truck_types[type_idx][1]\n                truck_width = truck_types[type_idx][2]\n                truck_height = truck_types[type_idx][3]\n\n                if item_weight <= truck_capacity and item_length <= truck_length and item_width <= truck_width and item_height <= truck_height:\n                    # Found a suitable truck type\n                    x = 0.0\n                    y = 0.0\n                    z = 0.0\n                    truck_type_index = type_idx\n                    truck_index = -1  # Indicate new truck\n                    item_index = item_idx\n                    break\n\n    return truck_index, item_index, x, y, z, truck_type_index\n\n\ndef find_valid_placement(item_length, item_width, item_height, truck_length, truck_width, truck_height, occupied_volumes):\n    \"\"\"\n    Finds a valid placement (x, y, z) for the item within the truck,\n    considering existing occupied volumes. Returns (-1, -1, -1) if no placement is found.\n    \"\"\"\n\n    # Try placing at the bottom first, then search upwards\n    z_levels = sorted(list(set([0.0] + [vol[3] + vol[6] for vol in occupied_volumes])))\n\n    for z in z_levels:\n        # Iterate through possible x and y coordinates\n        x_candidates = sorted(list(set([0.0] + [vol[1] + vol[4] for vol in occupied_volumes if vol[3] + vol[6] <= z ])))\n        y_candidates = sorted(list(set([0.0] + [vol[2] + vol[5] for vol in occupied_volumes if vol[3] + vol[6] <= z ])))\n\n\n        for x in x_candidates:\n            for y in y_candidates:\n                # Check if the item fits within the truck dimensions\n                if x + item_length <= truck_length and y + item_width <= truck_width and z + item_height <= truck_height:\n                    # Check for overlaps with existing volumes\n                    overlap = False\n                    for vol in occupied_volumes:\n                        if check_overlap(x, y, z, item_length, item_width, item_height, vol[1], vol[2], vol[3], vol[4], vol[5], vol[6]):\n                            overlap = True\n                            break\n                            \n                    if not overlap:\n                        # Check for support\n                        if is_supported(x, y, z, item_length, item_width, truck_length, truck_width, truck_height, occupied_volumes):\n                             return x, y, z\n\n    return -1.0, -1.0, -1.0\n\n\ndef check_overlap(x1, y1, z1, l1, w1, h1, x2, y2, z2, l2, w2, h2):\n    \"\"\"\n    Checks if two rectangular volumes overlap.\n    \"\"\"\n    return not (x1 + l1 <= x2 or x1 >= x2 + l2 or\n                y1 + w1 <= y2 or y1 >= y2 + w2 or\n                z1 + h1 <= z2 or z1 >= z2 + h2)\n\n\ndef is_supported(x, y, z, length, width, truck_length, truck_width, truck_height, occupied_volumes):\n    \"\"\"\n    Checks if the item is sufficiently supported by other items or the truck floor.\n    \"\"\"\n    supported_area = 0.0\n    \n    # Check support from the truck floor\n    if z == 0.0:\n        supported_area += length * width\n\n    # Check support from other items\n    for vol in occupied_volumes:\n        support_x_start = max(x, vol[1])\n        support_x_end = min(x + length, vol[1] + vol[4])\n        support_y_start = max(y, vol[2])\n        support_y_end = min(y + width, vol[2] + vol[5])\n        \n        if support_x_start < support_x_end and support_y_start < support_y_end and vol[3] + vol[6] == z:\n            supported_area += (support_x_end - support_x_start) * (support_y_end - support_y_start)\n            \n    return truck_index, item_index, x, y, z, truck_type_index"
    ],
    [
        "```",
        "import numpy as np\n\ndef place_item(unplaced_items, trucks_in_use, truck_types):\n    \"\"\"\n    Places an item into a truck, minimizing the number of trucks used.\n\n    The algorithm prioritizes filling existing trucks before using new ones.\n    It iterates through unplaced items and tries to find a suitable placement in existing trucks.\n    If no suitable placement is found in existing trucks, it selects a new truck type and places the item in the new truck.\n    \"\"\"\n    truck_index = -1\n    item_index = -1\n    x = 0.0\n    y = 0.0\n    z = 0.0\n    truck_type_index = -1\n\n    # Iterate through unplaced items\n    for i, item in enumerate(unplaced_items):\n        item_length = item['length']\n        item_width = item['width']\n        item_height = item['height']\n        item_weight = item['weight']\n        item_id = item['item_id']\n\n        # Try to place the item in existing trucks\n        for j, truck in enumerate(trucks_in_use):\n            truck_type_index_current = truck['truck_type_index']\n            capacity, truck_length, truck_width, truck_height = truck_types[truck_type_index_current]\n            current_weight = truck['current_weight']\n            occupied_volumes = truck['occupied_volumes']\n\n            if current_weight + item_weight <= capacity:\n                # Find a suitable placement in the truck\n                x_candidates = [0.0]\n                y_candidates = [0.0]\n                z_candidates = [0.0]\n\n                #Add existing item boundaries as potential placement locations.\n                for volume in occupied_volumes:\n                  x_candidates.append(volume[1]+volume[4])\n                  y_candidates.append(volume[2]+volume[5])\n                  z_candidates.append(volume[3]+volume[6])\n\n                x_candidates = sorted(list(set(x_candidates)))\n                y_candidates = sorted(list(set(y_candidates)))\n                z_candidates = sorted(list(set(z_candidates)))\n\n                for cx in x_candidates:\n                  for cy in y_candidates:\n                    for cz in z_candidates:\n                      #Check if dimensions fit in the box:\n                      if cx + item_length <= truck_length and cy + item_width <= truck_width and cz+item_height <= truck_height:\n                        #Check if there are any overlaps with placed items:\n                        overlap = False\n                        for volume in occupied_volumes:\n                          x1 = cx\n                          y1 = cy\n                          z1 = cz\n                          l1 = item_length\n                          w1 = item_width\n                          h1 = item_height\n\n                          x2 = volume[1]\n                          y2 = volume[2]\n                          z2 = volume[3]\n                          l2 = volume[4]\n                          w2 = volume[5]\n                          h2 = volume[6]\n                          if not (x1 + l1 <= x2 or x1 >= x2 + l2 or y1 + w1 <= y2 or y1 >= y2 + w2 or z1 + h1 <= z2 or z1 >= z2 + h2):\n                            overlap = True\n                            break\n                        \n                        if not overlap:\n                            # Check for support\n                            supported = False\n                            if cz == 0:\n                                supported = True\n                            else:\n                                # Calculate supported area\n                                supported_area = 0.0\n                                for volume in occupied_volumes:\n                                    if cz > volume[3] + volume[6]:\n                                        # Possible support\n                                        x_overlap = max(0, min(cx + item_length, volume[1] + volume[4]) - max(cx, volume[1]))\n                                        y_overlap = max(0, min(cy + item_width, volume[2] + volume[5]) - max(cy, volume[2]))\n                                        if x_overlap > 0 and y_overlap > 0:\n                                            supported_area += x_overlap * y_overlap\n                                if supported_area >= 0.8 * item_length * item_width:\n                                    supported = True\n\n                            if supported:\n                                truck_index = j\n                                item_index = i\n                                x = cx\n                                y = cy\n                                z = cz\n                                \n                                return truck_index, item_index, x, y, z, truck_type_index\n\n        # If no suitable placement found in existing trucks, use a new truck\n        truck_index = -1\n        # Find best truck to use, minimizing wasted space (FirstFitDecreasing heuristics)\n        best_truck_type_index = -1\n        min_waste = float('inf')\n        \n        for k, truck_type in enumerate(truck_types):\n          truck_capacity, truck_length, truck_width, truck_height = truck_type\n          if item_weight <= truck_capacity and truck_length >= item_length and truck_width >= item_width and truck_height >= item_height:\n            waste = truck_capacity - item_weight + truck_length*truck_width*truck_height\n            if waste < min_waste:\n              min_waste = waste\n              best_truck_type_index = k\n\n        if best_truck_type_index != -1:\n          truck_type_index = best_truck_type_index\n          item_index = i\n          x = 0.0\n          y = 0.0\n          z = 0.0\n          return truck_index, item_index, x, y, z, truck_type_index\n\n    return truck_index, item_index, x, y, z, truck_type_index"
    ],
    [
        "This algorithm prioritizes placing items into existing trucks, starting with the truck that has the least remaining weight capacity and sufficient space, and selecting the item that best fits into the available space based on a volume heuristic, then adding a new truck only if no existing truck can accommodate any of the remaining items.",
        "import numpy as np\n\ndef place_item(unplaced_items, trucks_in_use, truck_types):\n    \"\"\"\n    {This algorithm prioritizes placing items into existing trucks, starting with the truck that has the least remaining weight capacity and sufficient space, and selecting the item that best fits into the available space based on a volume heuristic, then adding a new truck only if no existing truck can accommodate any of the remaining items.}\n    \"\"\"\n    truck_index = -1\n    item_index = -1\n    x = -1.0\n    y = -1.0\n    z = -1.0\n    truck_type_index = -1\n\n    # Prioritize filling existing trucks\n    best_truck_index = -1\n    best_item_index = -1\n    best_x = -1.0\n    best_y = -1.0\n    best_z = -1.0\n    best_volume_fit = float('inf')\n\n    for i, truck in enumerate(trucks_in_use):\n        truck_type_index_local = truck['truck_type_index']\n        capacity, length, width, height = truck_types[truck_type_index_local]\n        current_weight = truck['current_weight']\n        remaining_capacity = capacity - current_weight\n        occupied_volumes = truck['occupied_volumes']\n\n        for j, item in enumerate(unplaced_items):\n            item_length = item['length']\n            item_width = item['width']\n            item_height = item['height']\n            item_weight = item['weight']\n\n            if item_weight <= remaining_capacity:\n                # Try different positions within the truck\n                for ix in np.arange(0, length - item_length + 0.1, min(item_length/2, 1)):\n                    for iy in np.arange(0, width - item_width + 0.1, min(item_width/2, 1)):\n                        \n                        # find the z that maximizes the supported surface\n                        valid_z_candidates = []\n                        # Check if fits on the floor\n                        is_valid = True\n                        for placed_item_id, px, py, pz, pl, pw, ph in occupied_volumes:\n                            if (ix < px + pl and ix + item_length > px and\n                                iy < py + pw and iy + item_width > py):\n                                is_valid = False\n                                break\n                        if is_valid:\n                            valid_z_candidates.append(0.0)\n\n                        # Check supports by other items\n                        for placed_item_id, px, py, pz, pl, pw, ph in occupied_volumes:\n                            is_valid = True\n                            local_z = pz + ph\n                            for placed_item_id2, px2, py2, pz2, pl2, pw2, ph2 in occupied_volumes:\n                                if placed_item_id != placed_item_id2:\n                                    if (ix < px2 + pl2 and ix + item_length > px2 and\n                                        iy < py2 + pw2 and iy + item_width > py2 and\n                                        local_z < pz2 + ph2 and local_z + item_height > pz2):\n                                        is_valid = False\n                                        break\n                            if is_valid:\n                                valid_z_candidates.append(local_z)\n                        \n                        for iz in valid_z_candidates:\n                            \n                            if iz + item_height > height:\n                                continue\n                                    \n                            # Check for overlaps with existing items\n                            is_valid = True\n                            for placed_item_id, px, py, pz, pl, pw, ph in occupied_volumes:\n                                if (ix < px + pl and ix + item_length > px and\n                                    iy < py + pw and iy + item_width > py and\n                                    iz < pz + ph and iz + item_height > pz):\n                                    is_valid = False\n                                    break\n\n                            if is_valid:\n\n                                # Check for support\n                                support_area = 0.0\n                                if iz == 0:\n                                    support_area = item_length * item_width\n                                else:\n                                    for placed_item_id, px, py, pz, pl, pw, ph in occupied_volumes:\n                                        if iz == pz + ph:\n                                            x_overlap = max(0, min(ix + item_length, px + pl) - max(ix, px))\n                                            y_overlap = max(0, min(iy + item_width, py + pw) - max(iy, py))\n                                            support_area += x_overlap * y_overlap\n                                support_percentage = support_area / (item_length * item_width)\n\n                                if support_percentage >= 0.8:  # Check support constraint\n\n                                    # Calculate remaining volume in truck and volume fit\n                                    remaining_volume = (length * width * height) - sum(pl * pw * ph for _, _, _, _, pl, pw, ph in occupied_volumes)\n                                    volume_fit = item_length * item_width * item_height #min(item_length, length - ix) * min(item_width, width - iy) * min(item_height, height-iz)\n                                    if volume_fit < best_volume_fit:\n                                        best_volume_fit = volume_fit\n                                        best_truck_index = i\n                                        best_item_index = j\n                                        best_x = ix\n                                        best_y = iy\n                                        best_z = iz\n                \n    if best_truck_index != -1:\n        truck_index = best_truck_index\n        item_index = best_item_index\n        x = best_x\n        y = best_y\n        z = best_z\n        \n    else:\n        # If no existing truck fits, add a new truck\n        for type_index, truck_type in enumerate(truck_types):\n            capacity, _, _, _ = truck_type\n            for j, item in enumerate(unplaced_items):\n                if item['weight'] <= capacity:\n                    truck_type_index = type_index\n                    truck_index = -1\n                    item_index = j\n                    x = 0.0\n                    y = 0.0\n                    z = 0.0\n                    break\n            if truck_type_index != -1:\n                break\n            \n    return truck_index, item_index, x, y, z, truck_type_index"
    ],
    [
        "The algorithm first prioritizes filling existing trucks using a heuristic that\n    combines remaining volume and weight capacity, then considers opening a new truck\n    if no existing truck can accommodate the item, employing a first-fit approach for\n    item selection and placement within trucks, with support and no-overlap constraints\n    checked at each step.",
        "import numpy as np\n\ndef place_item(unplaced_items, trucks_in_use, truck_types):\n    \"\"\"\n    Places an item into a truck, minimizing the number of trucks used.\n\n    {The algorithm first prioritizes filling existing trucks using a heuristic that\n    combines remaining volume and weight capacity, then considers opening a new truck\n    if no existing truck can accommodate the item, employing a first-fit approach for\n    item selection and placement within trucks, with support and no-overlap constraints\n    checked at each step.}\n    \"\"\"\n\n    truck_index = -1\n    item_index = -1\n    x = -1.0\n    y = -1.0\n    z = -1.0\n    truck_type_index = -1\n\n    # Prioritize filling existing trucks\n    best_truck_index = -1\n    best_item_index = -1\n    best_x = -1.0\n    best_y = -1.0\n    best_z = -1.0\n    best_score = -1.0\n\n    for i, item in enumerate(unplaced_items):\n        for j, truck in enumerate(trucks_in_use):\n            truck_type_index_val = truck['truck_type_index']\n            truck_capacity, truck_length, truck_width, truck_height = truck_types[truck_type_index_val]\n\n            if truck['current_weight'] + item['weight'] <= truck_capacity:\n                # Try placing the item in the truck\n                occupied_volumes = truck['occupied_volumes']\n\n                # Simple first-fit placement\n                for cur_x in np.arange(0, truck_length - item['length'] + 0.0001, 0.1):\n                    for cur_y in np.arange(0, truck_width - item['width'] + 0.0001, 0.1):\n                        # Find the lowest possible z\n                        cur_z = 0.0\n                        \n                        # Check support and collisions\n                        supported = False\n                        collision = False\n                        \n                        # Check for collisions with existing items\n                        for placed_item in occupied_volumes:\n                            px, py, pz, pl, pw, ph = placed_item[1], placed_item[2], placed_item[3], placed_item[4], placed_item[5], placed_item[6]\n                            if (cur_x < px + pl and cur_x + item['length'] > px and\n                                cur_y < py + pw and cur_y + item['width'] > py and\n                                cur_z < pz + ph and cur_z + item['height'] > pz):\n                                collision = True\n                                break\n                        \n                        if collision:\n                            continue\n                            \n                        # Check support\n                        support_area = 0.0\n                        total_bottom_area = item['length'] * item['width']\n                        \n                        # Check support from floor\n                        if cur_z == 0.0:\n                            support_area = total_bottom_area\n                            supported = True\n                        else:\n                            for placed_item in occupied_volumes:\n                                px, py, pz, pl, pw, ph = placed_item[1], placed_item[2], placed_item[3], placed_item[4], placed_item[5], placed_item[6]\n                                \n                                # Find overlap in x and y\n                                x_overlap = max(0, min(cur_x + item['length'], px + pl) - max(cur_x, px))\n                                y_overlap = max(0, min(cur_y + item['width'], py + pw) - max(cur_y, py))\n                                \n                                # Add to supported area if item is directly below\n                                if abs(pz + ph - cur_z) < 0.001:\n                                    support_area += x_overlap * y_overlap\n                            \n                            if support_area / total_bottom_area >= 0.8:\n                                supported = True\n                                \n\n                        if not supported:\n                            continue\n                            \n                        # All checks passed\n                        if not collision and supported:\n                            \n                            # Calculate a score based on remaining volume and weight\n                            remaining_volume = (truck_length * truck_width * truck_height -\n                                                sum(vol[4] * vol[5] * vol[6] for vol in [item[1:] for item in truck['occupied_volumes']]))\n                            remaining_weight = truck_capacity - truck['current_weight']\n\n                            score = remaining_volume * remaining_weight\n\n                            if best_truck_index == -1 or score > best_score:\n                                best_truck_index = j\n                                best_item_index = i\n                                best_x = cur_x\n                                best_y = cur_y\n                                best_z = cur_z\n                                best_score = score\n\n    if best_truck_index != -1:\n        # Use an existing truck\n        truck_index = best_truck_index\n        item_index = best_item_index\n        x = best_x\n        y = best_y\n        z = best_z\n    else:\n        # Use a new truck\n        truck_index = -1\n        # Find the best item for a new truck. Here we choose the first item.\n        if len(unplaced_items) > 0:\n            item_index = 0\n            item = unplaced_items[0]\n            \n            # Find the smallest truck that can fit the item\n            best_truck_type_index = -1\n            for k, truck_type in enumerate(truck_types):\n                capacity, truck_length, truck_width, truck_height = truck_type\n                if (item['length'] <= truck_length and\n                    item['width'] <= truck_width and\n                    item['height'] <= truck_height and\n                    item['weight'] <= capacity):\n                    best_truck_type_index = k\n                    break\n            \n            if best_truck_type_index != -1:\n                truck_type_index = best_truck_type_index\n                x = 0.0\n                y = 0.0\n                z = 0.0\n            else:\n                # No truck can fit the item. This should ideally never happen, but handle gracefully.\n                return -1, 0, 0.0, 0.0, 0.0, 0\n    \n    return truck_index, item_index, x, y, z, truck_type_index"
    ],
    [
        "This algorithm iterates through unplaced items and existing trucks, attempting to find a valid placement based on volume constraints, weight capacity, and support, prioritizing smaller items and partially filled trucks, and if no placement is found, opens a new truck.",
        "import numpy as np\n\ndef place_item(unplaced_items, trucks_in_use, truck_types):\n    \"\"\"\n    {This algorithm iterates through unplaced items and existing trucks, attempting to find a valid placement based on volume constraints, weight capacity, and support, prioritizing smaller items and partially filled trucks, and if no placement is found, opens a new truck.}\n    \"\"\"\n\n    truck_index = -1\n    item_index = -1\n    x = 0.0\n    y = 0.0\n    z = 0.0\n    truck_type_index = 0\n\n    # Sort unplaced items by volume (ascending)\n    unplaced_items = sorted(unplaced_items, key=lambda item: item['length'] * item['width'] * item['height'])\n\n    for i, item in enumerate(unplaced_items):\n        item_index = i\n        item_length = item['length']\n        item_width = item['width']\n        item_height = item['height']\n        item_weight = item['weight']\n\n        # Try placing in existing trucks\n        for j, truck in enumerate(trucks_in_use):\n            truck_index = j\n            truck_type_index = truck['truck_type_index']\n            truck_capacity, truck_length, truck_width, truck_height = truck_types[truck_type_index]\n\n            if truck['current_weight'] + item_weight <= truck_capacity:\n                occupied_volumes = truck['occupied_volumes']\n\n                # Find a valid placement within the truck\n                for x in np.arange(0, truck_length - item_length + 0.001, 0.5):\n                    for y in np.arange(0, truck_width - item_width + 0.001, 0.5):\n                        z = 0.0  # Start from the bottom\n\n                        # Check for overlap with existing items\n                        overlap = False\n                        for placed_item in occupied_volumes:\n                            placed_x, placed_y, placed_z = placed_item[1:4]\n                            placed_length, placed_width, placed_height = placed_item[4:7]\n\n                            if (x < placed_x + placed_length and\n                                x + item_length > placed_x and\n                                y < placed_y + placed_width and\n                                y + item_width > placed_y and\n                                z < placed_z + placed_height and\n                                z + item_height > placed_z):\n                                overlap = True\n                                break\n                        if overlap:\n                            continue\n\n                        # Check if the item is supported\n                        supported = False\n                        if z == 0:\n                            supported = True\n                        else:\n                            supported_area = 0.0\n                            item_area = item_length * item_width\n                            for placed_item in occupied_volumes:\n                                placed_x, placed_y, placed_z = placed_item[1:4]\n                                placed_length, placed_width, placed_height = placed_item[4:7]\n\n                                if (x < placed_x + placed_length and\n                                    x + item_length > placed_x and\n                                    y < placed_y + placed_width and\n                                    y + item_width > placed_y and\n                                    z == placed_z + placed_height):\n\n                                    intersect_x_start = max(x, placed_x)\n                                    intersect_x_end = min(x + item_length, placed_x + placed_length)\n                                    intersect_y_start = max(y, placed_y)\n                                    intersect_y_end = min(y + item_width, placed_y + placed_width)\n                                    \n                                    intersect_length = max(0, intersect_x_end - intersect_x_start)\n                                    intersect_width = max(0, intersect_y_end - intersect_y_start)\n                                    \n                                    supported_area += intersect_length * intersect_width\n                            \n                            if supported_area / item_area >= 0.8:\n                                supported = True\n\n                        # If no overlap and is supported, place the item\n                        if not overlap and supported:\n                            return truck_index, item_index, x, y, z, truck_type_index\n\n        # If no placement in existing trucks, open a new truck\n        truck_index = -1\n        \n        # Find the smallest truck that can fit the item\n        best_truck_type_index = -1\n        min_truck_volume = float('inf')\n        for k, truck_type in enumerate(truck_types):\n            capacity, truck_length, truck_width, truck_height = truck_type\n            if (item_length <= truck_length and\n                item_width <= truck_width and\n                item_height <= truck_height and\n                item_weight <= capacity):\n                truck_volume = truck_length * truck_width * truck_height\n                if truck_volume < min_truck_volume:\n                    min_truck_volume = truck_volume\n                    best_truck_type_index = k\n        \n        if best_truck_type_index != -1:\n            truck_type_index = best_truck_type_index\n            x = 0.0\n            y = 0.0\n            z = 0.0\n            return truck_index, item_index, x, y, z, truck_type_index\n\n    # If no truck can fit the item, return the first item and first truck\n    truck_index = -1\n    item_index = 0\n    x = 0.0\n    y = 0.0\n    z = 0.0\n    truck_type_index = 0\n\n    return truck_index, item_index, x, y, z, truck_type_index"
    ],
    [
        "This algorithm prioritizes placing larger, heavier items first, then iterates through existing trucks to find the best fit, considering space, weight capacity, and support, before resorting to opening a new truck if necessary.",
        "import numpy as np\n\ndef place_item(unplaced_items, trucks_in_use, truck_types):\n    \"\"\"\n    {This algorithm prioritizes placing larger, heavier items first, then iterates through existing trucks to find the best fit, considering space, weight capacity, and support, before resorting to opening a new truck if necessary.}\n    \"\"\"\n    truck_index = -1\n    item_index = -1\n    x = -1.0\n    y = -1.0\n    z = -1.0\n    truck_type_index = -1\n\n    # Prioritize items with larger volume and weight\n    item_priorities = []\n    for i, item in enumerate(unplaced_items):\n        item_priorities.append(item['length'] * item['width'] * item['height'] * item['weight'])\n    \n    sorted_item_indices = sorted(range(len(item_priorities)), key=lambda k: item_priorities[k], reverse=True)\n\n    for item_idx in sorted_item_indices:\n        item = unplaced_items[item_idx]\n        item_length = item['length']\n        item_width = item['width']\n        item_height = item['height']\n        item_weight = item['weight']\n\n        best_truck_index = -1\n        best_x = -1.0\n        best_y = -1.0\n        best_z = -1.0\n\n        # Try to fit the item into existing trucks\n        for t_idx, truck in enumerate(trucks_in_use):\n            truck_type_index_current = truck['truck_type_index']\n            truck_capacity, truck_length, truck_width, truck_height = truck_types[truck_type_index_current]\n\n            if truck['current_weight'] + item_weight <= truck_capacity:\n                # Find a suitable position within the truck\n                occupied_volumes = truck['occupied_volumes']\n                \n                # Try placing the item at various locations within the truck\n                for cur_x in np.arange(0, truck_length - item_length + 0.1, min(item_length, 0.5)):\n                    for cur_y in np.arange(0, truck_width - item_width + 0.1, min(item_width, 0.5)):\n                        \n                        # Find the highest z where the item can be placed such that it's either on the floor or supported by other items.\n                        max_z = 0.0\n                        \n                        # Check for support from the floor\n                        \n                        # Check for support from other boxes\n                        for placed_item in occupied_volumes:\n                            placed_item_x = placed_item[1]\n                            placed_item_y = placed_item[2]\n                            placed_item_z = placed_item[3]\n                            placed_item_length = placed_item[4]\n                            placed_item_width = placed_item[5]\n                            placed_item_height = placed_item[6]\n                            \n                            if (cur_x >= placed_item_x - 0.001 and cur_x <= placed_item_x + placed_item_length + 0.001 - item_length and\n                                cur_y >= placed_item_y - 0.001 and cur_y <= placed_item_y + placed_item_width + 0.001 - item_width):\n                                max_z = max(max_z, placed_item_z + placed_item_height)\n\n                        cur_z = max_z\n\n                        if cur_z + item_height <= truck_height:\n\n                            # Check for overlap with existing items\n                            overlap = False\n                            for placed_item in occupied_volumes:\n                                placed_item_x = placed_item[1]\n                                placed_item_y = placed_item[2]\n                                placed_item_z = placed_item[3]\n                                placed_item_length = placed_item[4]\n                                placed_item_width = placed_item[5]\n                                placed_item_height = placed_item[6]\n\n                                if (cur_x < placed_item_x + placed_item_length and\n                                    cur_x + item_length > placed_item_x and\n                                    cur_y < placed_item_y + placed_item_width and\n                                    cur_y + item_width > placed_item_y and\n                                    cur_z < placed_item_z + placed_item_height and\n                                    cur_z + item_height > placed_item_z):\n                                    overlap = True\n                                    break\n\n                            if not overlap:\n                                # Check for support\n                                supported_area = 0.0\n                                if cur_z == 0.0:\n                                    supported_area = item_length * item_width # Supported by floor\n                                else:\n                                    for placed_item in occupied_volumes:\n                                        placed_item_x = placed_item[1]\n                                        placed_item_y = placed_item[2]\n                                        placed_item_z = placed_item[3]\n                                        placed_item_length = placed_item[4]\n                                        placed_item_width = placed_item[5]\n                                        placed_item_height = placed_item[6]\n\n                                        x_overlap = max(0.0, min(cur_x + item_length, placed_item_x + placed_item_length) - max(cur_x, placed_item_x))\n                                        y_overlap = max(0.0, min(cur_y + item_width, placed_item_y + placed_item_width) - max(cur_y, placed_item_y))\n\n                                        if cur_z == placed_item_z + placed_item_height:\n                                            supported_area += x_overlap * y_overlap\n\n                                if supported_area >= 0.8 * item_length * item_width:\n                                    # Found a valid placement\n                                    best_truck_index = t_idx\n                                    best_x = cur_x\n                                    best_y = cur_y\n                                    best_z = cur_z\n                                    break\n                    if best_truck_index != -1:\n                        break\n\n        if best_truck_index != -1:\n            # Use the best truck found\n            truck_index = best_truck_index\n            item_index = item_idx\n            x = best_x\n            y = best_y\n            z = best_z\n            break\n\n    # If no suitable truck was found, open a new truck\n    if truck_index == -1:\n        # Find the smallest truck that can accommodate the item\n        best_truck_type_index = -1\n        min_volume = float('inf')\n\n        for tt_idx, truck_type in enumerate(truck_types):\n            truck_capacity, truck_length, truck_width, truck_height = truck_type\n            if (item_length <= truck_length and item_width <= truck_width and item_height <= truck_height and item_weight <= truck_capacity):\n                volume = truck_length * truck_width * truck_height\n                if volume < min_volume:\n                    min_volume = volume\n                    best_truck_type_index = tt_idx\n\n        if best_truck_type_index != -1:\n            truck_index = -1\n            item_index = item_idx\n            x = 0.0\n            y = 0.0\n            z = 0.0\n            truck_type_index = best_truck_type_index\n        else:\n            # No truck can accommodate the item. This is an error.\n            # Assign a default value so that the simulator won't break.\n            # Ideally, you should handle such a case more gracefully.\n            truck_index = -1\n            item_index = 0\n            x = 0.0\n            y = 0.0\n            z = 0.0\n            truck_type_index = 0\n\n    return truck_index, item_index, x, y, z, truck_type_index"
    ],
    [
        "This algorithm first tries to place items into existing trucks, prioritizing trucks with the least remaining weight capacity, and searching for the best-fit location for the item considering support and overlap; if no suitable truck is found, it selects the smallest truck type that can accommodate the item and creates a new truck.",
        "import numpy as np\n\ndef place_item(unplaced_items, trucks_in_use, truck_types):\n    \"\"\"\n    {This algorithm first tries to place items into existing trucks, prioritizing trucks with the least remaining weight capacity, and searching for the best-fit location for the item considering support and overlap; if no suitable truck is found, it selects the smallest truck type that can accommodate the item and creates a new truck.}\n    \"\"\"\n    truck_index = -1\n    item_index = -1\n    x = -1.0\n    y = -1.0\n    z = -1.0\n    truck_type_index = -1\n\n    # 1. Prioritize placing items in existing trucks\n    for i in range(len(unplaced_items)):\n        item = unplaced_items[i]\n        item_length = item['length']\n        item_width = item['width']\n        item_height = item['height']\n        item_weight = item['weight']\n\n        best_truck_index = -1\n        best_x = -1.0\n        best_y = -1.0\n        best_z = -1.0\n        min_remaining_capacity = float('inf')\n\n        for j in range(len(trucks_in_use)):\n            truck = trucks_in_use[j]\n            truck_type_index_current = truck['truck_type_index']\n            truck_capacity = truck_types[truck_type_index_current][0]\n            truck_length = truck_types[truck_type_index_current][1]\n            truck_width = truck_types[truck_type_index_current][2]\n            truck_height = truck_types[truck_type_index_current][3]\n            truck_current_weight = truck['current_weight']\n            truck_remaining_capacity = truck_capacity - truck_current_weight\n\n            if truck_remaining_capacity >= item_weight:\n                # Find a suitable position in the truck\n                occupied_volumes = truck['occupied_volumes']\n                \n                for current_x in np.arange(0, truck_length - item_length + 0.01, 0.1):\n                    for current_y in np.arange(0, truck_width - item_width + 0.01, 0.1):\n                        current_z = 0.0 \n                        \n                        # Check for support. Find the highest z-coordinate from items below.\n                        max_z_below = 0.0\n                        if occupied_volumes:\n                            for placed_item_id, placed_x, placed_y, placed_z, placed_length, placed_width, placed_height in occupied_volumes:\n                                if (placed_x <= current_x and current_x <= placed_x + placed_length - 0.0001) or (placed_x <= current_x + item_length - 0.0001 and current_x + item_length - 0.0001 <= placed_x + placed_length - 0.0001) or (current_x <= placed_x and placed_x + placed_length - 0.0001 <= current_x + item_length - 0.0001):\n                                    if (placed_y <= current_y and current_y <= placed_y + placed_width - 0.0001) or (placed_y <= current_y + item_width - 0.0001 and current_y + item_width - 0.0001 <= placed_y + placed_width - 0.0001) or (current_y <= placed_y and placed_y + placed_width - 0.0001 <= current_y + item_width - 0.0001):\n                                        max_z_below = max(max_z_below, placed_z + placed_height)\n                        \n                        \n                        current_z = max_z_below\n\n                        # Support condition check: at least 80% of bottom surface area supported\n                        supported_area = 0.0\n                        if current_z == 0.0:\n                            supported_area = item_length * item_width # Supported by truck floor\n                        else: # Supported by other items\n                            for placed_item_id, placed_x, placed_y, placed_z, placed_length, placed_width, placed_height in occupied_volumes:\n                                if placed_z + placed_height == current_z and placed_z != 0:\n                                    x_overlap = max(0, min(current_x + item_length, placed_x + placed_length) - max(current_x, placed_x))\n                                    y_overlap = max(0, min(current_y + item_width, placed_y + placed_width) - max(current_y, placed_y))\n                                    supported_area += x_overlap * y_overlap\n\n                        if supported_area < 0.8 * item_length * item_width:\n                            continue\n                        \n                        # Check for overlap with other items in the truck\n                        overlap = False\n                        for placed_item_id, placed_x, placed_y, placed_z, placed_length, placed_width, placed_height in occupied_volumes:\n                            if (current_x < placed_x + placed_length and\n                                current_x + item_length > placed_x and\n                                current_y < placed_y + placed_width and\n                                current_y + item_width > placed_y and\n                                current_z < placed_z + placed_height and\n                                current_z + item_height > placed_z):\n                                overlap = True\n                                break\n                        \n                        if not overlap and current_z + item_height <= truck_height:\n                            if truck_remaining_capacity < min_remaining_capacity:\n                                best_truck_index = j\n                                best_x = current_x\n                                best_y = current_y\n                                best_z = current_z\n                                min_remaining_capacity = truck_remaining_capacity\n\n        if best_truck_index != -1:\n            truck_index = best_truck_index\n            item_index = i\n            x = best_x\n            y = best_y\n            z = best_z\n            \n            return truck_index, item_index, x, y, z, truck_type_index\n\n    # 2. If no suitable truck is found, create a new truck\n    truck_type_index = -1\n    min_truck_volume = float('inf')\n\n    for k in range(len(truck_types)):\n        truck_type = truck_types[k]\n        truck_capacity = truck_type[0]\n        truck_length = truck_type[1]\n        truck_width = truck_type[2]\n        truck_height = truck_type[3]\n\n        if truck_length >= item_length and truck_width >= item_width and truck_height >= item_height and unplaced_items[i]['weight'] <= truck_capacity:\n            truck_volume = truck_length * truck_width * truck_height\n            if truck_volume < min_truck_volume:\n                min_truck_volume = truck_volume\n                truck_type_index = k\n\n    if truck_type_index != -1:\n        truck_index = -1\n        item_index = i\n        x = 0.0\n        y = 0.0\n        z = 0.0\n        return truck_index, item_index, x, y, z, truck_type_index\n\n    # If no solution is found, return -1 for all values (should not happen if the problem is feasible)\n    return truck_index, item_index, x, y, z, truck_type_index"
    ],
    [
        "This algorithm prioritizes placing items into existing trucks by finding the best-fit position for the largest item based on volume, then attempts to place it, otherwise opens a new truck and places it at the origin if possible.",
        "import numpy as np\n\ndef place_item(unplaced_items, trucks_in_use, truck_types):\n    \"\"\"\n    {This algorithm prioritizes placing items into existing trucks by finding the best-fit position for the largest item based on volume, then attempts to place it, otherwise opens a new truck and places it at the origin if possible.}\n    \"\"\"\n    truck_index = -1\n    item_index = -1\n    x = 0.0\n    y = 0.0\n    z = 0.0\n    truck_type_index = -1\n\n    # Sort unplaced items by volume (descending)\n    item_volumes = [item['length'] * item['width'] * item['height'] for item in unplaced_items]\n    sorted_item_indices = sorted(range(len(unplaced_items)), key=lambda i: item_volumes[i], reverse=True)\n\n    # Iterate through the sorted items\n    for item_idx in sorted_item_indices:\n        item = unplaced_items[item_idx]\n        item_length = item['length']\n        item_width = item['width']\n        item_height = item['height']\n        item_weight = item['weight']\n\n        # Try to place the item in existing trucks\n        for truck_idx, truck in enumerate(trucks_in_use):\n            truck_type_index = truck['truck_type_index']\n            capacity, truck_length, truck_width, truck_height = truck_types[truck_type_index]\n\n            if truck['current_weight'] + item_weight <= capacity:\n                # Find best-fit position within the truck\n                best_x, best_y, best_z = -1, -1, -1\n                min_waste = float('inf')\n                \n                for x in np.arange(0, truck_length - item_length + 0.1, 0.1):\n                    for y in np.arange(0, truck_width - item_width + 0.1, 0.1):\n                        for z in np.arange(0, truck_height - item_height + 0.1, 0.1):\n                            \n                            x, y, z = round(x,1), round(y,1), round(z,1)\n\n                            # Check for overlap with existing items\n                            overlap = False\n                            for existing_item in truck['occupied_volumes']:\n                                if (x < existing_item[1] + existing_item[4] and\n                                    x + item_length > existing_item[1] and\n                                    y < existing_item[2] + existing_item[5] and\n                                    y + item_width > existing_item[2] and\n                                    z < existing_item[3] + existing_item[6] and\n                                    z + item_height > existing_item[3]):\n                                    overlap = True\n                                    break\n                            \n                            if not overlap:\n                                #Check support\n                                supported = False\n                                if z == 0:\n                                    supported = True\n                                else:\n                                    supported_area = 0\n                                    for existing_item in truck['occupied_volumes']:\n                                        if (x < existing_item[1] + existing_item[4] and\n                                            x + item_length > existing_item[1] and\n                                            y < existing_item[2] + existing_item[5] and\n                                            y + item_width > existing_item[2] and\n                                            z == existing_item[3] + existing_item[6]):\n                                            \n                                            x_overlap = max(0, min(x + item_length, existing_item[1] + existing_item[4]) - max(x, existing_item[1]))\n                                            y_overlap = max(0, min(y + item_width, existing_item[2] + existing_item[5]) - max(y, existing_item[2]))\n                                            supported_area += x_overlap * y_overlap\n                                            \n                                    if supported_area / (item_length * item_width) >= 0.8:\n                                        supported = True\n\n                                if supported:\n                                    #Calculate wasted space: the difference between truck total volume and occupied volume.\n                                    waste = (truck_length * truck_width * truck_height) - sum([v[4]*v[5]*v[6] for v in truck['occupied_volumes']]) - (item_length * item_width * item_height)\n                                    if waste < min_waste:\n                                        min_waste = waste\n                                        best_x, best_y, best_z = x, y, z\n\n                # If a valid position is found in the existing truck\n                if best_x != -1:\n                    truck_index = truck_idx\n                    item_index = item_idx\n                    x, y, z = best_x, best_y, best_z\n                    return truck_index, item_index, x, y, z, truck_type_index\n\n        # If no suitable truck is found, open a new truck\n        for truck_type_idx, truck_type in enumerate(truck_types):\n            capacity, truck_length, truck_width, truck_height = truck_type\n            if item_weight <= capacity:\n                truck_index = -1\n                item_index = item_idx\n                x = 0.0\n                y = 0.0\n                z = 0.0\n                truck_type_index = truck_type_idx\n                return truck_index, item_index, x, y, z, truck_type_index\n\n    #Should never reach here, but returning -1s to avoid errors\n    return truck_index, item_index, x, y, z, truck_type_index"
    ]
]