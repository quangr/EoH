[
     {
          "algorithm": "Prioritizes placing items into partially filled trucks based on a volume utilization score, selecting the item that minimizes wasted space after placement and respects separation constraints.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Prioritizes placing items into partially filled trucks based on a volume utilization score, selecting the item that minimizes wasted space after placement and respects separation constraints.}\n\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_placement_score = float('inf')\n        \n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] <= 0:\n                continue\n            \n            for truck_index, truck in enumerate(trucks_in_use):\n                if (item.get('separation_set') is not None and truck.get('separation_set') is not None and\n                        item['separation_set'] != truck['separation_set']):\n                    continue\n                \n                x, y, z, orientation, score = self._evaluate_placement_in_truck(item, truck, truck_type)\n                \n                if x != -1 and score < best_placement_score:\n                    best_truck_index = truck_index\n                    best_item_index = item_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n                    best_placement_score = score\n        \n        if best_truck_index == -1:\n            best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation = self._find_placement_in_new_truck(unplaced_items, truck_type)\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n    \n    def _find_placement_in_new_truck(self, unplaced_items, truck_type):\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        \n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] <= 0:\n                continue\n            \n            x, y, z, orientation = self._find_first_position_for_item(item, truck_type)\n            \n            if x != -1:\n                best_item_index = item_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n                break\n        \n        return -1, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _evaluate_placement_in_truck(self, item, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = float('inf')\n        \n        for orientation_index, (orientation, item_dims) in enumerate(self._get_orientations(item)):\n            x, y, z = self._find_bottom_left_back_position(item_dims, truck, truck_type)\n            \n            if x != -1:\n                \n                score = self._calculate_placement_score(item_dims, truck, truck_type)\n                \n                if score < best_score:\n                    best_score = score\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation_index\n        \n        return best_x, best_y, best_z, best_score\n    \n    def _calculate_placement_score(self, item_dims, truck, truck_type):\n        truck_volume = truck_type[0] * truck_type[1] * truck_type[2]\n        item_volume = item_dims[0] * item_dims[1] * item_dims[2]\n        occupied_volume = sum([v['length'] * v['width'] * v['height'] for v in truck['occupied_volumes']])\n        remaining_volume = truck_volume - occupied_volume\n        \n        wasted_space = remaining_volume - item_volume\n        \n        utilization = occupied_volume / truck_volume if truck_volume > 0 else 0\n        \n        return wasted_space \n\n    def _find_bottom_left_back_position(self, item_dims, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n\n        cl, cw, ch = container_dims\n        pl, pw, ph = item_dims\n\n        x_candidates = [0.0]\n        y_candidates = [0.0]\n        z_candidates = [0.0]\n\n        for placed_item in occupied_volumes:\n            x_candidates.append(placed_item['x'] + placed_item['length'])\n            y_candidates.append(placed_item['y'] + placed_item['width'])\n            z_candidates.append(placed_item['z'] + placed_item['height'])\n        \n        x_candidates = sorted(list(set([x for x in x_candidates if x >= 0 and x + pl <= cl + self.epsilon])))\n        y_candidates = sorted(list(set([y for y in y_candidates if y >= 0 and y + pw <= cw + self.epsilon])))\n        z_candidates = sorted(list(set([z for z in z_candidates if z >= 0 and z + ph <= ch + self.epsilon])))\n        \n        for z in z_candidates:\n            for y in y_candidates:\n                for x in x_candidates:\n                    if self._is_valid_placement((x, y, z), (pl, pw, ph), container_dims, occupied_volumes):\n                        return x, y, z\n        \n        return -1, -1, -1\n\n    def _find_first_position_for_item(self, item, truck_type):\n        for orientation_index, (orientation, item_dims) in enumerate(self._get_orientations(item)):\n            if self._is_within_container_bounds((0,0,0), item_dims, truck_type):\n                return 0, 0, 0, orientation_index\n        return -1, -1, -1, -1\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _evaluate_placement_in_truck(self, item, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = float('inf')\n        \n        for orientation_index, (orientation, item_dims) in enumerate(self._get_orientations(item)):\n            x, y, z = self._find_bottom_left_back_position(item_dims, truck, truck_type)\n            \n            if x != -1:\n                \n                score = self._calculate_placement_score(item_dims, truck, truck_type)\n                \n                if score < best_score:\n                    best_score = score\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation_index\n        \n        return best_x, best_y, best_z, best_orientation, best_score",
          "objective": 25.15,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     },
     {
          "algorithm": "Selects the item with the highest volume-to-quantity ratio and places it in the most suitable existing truck or a new truck using a bottom-left-back placement strategy.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item with the highest volume-to-quantity ratio and places it in the most suitable existing truck or a new truck using a bottom-left-back placement strategy.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index is None:\n            return None, None, None, None, None, None\n\n        truck_index, x, y, z, orientation = self._find_best_truck_and_placement(item_index, unplaced_items, trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = None\n        best_ratio = -1\n\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                volume = item['length'] * item['width'] * item['height']\n                ratio = volume / item['quantity']\n                if ratio > best_ratio:\n                    best_ratio = ratio\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_truck_and_placement(self, item_index, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x, best_y, best_z, best_orientation = None, None, None, None\n        best_volume_utilization = -1\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if self._is_truck_compatible(unplaced_items[item_index], truck):\n                x, y, z, orientation, volume_utilization = self._find_best_position_in_truck(item_index, unplaced_items, truck, truck_type)\n                if x is not None and volume_utilization > best_volume_utilization:\n                    best_truck_index = truck_index\n                    best_x, best_y, best_z, best_orientation = x, y, z, orientation\n                    best_volume_utilization = volume_utilization\n\n        x, y, z, orientation, volume_utilization = self._find_best_position_new_truck(item_index, unplaced_items, truck_type)\n        if x is not None and volume_utilization > best_volume_utilization:\n            best_truck_index = -1\n            best_x, best_y, best_z, best_orientation = x, y, z, orientation\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _is_truck_compatible(self, item, truck):\n        if item.get('separation_set') is None:\n            return True\n        if truck.get('separation_set') is None:\n            return True\n        return item['separation_set'] == truck['separation_set']\n\n    def _find_best_position_in_truck(self, item_index, unplaced_items, truck, truck_type):\n        best_x, best_y, best_z, best_orientation = None, None, None, None\n        best_volume_utilization = -1\n        item = unplaced_items[item_index]\n        for orientation_index, (ox, (length, width, height)) in enumerate(self._get_orientations(item)):\n            x, y, z = self._find_bottom_left_back_position((length, width, height), truck, truck_type)\n            if x is not None:\n                if self._is_valid_placement((x, y, z), (length, width, height), truck_type, truck['occupied_volumes']):\n                    volume_utilization = self._evaluate_placement((x, y, z), (length, width, height), truck, truck_type)\n                    if volume_utilization > best_volume_utilization:\n                        best_x, best_y, best_z, best_orientation = x, y, z, orientation_index\n                        best_volume_utilization = volume_utilization\n\n        return best_x, best_y, best_z, best_orientation, best_volume_utilization\n\n    def _find_best_position_new_truck(self, item_index, unplaced_items, truck_type):\n        best_x, best_y, best_z, best_orientation = None, None, None, None\n        best_volume_utilization = -1\n        item = unplaced_items[item_index]\n\n        for orientation_index, (ox, (length, width, height)) in enumerate(self._get_orientations(item)):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                volume_utilization = length * width * height / (truck_type[0] * truck_type[1] * truck_type[2])\n                if volume_utilization > best_volume_utilization:\n                     best_x, best_y, best_z, best_orientation = 0.0, 0.0, 0.0, orientation_index\n                     best_volume_utilization = volume_utilization\n        return best_x, best_y, best_z, best_orientation, best_volume_utilization\n\n    def _find_bottom_left_back_position(self, item_dims, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n\n        cl, cw, ch = container_dims\n        pl, pw, ph = item_dims\n\n        x_candidates = [0.0]\n        y_candidates = [0.0]\n        z_candidates = [0.0]\n\n        for placed_item in occupied_volumes:\n            x_candidates.append(placed_item['x'] + placed_item['length'])\n            y_candidates.append(placed_item['y'] + placed_item['width'])\n            z_candidates.append(placed_item['z'] + placed_item['height'])\n\n        x_candidates = sorted(list(set([x for x in x_candidates if x >= 0 and x + pl <= cl + self.epsilon])))\n        y_candidates = sorted(list(set([y for y in y_candidates if y >= 0 and y + pw <= cw + self.epsilon])))\n        z_candidates = sorted(list(set([z for z in z_candidates if z >= 0 and z + ph <= ch + self.epsilon])))\n\n        for z in z_candidates:\n            for y in y_candidates:\n                for x in x_candidates:\n                    is_valid = True\n                    for placed_item in occupied_volumes:\n                        if self._check_overlap_3d((x, y, z), item_dims, (placed_item['x'], placed_item['y'], placed_item['z']), (placed_item['length'], placed_item['width'], placed_item['height'])):\n                            is_valid = False\n                            break\n                    if is_valid:\n                        return x, y, z\n\n        return None, None, None\n\n    def _evaluate_placement(self, position, dimensions, truck, truck_type):\n        x, y, z = position\n        length, width, height = dimensions\n        occupied_volumes = truck['occupied_volumes']\n        truck_volume= truck_type[0] * truck_type[1] * truck_type[2]\n        occupied_volume = sum([v['length'] * v['width'] * v['height'] for v in occupied_volumes])\n        remaining_volume = truck_volume - occupied_volume\n        return (length*width*height) / remaining_volume",
          "objective": 25.2,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Iteratively place items by prioritizing volume utilization, separation constraints, and bottom-left-back placement within existing or new trucks.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Iteratively place items by prioritizing volume utilization, separation constraints, and bottom-left-back placement within existing or new trucks.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_volume_utilization = -1\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                for truck_index, truck in enumerate(trucks_in_use):\n                    if (item.get('separation_set') is None or truck.get('separation_set') is None or\n                            item['separation_set'] == truck['separation_set']):\n                        x, y, z, orientation = self._find_placement_in_truck(item, truck, truck_type)\n                        if x != -1:\n                            item_dims = self._get_orientations(item)[orientation][1]\n                            volume = item_dims[0] * item_dims[1] * item_dims[2]\n                            truck_volume = truck_type[0] * truck_type[1] * truck_type[2]\n                            occupied_volume = sum([v['length'] * v['width'] * v['height'] for v in truck['occupied_volumes']])\n                            new_occupied_volume = occupied_volume + volume\n                            volume_utilization = new_occupied_volume / truck_volume\n                            \n                            if volume_utilization > best_volume_utilization:\n                                best_truck_index = truck_index\n                                best_item_index = item_index\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation\n                                best_volume_utilization = volume_utilization\n\n        if best_truck_index == -1:\n            best_item_index = self._find_best_item_for_new_truck(unplaced_items)\n            if best_item_index != -1:\n                item = unplaced_items[best_item_index]\n                x, y, z, best_orientation = self._find_first_position_for_item(item, truck_type)\n                best_x = x\n                best_y = y\n                best_z = z\n\n\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_placement_in_truck(self, item, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n\n        for orientation_index, (orientation, item_dims) in enumerate(self._get_orientations(item)):\n            \n            x, y, z = self._find_bottom_left_back_position(item_dims, truck, truck_type)\n            if x != -1:\n                return x, y, z, orientation_index\n        return best_x, best_y, best_z\n\n    def _find_first_position_for_item(self, item, truck_type):\n        for orientation_index, (orientation, item_dims) in enumerate(self._get_orientations(item)):\n            if self._is_within_container_bounds((0,0,0), item_dims, truck_type):\n                return 0, 0, 0, orientation_index\n        return -1,-1,-1,-1\n\n    def _find_bottom_left_back_position(self, item_dims, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n\n        cl, cw, ch = container_dims\n        pl, pw, ph = item_dims\n\n        x_candidates = [0.0]\n        y_candidates = [0.0]\n        z_candidates = [0.0]\n\n        for placed_item in occupied_volumes:\n            x_candidates.append(placed_item['x'] + placed_item['length'])\n            y_candidates.append(placed_item['y'] + placed_item['width'])\n            z_candidates.append(placed_item['z'] + placed_item['height'])\n\n            x_candidates.append(placed_item['x'] - pl)\n            y_candidates.append(placed_item['y'] - pw)\n            z_candidates.append(placed_item['z'] - ph)\n        \n        x_candidates = sorted(list(set([x for x in x_candidates if x >= 0 and x + pl <= cl + self.epsilon])))\n        y_candidates = sorted(list(set([y for y in y_candidates if y >= 0 and y + pw <= cw + self.epsilon])))\n        z_candidates = sorted(list(set([z for z in z_candidates if z >= 0 and z + ph <= ch + self.epsilon])))\n\n        for z in z_candidates:\n            for y in y_candidates:\n                for x in x_candidates:\n                    if self._is_valid_placement((x, y, z), (pl, pw, ph), container_dims, occupied_volumes):\n                        return x, y, z\n        return -1, -1, -1\n    \n    def _find_best_item_for_new_truck(self, unplaced_items):\n        \n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                if item.get('separation_set') is None:\n                    return item_index\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                return item_index\n        return -1\nclass AlgorithmFIX1(Algorithm):\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_volume_utilization = -1\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                for truck_index, truck in enumerate(trucks_in_use):\n                    if (item.get('separation_set') is None or truck.get('separation_set') is None or\n                            item['separation_set'] == truck['separation_set']):\n                        x, y, z, orientation = self._find_placement_in_truck(item, truck, truck_type)\n                        if x != -1:\n                            item_dims = self._get_orientations(item)[orientation][1]\n                            volume = item_dims[0] * item_dims[1] * item_dims[2]\n                            truck_volume = truck_type[0] * truck_type[1] * truck_type[2]\n                            occupied_volume = sum([v['length'] * v['width'] * v['height'] for v in truck['occupied_volumes']])\n                            new_occupied_volume = occupied_volume + volume\n                            volume_utilization = new_occupied_volume / truck_volume\n                            \n                            if volume_utilization > best_volume_utilization:\n                                best_truck_index = truck_index\n                                best_item_index = item_index\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation\n                                best_volume_utilization = volume_utilization\n\n        if best_truck_index == -1:\n            best_item_index = self._find_best_item_for_new_truck(unplaced_items)\n            if best_item_index != -1:\n                item = unplaced_items[best_item_index]\n                x, y, z, best_orientation = self._find_first_position_for_item(item, truck_type)\n                if x != -1:\n                    best_truck_index = -1\n                    best_x = x\n                    best_y = y\n                    best_z = z\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_first_position_for_item(self, item, truck_type):\n        for orientation_index, (orientation, item_dims) in enumerate(self._get_orientations(item)):\n            if self._is_within_container_bounds((0,0,0), item_dims, truck_type):\n                return 0, 0, 0, orientation_index\n        return -1, -1, -1, -1\nclass AlgorithmFIX3(AlgorithmFIX2):\n    def _find_placement_in_truck(self, item, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n\n        for orientation_index, (orientation, item_dims) in enumerate(self._get_orientations(item)):\n            \n            x, y, z = self._find_bottom_left_back_position(item_dims, truck, truck_type)\n            if x != -1:\n                return x, y, z, orientation_index\n        return best_x, best_y, best_z, best_orientation",
          "objective": 25.25,
          "other_inf": null,
          "class_name": "AlgorithmFIX3"
     },
     {
          "algorithm": "Places items by prioritizing items with smaller dimensions and maximizing space utilization based on scoring valid placements.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Places items by prioritizing items with smaller dimensions and maximizing space utilization based on scoring valid placements.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = -1\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                for truck_index, truck in enumerate(trucks_in_use):\n                    if (item.get('separation_set') is None or truck.get('separation_set') is None or\n                            item['separation_set'] == truck['separation_set']):\n                        x, y, z, orientation, score = self._evaluate_placements_in_truck(item, truck, truck_type)\n                        if score > best_score:\n                            best_truck_index = truck_index\n                            best_item_index = item_index\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            best_orientation = orientation\n                            best_score = score\n\n        if best_truck_index == -1:\n            best_item_index, x, y, z, best_orientation = self._find_placement_for_new_truck(unplaced_items, truck_type)\n            if best_item_index != -1:\n                best_truck_index = -1\n                best_x = x\n                best_y = y\n                best_z = z\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _evaluate_placements_in_truck(self, item, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = -1\n\n        for orientation_index, (orientation, item_dims) in enumerate(self._get_orientations(item)):\n            x, y, z = self._find_position_for_item(item_dims, truck, truck_type)\n            if x != -1:\n                score = self._calculate_placement_score((x,y,z), item_dims, truck, truck_type)\n                if score > best_score:\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation_index\n                    best_score = score\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_placement_for_new_truck(self, unplaced_items, truck_type):\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = -1\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                for orientation_index, (orientation, item_dims) in enumerate(self._get_orientations(item)):\n                    if self._is_within_container_bounds((0, 0, 0), item_dims, truck_type):\n                        score = item_dims[0] * item_dims[1] * item_dims[2]\n                        if score > best_score:\n                            best_item_index = item_index\n                            best_x = 0\n                            best_y = 0\n                            best_z = 0\n                            best_orientation = orientation_index\n                            best_score = score\n\n        return best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_for_item(self, item_dims, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n\n        cl, cw, ch = container_dims\n        pl, pw, ph = item_dims\n\n        x_candidates = [0.0]\n        y_candidates = [0.0]\n        z_candidates = [0.0]\n\n        for placed_item in occupied_volumes:\n            x_candidates.append(placed_item['x'] + placed_item['length'])\n            y_candidates.append(placed_item['y'] + placed_item['width'])\n            z_candidates.append(placed_item['z'] + placed_item['height'])\n\n        x_candidates = sorted(list(set([x for x in x_candidates if x >= 0 and x + pl <= cl + self.epsilon])))\n        y_candidates = sorted(list(set([y for y in y_candidates if y >= 0 and y + pw <= cw + self.epsilon])))\n        z_candidates = sorted(list(set([z for z in z_candidates if z >= 0 and z + ph <= ch + self.epsilon])))\n\n        for z in z_candidates:\n            for y in y_candidates:\n                for x in x_candidates:\n                    if self._is_valid_placement((x, y, z), (pl, pw, ph), container_dims, occupied_volumes):\n                        return x, y, z\n        return -1, -1, -1\n\n    def _calculate_placement_score(self, position, dimensions, truck, truck_type):\n        x, y, z = position\n        l, w, h = dimensions\n        volume = l * w * h\n        cl, cw, ch = truck_type\n\n        distance_from_center = np.sqrt(\n            ((x + l / 2) - cl / 2) ** 2 +\n            ((y + w / 2) - cw / 2) ** 2 +\n            ((z + h / 2) - ch / 2) ** 2\n        )\n\n        utilization_rate = volume / (cl * cw * ch)\n\n        return utilization_rate / (1 + distance_from_center)",
          "objective": 25.5,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Iteratively place items selecting the item type with largest remaining quantity and placing it using a skyline-based approach into the most suitable truck.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Iteratively place items selecting the item type with largest remaining quantity and placing it using a skyline-based approach into the most suitable truck.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = -1\n\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, -1, -1, -1, -1\n\n        item = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if (item.get('separation_set') is None or truck.get('separation_set') is None or\n                    item['separation_set'] == truck['separation_set']):\n                x, y, z, orientation, score = self._find_skyline_placement_in_truck(item, truck, truck_type)\n                if x != -1 and score > best_score:\n                    best_truck_index = truck_index\n                    best_item_index = item_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n                    best_score = score\n\n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._find_placement_new_truck(item_index, unplaced_items, truck_type)\n            if best_truck_index !=-2:#best_truck_index get a -2 indicate that current item cannot be placed whether existing truck or adding new truck\n\n                best_item_index = item_index\n                \n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_quantity = -1\n        for i, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                if item['quantity'] > max_quantity:\n                    max_quantity = item['quantity']\n                    best_item_index = i\n        return best_item_index\n\n    def _find_skyline_placement_in_truck(self, item, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = -1\n\n        for orientation_index, (orientation, item_dims) in enumerate(self._get_orientations(item)):\n            x, y, z, score = self._find_skyline_position(item_dims, truck, truck_type)\n            if x != -1 and score > best_score:\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation_index\n                best_score = score\n\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_skyline_position(self, item_dims, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n        L, W, H = container_dims\n        l, w, h = item_dims\n\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_score = -1\n\n        if not occupied_volumes:\n            if self._is_within_container_bounds((0, 0, 0), item_dims, container_dims):\n                return 0, 0, 0, 1.0\n            else:\n                return -1, -1, -1, -1\n\n        for placed_item in occupied_volumes:\n            x0, y0, z0 = placed_item['x'] + placed_item['length'], placed_item['y'], placed_item['z']\n            if self._is_valid_placement((x0, y0, z0), item_dims, container_dims, occupied_volumes):\n                    score =  (L - (x0 + l)) / L\n                    if score > best_score:\n                        best_x, best_y, best_z= x0, y0, z0\n                        best_score = score\n\n            x0, y0, z0 = placed_item['x'], placed_item['y']+ placed_item['width'], placed_item['z']\n            if self._is_valid_placement((x0, y0, z0), item_dims, container_dims, occupied_volumes):\n                score = (W - (y0 + w)) / W\n                if score > best_score:\n                    best_x, best_y, best_z = x0, y0, z0\n                    best_score = score\n            \n            x0, y0, z0 = placed_item['x'], placed_item['y'], placed_item['z]'] + placed_item['height']\n            if self._is_valid_placement((x0, y0, z0), item_dims, container_dims, occupied_volumes):\n                score = (H - (z0 + h)) / H\n                if score > best_score:\n                    best_x, best_y, best_z = x0, y0, z0\n                    best_score = score        \n        \n\n        return best_x, best_y, best_z, best_score\n\n    def _find_placement_new_truck(self, item_index, unplaced_items, truck_type):\n        item = unplaced_items[item_index]\n        for orientation_index, (orientation, item_dims) in enumerate(self._get_orientations(item)):\n            if self._is_within_container_bounds((0, 0, 0), item_dims, truck_type):\n                return -1, 0, 0, 0, orientation_index\n        return -2, -1, -1, -1, -1\nclass AlgorithmFIX1(Algorithm):\n    def _find_skyline_position(self, item_dims, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n        L, W, H = container_dims\n        l, w, h = item_dims\n\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_score = -1\n\n        if not occupied_volumes:\n            if self._is_within_container_bounds((0, 0, 0), item_dims, container_dims):\n                return 0, 0, 0, 1.0\n            else:\n                return -1, -1, -1, -1\n\n        for placed_item in occupied_volumes:\n            x0, y0, z0 = placed_item['x'] + placed_item['length'], placed_item['y'], placed_item['z']\n            if self._is_valid_placement((x0, y0, z0), item_dims, container_dims, occupied_volumes):\n                    score =  (L - (x0 + l)) / L\n                    if score > best_score:\n                        best_x, best_y, best_z= x0, y0, z0\n                        best_score = score\n\n            x0, y0, z0 = placed_item['x'], placed_item['y']+ placed_item['width'], placed_item['z']\n            if self._is_valid_placement((x0, y0, z0), item_dims, container_dims, occupied_volumes):\n                score = (W - (y0 + w)) / W\n                if score > best_score:\n                    best_x, best_y, best_z = x0, y0, z0\n                    best_score = score\n            \n            x0, y0, z0 = placed_item['x'], placed_item['y'], placed_item['z'] + placed_item['height']\n            if self._is_valid_placement((x0, y0, z0), item_dims, container_dims, occupied_volumes):\n                score = (H - (z0 + h)) / H\n                if score > best_score:\n                    best_x, best_y, best_z = x0, y0, z0\n                    best_score = score        \n        \n\n        return best_x, best_y, best_z, best_score",
          "objective": 25.85,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     }
]