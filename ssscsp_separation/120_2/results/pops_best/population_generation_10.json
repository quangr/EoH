{
     "algorithm": "Selects the item with the largest footprint area and places it at the bottom-left-most available position, prioritizing separation constraints.",
     "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item with the largest footprint area and places it at the bottom-left-most available position, prioritizing separation constraints.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_footprint = -1\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                for truck_index, truck in enumerate(trucks_in_use):\n                    if self._is_truck_compatible(item, truck):\n                        x, y, z, orientation, footprint = self._find_best_position_in_truck(item, truck, truck_type)\n                        if x != -1 and footprint > best_footprint:\n                            best_truck_index = truck_index\n                            best_item_index = item_index\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            best_orientation = orientation\n                            best_footprint = footprint\n\n        if best_truck_index == -1:\n            best_item_index, x, y, z, best_orientation, footprint = self._find_best_position_new_truck(unplaced_items, truck_type)\n            if best_item_index != -1:\n                best_truck_index = -1\n                best_x = x\n                best_y = y\n                best_z = z\n                best_footprint = footprint\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _is_truck_compatible(self, item, truck):\n        if item.get('separation_set') is None:\n            return True\n        if truck.get('separation_set') is None:\n            return True\n        return item['separation_set'] == truck['separation_set']\n\n    def _find_best_position_in_truck(self, item, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_footprint = -1\n\n        for orientation_index, (orientation, item_dims) in enumerate(self._get_orientations(item)):\n            x, y, z = self._find_bottom_left_most_position(item_dims, truck, truck_type)\n            if x != -1:\n                if self._is_valid_placement((x, y, z), item_dims, truck_type, truck['occupied_volumes']):\n                    footprint = item_dims[0] * item_dims[1]\n                    if footprint > best_footprint:\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n                        best_footprint = footprint\n\n        return best_x, best_y, best_z, best_orientation, best_footprint\n\n    def _find_best_position_new_truck(self, unplaced_items, truck_type):\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_footprint = -1\n\n        for item_index, item in enumerate(unplaced_items):\n            if item['quantity'] > 0:\n                for orientation_index, (orientation, item_dims) in enumerate(self._get_orientations(item)):\n                    if self._is_within_container_bounds((0, 0, 0), item_dims, truck_type):\n                        footprint = item_dims[0] * item_dims[1]\n                        if footprint > best_footprint:\n                            best_item_index = item_index\n                            best_x = 0\n                            best_y = 0\n                            best_z = 0\n                            best_orientation = orientation_index\n                            best_footprint = footprint\n        return best_item_index, best_x, best_y, best_z, best_orientation, best_footprint\n\n    def _find_bottom_left_most_position(self, item_dims, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n\n        cl, cw, ch = container_dims\n        pl, pw, ph = item_dims\n\n        x_candidates = [0.0]\n        y_candidates = [0.0]\n        z_candidates = [0.0]\n\n        for placed_item in occupied_volumes:\n            x_candidates.append(placed_item['x'] + placed_item['length'])\n            y_candidates.append(placed_item['y'] + placed_item['width'])\n            z_candidates.append(placed_item['z'] + placed_item['height'])\n\n        x_candidates = sorted(list(set([x for x in x_candidates if x >= 0 and x + pl <= cl + self.epsilon])))\n        y_candidates = sorted(list(set([y for y in y_candidates if y >= 0 and y + pw <= cw + self.epsilon])))\n        z_candidates = sorted(list(set([z for z in z_candidates if z >= 0 and z + ph <= ch + self.epsilon])))\n        \n        for z in z_candidates:\n            for y in y_candidates:\n                for x in x_candidates:\n                    is_valid = True\n                    for placed_item in occupied_volumes:\n                        if self._check_overlap_3d((x, y, z), item_dims, (placed_item['x'], placed_item['y'], placed_item['z']), (placed_item['length'], placed_item['width'], placed_item['height'])):\n                            is_valid = False\n                            break\n                    if is_valid:\n                        return x, y, z\n\n        return -1, -1, -1",
     "objective": 23.05,
     "other_inf": null,
     "class_name": "Algorithm"
}