{
     "algorithm": "This algorithm prioritizes placing items into existing trucks using a first-fit decreasing height strategy, selecting the most constrained item type and orientation that minimizes remaining space and respects separation constraints, while creating new trucks only when necessary.",
     "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes placing items into existing trucks using a first-fit decreasing height strategy, selecting the most constrained item type and orientation that minimizes remaining space and respects separation constraints, while creating new trucks only when necessary.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index = -1\n        item_index = -1\n        x, y, z = 0.0, 0.0, 0.0\n        orientation = 0\n\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x, best_y, best_z = 0.0, 0.0, 0.0\n        best_orientation = 0\n        min_waste = float('inf')\n\n        \n        for item_idx, item in enumerate(unplaced_items):\n            if item['quantity'] <= 0:\n                continue\n            \n            for truck_idx, truck in enumerate(trucks_in_use):\n                if item.get('separation_set') is not None and truck.get('separation_set') is not None and item['separation_set'] != truck['separation_set']:\n                    continue\n                \n                x, y, z, orientation, waste = self._find_position_for_item_in_truck(item, truck, truck_type)\n                \n                if x is not None and waste < min_waste:\n                    min_waste = waste\n                    best_truck_index = truck_idx\n                    best_item_index = item_idx\n                    best_x, best_y, best_z = x, y, z\n                    best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_item_index, best_x, best_y, best_z, best_orientation, waste = self._find_best_placement_in_new_truck(unplaced_items, truck_type)\n        \n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_placement_in_new_truck(self, unplaced_items, truck_type):\n        best_item_index = -1\n        best_x, best_y, best_z = 0.0, 0.0, 0.0\n        best_orientation = 0\n        min_waste = float('inf')\n        \n        for item_idx, item in enumerate(unplaced_items):\n            if item['quantity'] <= 0:\n                continue\n            \n            x, y, z, orientation, waste = self._find_position_for_item_new_truck(item, truck_type)\n            if x is not None and waste < min_waste:\n                min_waste = waste\n                best_item_index = item_idx\n                best_x, best_y, best_z = x, y, z\n                best_orientation = orientation\n\n        return best_item_index, best_x, best_y, best_z, best_orientation, min_waste\n\n    def _find_position_for_item_new_truck(self, item, truck_type):\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        min_waste = float('inf')\n\n        for orientation_idx, (orientation, dims) in enumerate(self._get_orientations(item)):\n            if self._is_within_container_bounds((0.0, 0.0, 0.0), dims, truck_type):\n                waste = self._calculate_waste(dims, truck_type)\n                if waste < min_waste:\n                    min_waste = waste\n                    best_x, best_y, best_z = 0.0, 0.0, 0.0\n                    best_orientation = orientation_idx\n\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _find_position_for_item_in_truck(self, item, truck, truck_type):\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        min_waste = float('inf')\n\n        for orientation_idx, (orientation, dims) in enumerate(self._get_orientations(item)):\n            possible_positions = self._find_possible_positions(truck, truck_type, dims)\n                \n            for x, y, z in possible_positions:                    \n                if self._is_valid_placement((x, y, z), dims, truck_type, truck['occupied_volumes']):\n                    waste = self._calculate_waste(dims, truck_type)\n                    if waste < min_waste:\n                        min_waste = waste\n                        best_x, best_y, best_z = x, y, z\n                        best_orientation = orientation_idx\n\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _find_possible_positions(self, truck, truck_type, item_dims):\n        positions = []\n        \n        if not truck['occupied_volumes']:\n            return [(0.0, 0.0, 0.0)]\n\n        \n        for placed_item in truck['occupied_volumes']:\n            x = placed_item['x'] + placed_item['length']\n            y = placed_item['y']\n            z = placed_item['z']\n            if self._is_within_container_bounds((x, y, z), item_dims, truck_type):\n                positions.append((x, y, z))\n\n            x = placed_item['x']\n            y = placed_item['y'] + placed_item['width']\n            z = placed_item['z']\n            if self._is_within_container_bounds((x, y, z), item_dims, truck_type):\n                positions.append((x, y, z))\n\n            x = placed_item['x']\n            y = placed_item['y']\n            z = placed_item['z'] + placed_item['height']\n            if self._is_within_container_bounds((x, y, z), item_dims, truck_type):\n                positions.append((x, y, z))\n        return positions\n        \n\n    def _calculate_waste(self, item_dims, container_dims):\n        item_volume = item_dims[0] * item_dims[1] * item_dims[2]\n        container_volume = container_dims[0] * container_dims[1] * container_dims[2]\n        return container_volume - item_volume",
     "objective": 25.2,
     "other_inf": null,
     "class_name": "Algorithm"
}