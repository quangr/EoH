{
     "algorithm": "This algorithm selects the best placement by prioritizing items with smaller footprint area, and maximizing space utilization with an emphasis on minimizing wasted space along all axes.",
     "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm selects the best placement by prioritizing items with smaller footprint area, and maximizing space utilization with an emphasis on minimizing wasted space along all axes.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        return self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation, best_score = -1, -1, -1, -1, -1, -1, float('-inf')\n        for item_index in self._sort_items_by_footprint(unplaced_items):\n            item_type = unplaced_items[item_index]\n            if item_type['quantity'] <= 0:\n                continue\n\n            truck_index, x, y, z, orientation, score = self._find_placement_in_existing_trucks(item_type, trucks_in_use, truck_type)\n            if score > best_score:\n                best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation, best_score = truck_index, item_index, x, y, z, orientation, score\n\n            if best_truck_index == -1:\n                x, y, z, orientation, score = self._find_placement_in_new_truck(item_type, truck_type)\n                if score > best_score:\n                    best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation, best_score = -1, item_index, x, y, z, orientation, score\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_placement_in_existing_trucks(self, item_type, trucks_in_use, truck_type):\n        best_truck_index, best_x, best_y, best_z, best_orientation, best_score = -1, -1, -1, -1, -1, float('-inf')\n        for truck_index, truck in enumerate(trucks_in_use):\n            if truck['separation_set'] is not None and item_type.get('separation_set') is not None and truck['separation_set'] != item_type['separation_set']:\n                continue\n            x, y, z, orientation, score = self._find_best_position_for_item(item_type, truck_type, truck['occupied_volumes'])\n            if score > best_score:\n                best_truck_index, best_x, best_y, best_z, best_orientation, best_score = truck_index, x, y, z, orientation, score\n        return best_truck_index, best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_placement_in_new_truck(self, item_type, truck_type):\n        occupied_volumes = []\n        x, y, z, orientation, score = self._find_best_position_for_item(item_type, truck_type, occupied_volumes)\n        return x, y, z, orientation, score\n\n    def _sort_items_by_footprint(self, unplaced_items):\n        return sorted(range(len(unplaced_items)), key=lambda k: unplaced_items[k]['length'] * unplaced_items[k]['width'], reverse=False)\n\n    def _find_best_position_for_item(self, item_type, container_dims, occupied_volumes):\n        best_x, best_y, best_z, best_orientation, best_score = -1, -1, -1, -1, float('-inf')\n        for orientation, dims in self._get_orientations(item_type):\n            l, w, h = dims\n            for x, y, z in self._generate_candidate_positions(container_dims, occupied_volumes, dims):\n                if self._is_valid_placement((x, y, z), (l, w, h), container_dims, occupied_volumes):\n                    score = self._calculate_score((x, y, z), (l, w, h), container_dims, occupied_volumes)\n                    if score > best_score:\n                        best_x, best_y, best_z, best_orientation, best_score = x, y, z, orientation, score\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _calculate_score(self, item_pos, item_dims, container_dims, occupied_volumes):\n        x, y, z = item_pos\n        l, w, h = item_dims\n        cl, cw, ch = container_dims\n        space_utilization = (l * w * h) / (cl * cw * ch)\n\n        waste_x = cl - (x + l)\n        waste_y = cw - (y + w)\n        waste_z = ch - (z + h)\n        normalized_waste = (waste_x / cl) + (waste_y / cw) + (waste_z / ch)\n\n        return space_utilization - 0.25 * normalized_waste\n\n    def _generate_candidate_positions(self, container_dims, occupied_volumes, item_dims):\n        candidate_positions = [(0, 0, 0)] if not occupied_volumes else []\n        for placed_item in occupied_volumes:\n            x, y, z = placed_item['x'], placed_item['y'], placed_item['z']\n            l, w, h = placed_item['length'], placed_item['width'], placed_item['height']\n            candidate_positions.extend([(x + l, y, z), (x, y + w, z), (x, y, z + h)])\n        return [(x, y, z) for x, y, z in candidate_positions if self._is_within_container_bounds((x, y, z), item_dims, container_dims)]",
     "objective": 23.3,
     "other_inf": null,
     "class_name": "Algorithm"
}