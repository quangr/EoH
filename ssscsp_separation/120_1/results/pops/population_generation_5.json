[
     {
          "algorithm": "This algorithm iteratively places the largest volume item in the tightest-fit position within existing trucks or a new truck, prioritizing space utilization and separation constraints.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm iteratively places the largest volume item in the tightest-fit position within existing trucks or a new truck, prioritizing space utilization and separation constraints.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_fit = float('inf')\n\n        item_indices = self._sort_items_by_volume(unplaced_items)\n\n        for item_index in item_indices:\n            item_type = unplaced_items[item_index]\n            if item_type['quantity'] <= 0:\n                continue\n\n            for truck_index in range(-1, len(trucks_in_use)):\n                if truck_index == -1:\n                    separation_set = None\n                    occupied_volumes = []\n                else:\n                    separation_set = trucks_in_use[truck_index]['separation_set']\n                    occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n                if separation_set is not None and item_type.get('separation_set') is not None and separation_set != item_type['separation_set']:\n                    continue\n\n                x, y, z, orientation, fit = self._find_best_position_for_item(item_type, truck_type, occupied_volumes)\n\n                if x != -1 and fit < best_fit:\n                    best_truck_index = truck_index\n                    best_item_index = item_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n                    best_fit = fit\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _sort_items_by_volume(self, unplaced_items):\n        return sorted(range(len(unplaced_items)), key=lambda k: unplaced_items[k]['length'] * unplaced_items[k]['width'] * unplaced_items[k]['height'], reverse=True)\n\n    def _find_best_position_for_item(self, item_type, container_dims, occupied_volumes):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_fit = float('inf')\n\n        for orientation, dims in self._get_orientations(item_type):\n            l, w, h = dims\n\n            positions = self._generate_candidate_positions(container_dims, occupied_volumes, dims)\n\n            for x, y, z in positions:\n                if self._is_valid_placement((x, y, z), (l, w, h), container_dims, occupied_volumes):\n                    fit = self._calculate_fit((x, y, z), (l, w, h), container_dims, occupied_volumes)\n                    if fit < best_fit:\n                        best_fit = fit\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation\n\n        return best_x, best_y, best_z, best_orientation, best_fit\n\n    def _calculate_fit(self, item_pos, item_dims, container_dims, occupied_volumes):\n        x, y, z = item_pos\n        l, w, h = item_dims\n        cl, cw, ch = container_dims\n\n        space_on_sides = cl - (x + l) + cw - (y + w) + ch - (z + h)\n        touching_sides = 0\n\n        if x == 0 or y == 0 or z == 0:\n            touching_sides +=1\n        if x+l == cl or y+w == cw or z+h ==ch:\n            touching_sides +=1\n    \n        for placed_item in occupied_volumes:\n                px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n                pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n\n                if x + l == px and self._is_overlapped(y, y + w, py, py + pw) and self._is_overlapped(z, z + h, pz, pz + ph):\n                    touching_sides +=1\n                if px + pl == x and self._is_overlapped(y, y + w, py, py + pw) and self._is_overlapped(z, z + h, pz, pz + ph):\n                    touching_sides +=1\n                if y + w == py and self._is_overlapped(x, x + l, px, px + pl) and self._is_overlapped(z, z + h, pz, pz + ph):\n                    touching_sides +=1\n                if py + pw == y and self._is_overlapped(x, x + l, px, px + pl) and self._is_overlapped(z, z + h, pz, pz + ph):\n                   touching_sides +=1\n                if z + h == pz and self._is_overlapped(x, x + l, px, px + pl) and self._is_overlapped(y, y + w, py, py + pw):\n                    touching_sides +=1\n                if pz + ph == z and self._is_overlapped(x, x + l, px, px + pl) and self._is_overlapped(y, y + w, py, py + pw):\n                    touching_sides +=1\n                    \n        return space_on_sides - touching_sides\n\n\n    def _is_overlapped(self, start1, end1, start2, end2):\n        return max(start1, start2) < min(end1, end2)\n    \n    def _generate_candidate_positions(self, container_dims, occupied_volumes, item_dims):\n        candidate_positions = []\n\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        for placed_item in occupied_volumes:\n            x, y, z = placed_item['x'], placed_item['y'], placed_item['z']\n            l, w, h = placed_item['length'], placed_item['width'], placed_item['height']\n\n            candidate_positions.extend([(x + l, y, z), (x, y + w, z), (x, y, z + h)])\n\n        candidate_positions.append((0, 0, 0))\n\n        valid_positions = []\n        for x, y, z in candidate_positions:\n            if self._is_within_container_bounds((x, y, z), item_dims, container_dims):\n                valid_positions.append((x, y, z))\n\n        return valid_positions",
          "objective": 23.75,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm prioritizes items with smaller dimensions to pack densely, increasing the weight of space utilization in the scoring function and decreasing the weight of touching sides.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes items with smaller dimensions to pack densely, increasing the weight of space utilization in the scoring function and decreasing the weight of touching sides.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = float('-inf')\n\n        item_indices = self._sort_items_by_volume(unplaced_items)\n\n        for item_index in item_indices:\n            item_type = unplaced_items[item_index]\n            if item_type['quantity'] <= 0:\n                continue\n\n            for truck_index in range(-1, len(trucks_in_use)):\n                if truck_index == -1:\n                    separation_set = None\n                    occupied_volumes = []\n                else:\n                    separation_set = trucks_in_use[truck_index]['separation_set']\n                    occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n                if separation_set is not None and item_type.get('separation_set') is not None and separation_set != item_type['separation_set']:\n                    continue\n\n                x, y, z, orientation, score = self._find_best_position_for_item(item_type, truck_type, occupied_volumes)\n\n                if x != -1 and score > best_score:\n                    best_truck_index = truck_index\n                    best_item_index = item_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n                    best_score = score\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _sort_items_by_volume(self, unplaced_items):\n        return sorted(range(len(unplaced_items)), key=lambda k: unplaced_items[k]['length'] * unplaced_items[k]['width'] * unplaced_items[k]['height'], reverse=False)\n\n    def _find_best_position_for_item(self, item_type, container_dims, occupied_volumes):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = float('-inf')\n\n        for orientation, dims in self._get_orientations(item_type):\n            l, w, h = dims\n\n            positions = self._generate_candidate_positions(container_dims, occupied_volumes, dims)\n\n            for x, y, z in positions:\n                if self._is_valid_placement((x, y, z), (l, w, h), container_dims, occupied_volumes):\n                    score = self._calculate_score((x, y, z), (l, w, h), container_dims, occupied_volumes)\n                    if score > best_score:\n                        best_score = score\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation\n\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _calculate_score(self, item_pos, item_dims, container_dims, occupied_volumes):\n        x, y, z = item_pos\n        l, w, h = item_dims\n        cl, cw, ch = container_dims\n\n        space_utilization = (l * w * h) / (cl * cw * ch)\n\n        touching_sides = 0\n\n        if x == 0 or y == 0 or z == 0:\n            touching_sides += 1\n        if x + l == cl or y + w == cw or z + h == ch:\n            touching_sides += 1\n\n        for placed_item in occupied_volumes:\n            px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n            pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n\n            if x + l == px and self._is_overlapped(y, y + w, py, py + pw) and self._is_overlapped(z, z + h, pz, pz + ph):\n                touching_sides += 1\n            if px + pl == x and self._is_overlapped(y, y + w, py, py + pw) and self._is_overlapped(z, z + h, pz, pz + ph):\n                touching_sides += 1\n            if y + w == py and self._is_overlapped(x, x + l, px, px + pl) and self._is_overlapped(z, z + h, pz, pz + ph):\n                touching_sides += 1\n            if py + pw == y and self._is_overlapped(x, x + l, px, px + pl) and self._is_overlapped(z, z + h, pz, pz + ph):\n                touching_sides += 1\n            if z + h == pz and self._is_overlapped(x, x + l, px, px + pl) and self._is_overlapped(y, y + w, py, py + pw):\n                touching_sides += 1\n            if pz + ph == z and self._is_overlapped(x, x + l, px, px + pl) and self._is_overlapped(y, y + w, py, py + pw):\n                touching_sides += 1\n\n        return  touching_sides * 0.1 + space_utilization * 1\n\n    def _is_overlapped(self, start1, end1, start2, end2):\n        return max(start1, start2) < min(end1, end2)\n\n    def _generate_candidate_positions(self, container_dims, occupied_volumes, item_dims):\n        candidate_positions = []\n\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        for placed_item in occupied_volumes:\n            x, y, z = placed_item['x'], placed_item['y'], placed_item['z']\n            l, w, h = placed_item['length'], placed_item['width'], placed_item['height']\n\n            candidate_positions.extend([(x + l, y, z), (x, y + w, z), (x, y, z + h)])\n\n        candidate_positions.append((0, 0, 0))\n\n        valid_positions = []\n        for x, y, z in candidate_positions:\n            if self._is_within_container_bounds((x, y, z), item_dims, container_dims):\n                valid_positions.append((x, y, z))\n\n        return valid_positions",
          "objective": 23.8,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm prioritizes placing items in existing trucks, selecting the item with the highest remaining quantity and favoring positions that maximize contact with existing items while minimizing wasted space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes placing items in existing trucks, selecting the item with the highest remaining quantity and favoring positions that maximize contact with existing items while minimizing wasted space.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = float('-inf')\n\n        item_indices = self._sort_items_by_quantity(unplaced_items)\n\n        for item_index in item_indices:\n            item_type = unplaced_items[item_index]\n            if item_type['quantity'] <= 0:\n                continue\n\n            for truck_index in range(-1, len(trucks_in_use)):\n                if truck_index == -1:\n                    separation_set = None\n                    occupied_volumes = []\n                else:\n                    separation_set = trucks_in_use[truck_index]['separation_set']\n                    occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n                if separation_set is not None and item_type.get('separation_set') is not None and separation_set != item_type['separation_set']:\n                    continue\n\n                x, y, z, orientation, score = self._find_best_position_for_item(item_type, truck_type, occupied_volumes)\n\n                if x != -1 and score > best_score:\n                    best_truck_index = truck_index\n                    best_item_index = item_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n                    best_score = score\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _sort_items_by_quantity(self, unplaced_items):\n        return sorted(range(len(unplaced_items)), key=lambda k: unplaced_items[k]['quantity'], reverse=True)\n\n    def _find_best_position_for_item(self, item_type, container_dims, occupied_volumes):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = float('-inf')\n\n        for orientation, dims in self._get_orientations(item_type):\n            l, w, h = dims\n\n            positions = self._generate_candidate_positions(container_dims, occupied_volumes, dims)\n\n            for x, y, z in positions:\n                if self._is_valid_placement((x, y, z), (l, w, h), container_dims, occupied_volumes):\n                    score = self._calculate_score((x, y, z), (l, w, h), container_dims, occupied_volumes)\n                    if score > best_score:\n                        best_score = score\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation\n\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _calculate_score(self, item_pos, item_dims, container_dims, occupied_volumes):\n        x, y, z = item_pos\n        l, w, h = item_dims\n        cl, cw, ch = container_dims\n\n        space_utilization = (l * w * h) / (cl * cw * ch)\n\n        touching_sides = 0\n\n        if x == 0 or y == 0 or z == 0:\n            touching_sides += 1\n        if x + l == cl or y + w == cw or z + h == ch:\n            touching_sides += 1\n\n        for placed_item in occupied_volumes:\n            px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n            pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n\n            if x + l == px and self._is_overlapped(y, y + w, py, py + pw) and self._is_overlapped(z, z + h, pz, pz + ph):\n                touching_sides += 1\n            if px + pl == x and self._is_overlapped(y, y + w, py, py + pw) and self._is_overlapped(z, z + h, pz, pz + ph):\n                touching_sides += 1\n            if y + w == py and self._is_overlapped(x, x + l, px, px + pl) and self._is_overlapped(z, z + h, pz, pz + ph):\n                touching_sides += 1\n            if py + pw == y and self._is_overlapped(x, x + l, px, px + pl) and self._is_overlapped(z, z + h, pz, pz + ph):\n                touching_sides += 1\n            if z + h == pz and self._is_overlapped(x, x + l, px, px + pl) and self._is_overlapped(y, y + w, py, py + pw):\n                touching_sides += 1\n            if pz + ph == z and self._is_overlapped(x, x + l, px, px + pl) and self._is_overlapped(y, y + w, py, py + pw):\n                touching_sides += 1\n\n        return  touching_sides + space_utilization * 0.1\n\n    def _is_overlapped(self, start1, end1, start2, end2):\n        return max(start1, start2) < min(end1, end2)\n\n    def _generate_candidate_positions(self, container_dims, occupied_volumes, item_dims):\n        candidate_positions = []\n\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        for placed_item in occupied_volumes:\n            x, y, z = placed_item['x'], placed_item['y'], placed_item['z']\n            l, w, h = placed_item['length'], placed_item['width'], placed_item['height']\n\n            candidate_positions.extend([(x + l, y, z), (x, y + w, z), (x, y, z + h)])\n\n        candidate_positions.append((0, 0, 0))\n\n        valid_positions = []\n        for x, y, z in candidate_positions:\n            if self._is_within_container_bounds((x, y, z), item_dims, container_dims):\n                valid_positions.append((x, y, z))\n\n        return valid_positions",
          "objective": 23.85,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm prioritizes filling containers by selecting the item that best fits the largest empty space in the current truck based on a scoring function that considers volume utilization.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes filling containers by selecting the item that best fits the largest empty space in the current truck based on a scoring function that considers volume utilization.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = float('-inf')\n\n        for truck_index in range(-1, len(trucks_in_use)):\n            if truck_index == -1:\n                separation_set = None\n                occupied_volumes = []\n            else:\n                separation_set = trucks_in_use[truck_index]['separation_set']\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n            for item_index in range(len(unplaced_items)):\n                item_type = unplaced_items[item_index]\n                if item_type['quantity'] <= 0:\n                    continue\n\n                if separation_set is not None and item_type.get('separation_set') is not None and separation_set != item_type['separation_set']:\n                    continue\n\n                x, y, z, orientation, score = self._find_best_position_for_item(item_type, truck_type, occupied_volumes)\n\n                if x != -1 and score > best_score:\n                    best_truck_index = truck_index\n                    best_item_index = item_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n                    best_score = score\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_for_item(self, item_type, container_dims, occupied_volumes):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = float('-inf')\n\n        for orientation, dims in self._get_orientations(item_type):\n            l, w, h = dims\n\n            positions = self._generate_candidate_positions(container_dims, occupied_volumes, dims)\n\n            for x, y, z in positions:\n                if self._is_valid_placement((x, y, z), (l, w, h), container_dims, occupied_volumes):\n                    score = self._calculate_score((x, y, z), (l, w, h), container_dims, occupied_volumes)\n                    if score > best_score:\n                        best_score = score\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation\n\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _calculate_score(self, item_pos, item_dims, container_dims, occupied_volumes):\n        x, y, z = item_pos\n        l, w, h = item_dims\n        cl, cw, ch = container_dims\n        item_volume = l * w * h\n\n        total_occupied_volume = sum(item['length'] * item['width'] * item['height'] for item in occupied_volumes)\n        remaining_volume = cl * cw * ch - total_occupied_volume\n        \n        volume_utilization = item_volume / remaining_volume if remaining_volume > 0 else 0\n        \n        space_on_sides = max(0, cl - (x + l)) + max(0, cw - (y + w)) + max(0, ch - (z + h))\n\n        touching_sides = 0\n\n        if x == 0 or y == 0 or z == 0:\n            touching_sides += 1\n        if x + l >= cl - self.epsilon or y + w >= cw - self.epsilon or z + h >= ch - self.epsilon:\n            touching_sides += 1\n\n        for placed_item in occupied_volumes:\n            px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n            pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n\n            if x + l >= px - self.epsilon and x + l <= px + self.epsilon and self._is_overlapped(y, y + w, py, py + pw) and self._is_overlapped(z, z + h, pz, pz + ph):\n                touching_sides += 1\n            if px + pl >= x - self.epsilon and px + pl <= x + self.epsilon and self._is_overlapped(y, y + w, py, py + pw) and self._is_overlapped(z, z + h, pz, pz + ph):\n                touching_sides += 1\n            if y + w >= py - self.epsilon and y + w <= py + self.epsilon and self._is_overlapped(x, x + l, px, px + pl) and self._is_overlapped(z, z + h, pz, pz + ph):\n                touching_sides += 1\n            if py + pw >= y - self.epsilon and py + pw <= y + self.epsilon and self._is_overlapped(x, x + l, px, px + pl) and self._is_overlapped(z, z + h, pz, pz + ph):\n                touching_sides += 1\n            if z + h >= pz - self.epsilon and z + h <= pz + self.epsilon and self._is_overlapped(x, x + l, px, px + pl) and self._is_overlapped(y, y + w, py, py + pw):\n                touching_sides += 1\n            if pz + ph >= z - self.epsilon and pz + ph <= z + self.epsilon and self._is_overlapped(x, x + l, px, px + pl) and self._is_overlapped(y, y + w, py, py + pw):\n                touching_sides += 1\n\n        return 0.7 * volume_utilization - 0.1 * space_on_sides + 0.2 * touching_sides\n\n    def _is_overlapped(self, start1, end1, start2, end2):\n        return max(start1, start2) < min(end1, end2)\n\n    def _generate_candidate_positions(self, container_dims, occupied_volumes, item_dims):\n        candidate_positions = []\n\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        for placed_item in occupied_volumes:\n            x, y, z = placed_item['x'], placed_item['y'], placed_item['z']\n            l, w, h = placed_item['length'], placed_item['width'], placed_item['height']\n\n            candidate_positions.extend([(x + l, y, z), (x, y + w, z), (x, y, z + h),\n                                         (max(0, x - item_dims[0]), y, z), (x, max(0, y - item_dims[1]), z), (x, y, max(0, z - item_dims[2]))])\n\n        candidate_positions.append((0, 0, 0))\n\n        valid_positions = []\n        for x, y, z in candidate_positions:\n            if self._is_within_container_bounds((x, y, z), item_dims, container_dims):\n                valid_positions.append((x, y, z))\n\n        return valid_positions",
          "objective": 24.3,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm selects the item and orientation that maximizes volume utilization while prioritizing placement against existing items and container boundaries.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm selects the item and orientation that maximizes volume utilization while prioritizing placement against existing items and container boundaries.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = float('-inf')\n\n        for truck_index in range(-1, len(trucks_in_use)):\n            if truck_index == -1:\n                separation_set = None\n                occupied_volumes = []\n            else:\n                separation_set = trucks_in_use[truck_index]['separation_set']\n                occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n            for item_index in range(len(unplaced_items)):\n                item_type = unplaced_items[item_index]\n                if item_type['quantity'] <= 0:\n                    continue\n\n                if separation_set is not None and item_type.get('separation_set') is not None and separation_set != item_type['separation_set']:\n                    continue\n                \n                x, y, z, orientation, score = self._find_best_position_for_item(item_type, truck_type, occupied_volumes)\n\n                if x != -1 and score > best_score:\n                    best_truck_index = truck_index\n                    best_item_index = item_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n                    best_score = score\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_position_for_item(self, item_type, container_dims, occupied_volumes):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = float('-inf')\n\n        for orientation, dims in self._get_orientations(item_type):\n            l, w, h = dims\n\n            positions = self._generate_candidate_positions(container_dims, occupied_volumes, dims)\n\n            for x, y, z in positions:\n                if self._is_valid_placement((x, y, z), (l, w, h), container_dims, occupied_volumes):\n                    score = self._calculate_score((x, y, z), (l, w, h), container_dims, occupied_volumes)\n                    if score > best_score:\n                        best_score = score\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation\n\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _calculate_score(self, item_pos, item_dims, container_dims, occupied_volumes):\n        x, y, z = item_pos\n        l, w, h = item_dims\n        cl, cw, ch = container_dims\n        item_volume = l * w * h\n\n        total_occupied_volume = sum(item['length'] * item['width'] * item['height'] for item in occupied_volumes)\n        remaining_volume = cl * cw * ch - total_occupied_volume\n        \n        volume_utilization = item_volume / (cl * cw * ch)\n        \n        space_on_sides = max(0, cl - (x + l)) + max(0, cw - (y + w)) + max(0, ch - (z + h))\n\n        touching_sides = 0\n\n        if x == 0 or y == 0 or z == 0:\n            touching_sides += 1\n        if x + l >= cl - self.epsilon or y + w >= cw - self.epsilon or z + h >= ch - self.epsilon:\n            touching_sides += 1\n\n        for placed_item in occupied_volumes:\n            px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n            pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n\n            if x + l >= px - self.epsilon and x + l <= px + self.epsilon and self._is_overlapped(y, y + w, py, py + pw) and self._is_overlapped(z, z + h, pz, pz + ph):\n                touching_sides += 1\n            if px + pl >= x - self.epsilon and px + pl <= x + self.epsilon and self._is_overlapped(y, y + w, py, py + pw) and self._is_overlapped(z, z + h, pz, pz + ph):\n                touching_sides += 1\n            if y + w >= py - self.epsilon and y + w <= py + self.epsilon and self._is_overlapped(x, x + l, px, px + pl) and self._is_overlapped(z, z + h, pz, pz + ph):\n                touching_sides += 1\n            if py + pw >= y - self.epsilon and py + pw <= y + self.epsilon and self._is_overlapped(x, x + l, px, px + pl) and self._is_overlapped(z, z + h, pz, pz + ph):\n                touching_sides += 1\n            if z + h >= pz - self.epsilon and z + h <= pz + self.epsilon and self._is_overlapped(x, x + l, px, px + pl) and self._is_overlapped(y, y + w, py, py + pw):\n                touching_sides += 1\n            if pz + ph >= z - self.epsilon and pz + ph <= z + self.epsilon and self._is_overlapped(x, x + l, px, px + pl) and self._is_overlapped(y, y + w, py, py + pw):\n                touching_sides += 1\n\n        return 0.7 * volume_utilization - 0.1 * space_on_sides + 0.2 * touching_sides\n\n    def _is_overlapped(self, start1, end1, start2, end2):\n        return max(start1, start2) < min(end1, end2)\n\n    def _generate_candidate_positions(self, container_dims, occupied_volumes, item_dims):\n        candidate_positions = []\n\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        for placed_item in occupied_volumes:\n            x, y, z = placed_item['x'], placed_item['y'], placed_item['z']\n            l, w, h = placed_item['length'], placed_item['width'], placed_item['height']\n\n            candidate_positions.extend([(x + l, y, z), (x, y + w, z), (x, y, z + h),\n                                         (max(0, x - item_dims[0]), y, z), (x, max(0, y - item_dims[1]), z), (x, y, max(0, z - item_dims[2]))])\n\n        candidate_positions.append((0, 0, 0))\n\n        valid_positions = []\n        for x, y, z in candidate_positions:\n            if self._is_within_container_bounds((x, y, z), item_dims, container_dims):\n                valid_positions.append((x, y, z))\n\n        return valid_positions",
          "objective": 24.35,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]