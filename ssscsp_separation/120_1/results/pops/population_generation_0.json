[
     {
          "algorithm": "This algorithm prioritizes placing items into existing trucks using a first-fit decreasing height strategy, selecting the most constrained item type and orientation that minimizes remaining space and respects separation constraints, while creating new trucks only when necessary.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes placing items into existing trucks using a first-fit decreasing height strategy, selecting the most constrained item type and orientation that minimizes remaining space and respects separation constraints, while creating new trucks only when necessary.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index = -1\n        item_index = -1\n        x, y, z = 0.0, 0.0, 0.0\n        orientation = 0\n\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x, best_y, best_z = 0.0, 0.0, 0.0\n        best_orientation = 0\n        min_waste = float('inf')\n\n        \n        for item_idx, item in enumerate(unplaced_items):\n            if item['quantity'] <= 0:\n                continue\n            \n            for truck_idx, truck in enumerate(trucks_in_use):\n                if item.get('separation_set') is not None and truck.get('separation_set') is not None and item['separation_set'] != truck['separation_set']:\n                    continue\n                \n                x, y, z, orientation, waste = self._find_position_for_item_in_truck(item, truck, truck_type)\n                \n                if x is not None and waste < min_waste:\n                    min_waste = waste\n                    best_truck_index = truck_idx\n                    best_item_index = item_idx\n                    best_x, best_y, best_z = x, y, z\n                    best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_item_index, best_x, best_y, best_z, best_orientation, waste = self._find_best_placement_in_new_truck(unplaced_items, truck_type)\n        \n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_placement_in_new_truck(self, unplaced_items, truck_type):\n        best_item_index = -1\n        best_x, best_y, best_z = 0.0, 0.0, 0.0\n        best_orientation = 0\n        min_waste = float('inf')\n        \n        for item_idx, item in enumerate(unplaced_items):\n            if item['quantity'] <= 0:\n                continue\n            \n            x, y, z, orientation, waste = self._find_position_for_item_new_truck(item, truck_type)\n            if x is not None and waste < min_waste:\n                min_waste = waste\n                best_item_index = item_idx\n                best_x, best_y, best_z = x, y, z\n                best_orientation = orientation\n\n        return best_item_index, best_x, best_y, best_z, best_orientation, min_waste\n\n    def _find_position_for_item_new_truck(self, item, truck_type):\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        min_waste = float('inf')\n\n        for orientation_idx, (orientation, dims) in enumerate(self._get_orientations(item)):\n            if self._is_within_container_bounds((0.0, 0.0, 0.0), dims, truck_type):\n                waste = self._calculate_waste(dims, truck_type)\n                if waste < min_waste:\n                    min_waste = waste\n                    best_x, best_y, best_z = 0.0, 0.0, 0.0\n                    best_orientation = orientation_idx\n\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _find_position_for_item_in_truck(self, item, truck, truck_type):\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        min_waste = float('inf')\n\n        for orientation_idx, (orientation, dims) in enumerate(self._get_orientations(item)):\n            possible_positions = self._find_possible_positions(truck, truck_type, dims)\n                \n            for x, y, z in possible_positions:                    \n                if self._is_valid_placement((x, y, z), dims, truck_type, truck['occupied_volumes']):\n                    waste = self._calculate_waste(dims, truck_type)\n                    if waste < min_waste:\n                        min_waste = waste\n                        best_x, best_y, best_z = x, y, z\n                        best_orientation = orientation_idx\n\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _find_possible_positions(self, truck, truck_type, item_dims):\n        positions = []\n        \n        if not truck['occupied_volumes']:\n            return [(0.0, 0.0, 0.0)]\n\n        \n        for placed_item in truck['occupied_volumes']:\n            x = placed_item['x'] + placed_item['length']\n            y = placed_item['y']\n            z = placed_item['z']\n            if self._is_within_container_bounds((x, y, z), item_dims, truck_type):\n                positions.append((x, y, z))\n\n            x = placed_item['x']\n            y = placed_item['y'] + placed_item['width']\n            z = placed_item['z']\n            if self._is_within_container_bounds((x, y, z), item_dims, truck_type):\n                positions.append((x, y, z))\n\n            x = placed_item['x']\n            y = placed_item['y']\n            z = placed_item['z'] + placed_item['height']\n            if self._is_within_container_bounds((x, y, z), item_dims, truck_type):\n                positions.append((x, y, z))\n        return positions\n        \n\n    def _calculate_waste(self, item_dims, container_dims):\n        item_volume = item_dims[0] * item_dims[1] * item_dims[2]\n        container_volume = container_dims[0] * container_dims[1] * container_dims[2]\n        return container_volume - item_volume",
          "objective": 25.2,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "The algorithm iterates through unplaced items, tries all orientations and placement positions using Bottom-Left-Fill strategy within either existing or new trucks, prioritizing items based on a volume heuristic and separation constraints.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {The algorithm iterates through unplaced items, tries all orientations and placement positions using Bottom-Left-Fill strategy within either existing or new trucks, prioritizing items based on a volume heuristic and separation constraints.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_volume_utilization = -1\n\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] <= 0:\n                continue\n\n            for truck_index in range(-1, len(trucks_in_use)):\n                if truck_index == -1:\n                    separation_set = None\n                    occupied_volumes = []\n                else:\n                    separation_set = trucks_in_use[truck_index]['separation_set']\n                    occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n                \n                if separation_set is not None and item_type.get('separation_set') is not None and separation_set != item_type['separation_set']:\n                    continue\n\n\n                x, y, z, orientation = self._find_placement_position(item_type, truck_type, occupied_volumes)\n\n                if x != -1:\n                    item_dims = self._get_orientations(item_type)[orientation][1]\n                    volume = item_dims[0] * item_dims[1] * item_dims[2]\n                    truck_volume = truck_type[0] * truck_type[1] * truck_type[2]\n                    current_volume_utilization = volume / truck_volume\n\n                    if best_truck_index == -1 or current_volume_utilization > best_volume_utilization:\n                        best_truck_index = truck_index\n                        best_item_index = item_index\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation\n                        best_volume_utilization = current_volume_utilization\n        \n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_placement_position(self, item_type, container_dims, occupied_volumes):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        \n        for orientation, dims in self._get_orientations(item_type):\n            l, w, h = dims\n            \n            positions = self._generate_candidate_positions(container_dims, occupied_volumes, dims)\n            \n            if positions:\n                for pos in positions:\n                    x, y, z = pos\n                    if self._is_valid_placement((x, y, z), (l, w, h), container_dims, occupied_volumes):\n                        return x, y, z, orientation\n\n        return best_x, best_y, best_z, best_orientation\n    \n    def _generate_candidate_positions(self, container_dims, occupied_volumes, item_dims):\n        candidate_positions = []\n        \n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        for item in occupied_volumes:\n            x_new = item['x'] + item['length']\n            y_new = item['y'] + item['width']\n            z_new = item['z'] + item['height']\n\n            candidate_positions.extend([(x_new, item['y'], item['z']), \n                                        (item['x'], y_new, item['z']),\n                                        (item['x'], item['y'], z_new)])\n\n        return candidate_positions",
          "objective": 25.45,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "The algorithm prioritizes filling existing trucks using a first-fit approach, selecting the first feasible placement based on item type, orientation, and position while respecting separation constraints and minimizing wasted space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {The algorithm prioritizes filling existing trucks using a first-fit approach, selecting the first feasible placement based on item type, orientation, and position while respecting separation constraints and minimizing wasted space.}\n    def _select_item(self, unplaced_items, trucks_in_use, truck_type):\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                return item_index\n        return None\n\n    def _find_valid_position(self, item_type, truck_index, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n\n        for orientation_index, (orientation, item_dims) in enumerate(orientations):\n            for x in np.arange(0, container_dims[0], 1.0): \n                for y in np.arange(0, container_dims[1], 1.0):\n                    for z in np.arange(0, container_dims[2], 1.0):\n                        x, y, z = float(x), float(y), float(z)\n\n                        if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                            return x, y, z, orientation_index\n        return None, None, None, None\n\n    def _select_truck(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        item_type = unplaced_items[item_index]\n        item_separation_set = item_type.get('separation_set')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            truck_separation_set = truck.get('separation_set')\n            if item_separation_set is not None and truck_separation_set is not None and item_separation_set != truck_separation_set:\n                continue\n            \n            x, y, z, orientation = self._find_valid_position(item_type, truck_index, truck, truck_type)\n            if x is not None:\n                return truck_index, x, y, z, orientation\n        return -1, None, None, None, None\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items, trucks_in_use, truck_type)\n\n        if item_index is None:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n        truck_index, x, y, z, orientation = self._select_truck(unplaced_items, trucks_in_use, truck_type, item_index)\n\n        if truck_index == -1:\n            item_type = unplaced_items[item_index]\n            orientations = self._get_orientations(item_type)\n            for orientation_index, (orientation, item_dims) in enumerate(orientations):\n                if self._is_valid_placement((0.0, 0.0, 0.0), item_dims, truck_type, []):\n                    return -1, item_index, 0.0, 0.0, 0.0, orientation_index\n            return -1, -1, 0.0, 0.0, 0.0, 0 \n\n        return truck_index, item_index, x, y, z, orientation\nclass AlgorithmFIX1(Algorithm):\n    def _find_valid_position(self, item_type, truck_index, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n\n        max_attempts = 100\n\n        for orientation_index, (orientation, item_dims) in enumerate(orientations):\n            attempt_count = 0\n            while attempt_count < max_attempts:\n                x = np.random.uniform(0, container_dims[0] - item_dims[0])\n                y = np.random.uniform(0, container_dims[1] - item_dims[1])\n                z = np.random.uniform(0, container_dims[2] - item_dims[2])\n\n                if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                    return x, y, z, orientation_index\n                attempt_count += 1\n        return None, None, None, None\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_valid_position(self, item_type, truck_index, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n        \n        step_size = min(item_type['length'], item_type['width'], item_type['height']) / 2.0\n\n        for orientation_index, (orientation, item_dims) in enumerate(orientations):\n            for x in np.arange(0, container_dims[0] - item_dims[0] + self.epsilon, step_size):\n                for y in np.arange(0, container_dims[1] - item_dims[1] + self.epsilon, step_size):\n                    for z in np.arange(0, container_dims[2] - item_dims[2] + self.epsilon, step_size):\n                        x, y, z = float(x), float(y), float(z)\n\n                        if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                            return x, y, z, orientation_index\n        return None, None, None, None",
          "objective": 29.1,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     },
     {
          "algorithm": "Selects the item with the largest volume ratio to its remaining quantity, places it in the best feasible position and orientation within an existing or new truck, and considers separation constraints.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item with the largest volume ratio to its remaining quantity, places it in the best feasible position and orientation within an existing or new truck, and considers separation constraints.}\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        best_volume_ratio = -1\n\n        for i, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                volume = item_type['length'] * item_type['width'] * item_type['height']\n                volume_ratio = volume / item_type['quantity']\n                if volume_ratio > best_volume_ratio:\n                    best_volume_ratio = volume_ratio\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x, best_y, best_z = -1, -1, -1\n        best_orientation = -1\n        min_waste = float('inf')\n\n        for truck_index in range(-1, len(trucks_in_use)):\n            x, y, z, orientation, waste = self._find_placement_in_truck(unplaced_items, trucks_in_use, truck_type, item_index, truck_index)\n            if x != -1 and waste < min_waste:\n                min_waste = waste\n                best_truck_index = truck_index\n                best_x, best_y, best_z = x, y, z\n                best_orientation = orientation\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_placement_in_truck(self, unplaced_items, trucks_in_use, truck_type, item_index, truck_index):\n        item_type = unplaced_items[item_index]\n        container_dims = truck_type\n        \n        if truck_index == -1:\n            separation_set_truck = item_type.get('separation_set')\n            occupied_volumes = []\n        else:\n            separation_set_truck = trucks_in_use[truck_index].get('separation_set')\n            occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n            \n        if (separation_set_truck is not None and item_type.get('separation_set') is not None and separation_set_truck != item_type.get('separation_set')):\n            return -1, -1, -1, -1, float('inf')\n\n        best_x, best_y, best_z = -1, -1, -1\n        best_orientation = -1\n        min_waste = float('inf')\n\n        for orientation, item_dims in self._get_orientations(item_type):\n            length, width, height = item_dims\n            \n            x_increment = min(length, container_dims[0])\n            y_increment = min(width, container_dims[1])\n            z_increment = min(height, container_dims[2])\n\n            for x in np.arange(0, container_dims[0], x_increment):\n                for y in np.arange(0, container_dims[1], y_increment):\n                    for z in np.arange(0, container_dims[2], z_increment):\n                        x, y, z = round(x, 3), round(y, 3), round(z, 3)\n                        \n                        if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                            waste = self._calculate_waste(container_dims, occupied_volumes, item_dims, (x, y, z))\n\n                            if waste < min_waste:\n                                min_waste = waste\n                                best_x, best_y, best_z = x, y, z\n                                best_orientation = orientation\n\n        return best_x, best_y, best_z, best_orientation, min_waste\n    \n    def _calculate_waste(self, container_dims, occupied_volumes, item_dims, item_pos):\n        container_volume = container_dims[0] * container_dims[1] * container_dims[2]\n        occupied_volume = 0\n        \n        for placed_item in occupied_volumes:\n            occupied_volume += placed_item['length'] * placed_item['width'] * placed_item['height']\n\n        occupied_volume += item_dims[0] * item_dims[1] * item_dims[2]\n\n        return container_volume - occupied_volume",
          "objective": 29.15,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm iterates through unplaced items, finds the best-fit orientation and position within existing or new trucks considering separation constraints, and places the item.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm iterates through unplaced items, finds the best-fit orientation and position within existing or new trucks considering separation constraints, and places the item.}\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] <= 0:\n                continue\n\n            for truck_index, truck in enumerate(trucks_in_use):\n                if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                    continue\n                \n                x, y, z, orientation, waste = self._find_placement_in_truck(item_type, truck, truck_type)\n                if x != -1 and waste < min_waste:\n                    min_waste = waste\n                    best_truck_index = truck_index\n                    best_item_index = item_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n\n            if best_truck_index == -1:\n                x, y, z, orientation, waste = self._find_placement_new_truck(item_type, truck_type)\n                if x != -1 and waste < min_waste:\n                    min_waste = waste\n                    best_truck_index = -1\n                    best_item_index = item_index\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n                    \n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_placement_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n\n        for orientation, dims in self._get_orientations(item_type):\n            length, width, height = dims\n            for x in np.arange(0, truck_type[0] - length + self.epsilon, 1):\n                for y in np.arange(0, truck_type[1] - width + self.epsilon, 1):\n                    for z in np.arange(0, truck_type[2] - height + self.epsilon, 1):\n                        if self._is_valid_placement((x, y, z), (length, width, height), truck_type, truck['occupied_volumes']):\n                            waste = self._calculate_waste((x, y, z), (length, width, height),truck_type, truck['occupied_volumes'])\n                            if waste < min_waste:\n                                min_waste = waste\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation\n        return best_x, best_y, best_z, best_orientation, min_waste\n    \n    def _find_placement_new_truck(self, item_type, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n        occupied_volumes = []\n\n        for orientation, dims in self._get_orientations(item_type):\n            length, width, height = dims\n            x, y, z = 0, 0, 0\n\n            if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                waste = self._calculate_waste((x, y, z), (length, width, height),truck_type, occupied_volumes)\n                if waste < min_waste:\n                    min_waste = waste\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation\n\n        return best_x, best_y, best_z, best_orientation, min_waste\n    \n    def _calculate_waste(self, item_pos, item_dims, container_dims, occupied_volumes):\n        total_volume = container_dims[0] * container_dims[1] * container_dims[2]\n        occupied_volume = 0\n        for item in occupied_volumes:\n            occupied_volume += item['length'] * item['width'] * item['height']\n        new_volume = item_dims[0] * item_dims[1] * item_dims[2]\n        waste = total_volume - occupied_volume - new_volume\n        return waste\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _find_placement_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n\n        for orientation, dims in self._get_orientations(item_type):\n            length, width, height = dims\n            \n            max_x = max(0, truck_type[0] - length + self.epsilon)\n            max_y = max(0, truck_type[1] - width + self.epsilon)\n            max_z = max(0, truck_type[2] - height + self.epsilon)\n\n            \n            possible_xs = np.arange(0, max_x + 1, 1)\n            possible_ys = np.arange(0, max_y + 1, 1)\n            possible_zs = np.arange(0, max_z + 1, 1)\n            \n            for x in possible_xs:\n                for y in possible_ys:\n                    for z in possible_zs:\n                        if self._is_valid_placement((x, y, z), (length, width, height), truck_type, truck['occupied_volumes']):\n                            waste = self._calculate_waste((x, y, z), (length, width, height),truck_type, truck['occupied_volumes'])\n                            if waste < min_waste:\n                                min_waste = waste\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation\n        return best_x, best_y, best_z, best_orientation, min_waste\nimport numpy as np\n\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_placement_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n        \n        num_placements_considered = 0  # Counter to limit placements\n\n        for orientation, dims in self._get_orientations(item_type):\n            length, width, height = dims\n\n            max_x = max(0, truck_type[0] - length + self.epsilon)\n            max_y = max(0, truck_type[1] - width + self.epsilon)\n            max_z = max(0, truck_type[2] - height + self.epsilon)\n\n            possible_xs = [0] if max_x == 0 else np.arange(0, max_x + 1, max(1, max_x))\n            possible_ys = [0] if max_y == 0 else np.arange(0, max_y + 1, max(1, max_y))\n            possible_zs = [0] if max_z == 0 else np.arange(0, max_z + 1, max(1, max_z))\n\n            for x in possible_xs:\n                for y in possible_ys:\n                    for z in possible_zs:\n                        num_placements_considered += 1\n                        if num_placements_considered > 20:\n                            return best_x, best_y, best_z, best_orientation, min_waste\n\n                        if self._is_valid_placement((x, y, z), (length, width, height), truck_type, truck['occupied_volumes']):\n                            waste = self._calculate_waste((x, y, z), (length, width, height), truck_type, truck['occupied_volumes'])\n                            if waste < min_waste:\n                                min_waste = waste\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation\n\n        return best_x, best_y, best_z, best_orientation, min_waste\nimport numpy as np\n\nclass AlgorithmFIX3(AlgorithmFIX2):\n    def _find_placement_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n\n        num_placements_considered = 0\n\n        for orientation, dims in self._get_orientations(item_type):\n            length, width, height = dims\n\n            max_x = truck_type[0] - length\n            max_y = truck_type[1] - width\n            max_z = truck_type[2] - height\n\n            possible_xs = [0] if max_x <= 0 else [0, max_x] if max_x > 0 else [0]\n            possible_ys = [0] if max_y <= 0 else [0, max_y] if max_y > 0 else [0]\n            possible_zs = [0] if max_z <= 0 else [0, max_z] if max_z > 0 else [0]\n\n            for x in possible_xs:\n                for y in possible_ys:\n                    for z in possible_zs:\n                        num_placements_considered += 1\n                        if num_placements_considered > 20:\n                            return best_x, best_y, best_z, best_orientation, min_waste\n\n                        if self._is_valid_placement((x, y, z), (length, width, height), truck_type, truck['occupied_volumes']):\n                            waste = self._calculate_waste((x, y, z), (length, width, height), truck_type, truck['occupied_volumes'])\n                            if waste < min_waste:\n                                min_waste = waste\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation\n\n        return best_x, best_y, best_z, best_orientation, min_waste",
          "objective": 31.65,
          "other_inf": null,
          "class_name": "AlgorithmFIX3"
     }
]