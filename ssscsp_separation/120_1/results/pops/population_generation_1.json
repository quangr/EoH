[
     {
          "algorithm": "This algorithm prioritizes placing items into existing trucks using a first-fit decreasing height strategy, selecting the most constrained item type and orientation that minimizes remaining space and respects separation constraints, while creating new trucks only when necessary.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes placing items into existing trucks using a first-fit decreasing height strategy, selecting the most constrained item type and orientation that minimizes remaining space and respects separation constraints, while creating new trucks only when necessary.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index = -1\n        item_index = -1\n        x, y, z = 0.0, 0.0, 0.0\n        orientation = 0\n\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x, best_y, best_z = 0.0, 0.0, 0.0\n        best_orientation = 0\n        min_waste = float('inf')\n\n        \n        for item_idx, item in enumerate(unplaced_items):\n            if item['quantity'] <= 0:\n                continue\n            \n            for truck_idx, truck in enumerate(trucks_in_use):\n                if item.get('separation_set') is not None and truck.get('separation_set') is not None and item['separation_set'] != truck['separation_set']:\n                    continue\n                \n                x, y, z, orientation, waste = self._find_position_for_item_in_truck(item, truck, truck_type)\n                \n                if x is not None and waste < min_waste:\n                    min_waste = waste\n                    best_truck_index = truck_idx\n                    best_item_index = item_idx\n                    best_x, best_y, best_z = x, y, z\n                    best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_item_index, best_x, best_y, best_z, best_orientation, waste = self._find_best_placement_in_new_truck(unplaced_items, truck_type)\n        \n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_placement_in_new_truck(self, unplaced_items, truck_type):\n        best_item_index = -1\n        best_x, best_y, best_z = 0.0, 0.0, 0.0\n        best_orientation = 0\n        min_waste = float('inf')\n        \n        for item_idx, item in enumerate(unplaced_items):\n            if item['quantity'] <= 0:\n                continue\n            \n            x, y, z, orientation, waste = self._find_position_for_item_new_truck(item, truck_type)\n            if x is not None and waste < min_waste:\n                min_waste = waste\n                best_item_index = item_idx\n                best_x, best_y, best_z = x, y, z\n                best_orientation = orientation\n\n        return best_item_index, best_x, best_y, best_z, best_orientation, min_waste\n\n    def _find_position_for_item_new_truck(self, item, truck_type):\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        min_waste = float('inf')\n\n        for orientation_idx, (orientation, dims) in enumerate(self._get_orientations(item)):\n            if self._is_within_container_bounds((0.0, 0.0, 0.0), dims, truck_type):\n                waste = self._calculate_waste(dims, truck_type)\n                if waste < min_waste:\n                    min_waste = waste\n                    best_x, best_y, best_z = 0.0, 0.0, 0.0\n                    best_orientation = orientation_idx\n\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _find_position_for_item_in_truck(self, item, truck, truck_type):\n        best_x, best_y, best_z = None, None, None\n        best_orientation = None\n        min_waste = float('inf')\n\n        for orientation_idx, (orientation, dims) in enumerate(self._get_orientations(item)):\n            possible_positions = self._find_possible_positions(truck, truck_type, dims)\n                \n            for x, y, z in possible_positions:                    \n                if self._is_valid_placement((x, y, z), dims, truck_type, truck['occupied_volumes']):\n                    waste = self._calculate_waste(dims, truck_type)\n                    if waste < min_waste:\n                        min_waste = waste\n                        best_x, best_y, best_z = x, y, z\n                        best_orientation = orientation_idx\n\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _find_possible_positions(self, truck, truck_type, item_dims):\n        positions = []\n        \n        if not truck['occupied_volumes']:\n            return [(0.0, 0.0, 0.0)]\n\n        \n        for placed_item in truck['occupied_volumes']:\n            x = placed_item['x'] + placed_item['length']\n            y = placed_item['y']\n            z = placed_item['z']\n            if self._is_within_container_bounds((x, y, z), item_dims, truck_type):\n                positions.append((x, y, z))\n\n            x = placed_item['x']\n            y = placed_item['y'] + placed_item['width']\n            z = placed_item['z']\n            if self._is_within_container_bounds((x, y, z), item_dims, truck_type):\n                positions.append((x, y, z))\n\n            x = placed_item['x']\n            y = placed_item['y']\n            z = placed_item['z'] + placed_item['height']\n            if self._is_within_container_bounds((x, y, z), item_dims, truck_type):\n                positions.append((x, y, z))\n        return positions\n        \n\n    def _calculate_waste(self, item_dims, container_dims):\n        item_volume = item_dims[0] * item_dims[1] * item_dims[2]\n        container_volume = container_dims[0] * container_dims[1] * container_dims[2]\n        return container_volume - item_volume",
          "objective": 25.2,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm prioritizes items by remaining quantity, then attempts to place them using a bottom-left-back strategy, favoring placements that minimize wasted space and respect separation constraints.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes items by remaining quantity, then attempts to place them using a bottom-left-back strategy, favoring placements that minimize wasted space and respect separation constraints.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_space_utilization = float('inf')\n\n        sorted_item_indices = sorted(range(len(unplaced_items)), key=lambda k: unplaced_items[k]['quantity'], reverse=True)\n\n        for item_index in sorted_item_indices:\n            item_type = unplaced_items[item_index]\n            if item_type['quantity'] <= 0:\n                continue\n\n            for truck_index in range(-1, len(trucks_in_use)):\n                if truck_index == -1:\n                    separation_set = None\n                    occupied_volumes = []\n                else:\n                    separation_set = trucks_in_use[truck_index]['separation_set']\n                    occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n\n                if separation_set is not None and item_type.get('separation_set') is not None and separation_set != item_type['separation_set']:\n                    continue\n\n                x, y, z, orientation = self._find_placement_position(item_type, truck_type, occupied_volumes)\n\n                if x != -1:\n                    item_dims = self._get_orientations(item_type)[orientation][1]\n                    \n                    waste = self._calculate_waste(truck_type, occupied_volumes, (x,y,z), item_dims)\n                    \n                    if best_truck_index == -1 or waste < best_space_utilization:\n                        best_truck_index = truck_index\n                        best_item_index = item_index\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation\n                        best_space_utilization = waste\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _calculate_waste(self, container_dims, occupied_volumes, item_pos, item_dims):\n            total_volume = container_dims[0] * container_dims[1] * container_dims[2]\n            occupied_volume = 0\n            \n            for placed_item in occupied_volumes:\n                occupied_volume += placed_item['length'] * placed_item['width'] * placed_item['height']\n                \n            occupied_volume += item_dims[0] * item_dims[1] * item_dims[2]\n\n            return total_volume - occupied_volume\n\n    def _find_placement_position(self, item_type, container_dims, occupied_volumes):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n\n        for orientation, dims in self._get_orientations(item_type):\n            l, w, h = dims\n\n            positions = self._generate_candidate_positions(container_dims, occupied_volumes, dims)\n\n            if positions:\n                for pos in positions:\n                    x, y, z = pos\n                    if self._is_valid_placement((x, y, z), (l, w, h), container_dims, occupied_volumes):\n                        return x, y, z, orientation\n\n        return best_x, best_y, best_z, best_orientation\n\n    def _generate_candidate_positions(self, container_dims, occupied_volumes, item_dims):\n        candidate_positions = []\n        \n        if not occupied_volumes:\n            return [(0, 0, 0)]\n        \n        z_values = sorted(list(set([0] + [item['z'] + item['height'] for item in occupied_volumes])))\n        \n        for z in z_values:\n            y_values = sorted(list(set([0] + [item['y'] + item['width'] if item['z'] <= z < item['z'] + item['height'] else 0 for item in occupied_volumes])))\n\n            for y in y_values:\n                x_values = sorted(list(set([0] + [item['x'] + item['length'] if item['y'] <= y < item['y'] + item['width'] and item['z'] <= z < item['z'] + item['height'] else 0 for item in occupied_volumes])))\n\n                for x in x_values:\n                    candidate_positions.append((x, y, z))\n\n        return candidate_positions",
          "objective": 25.25,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm iteratively selects item types based on a packing density score, attempts to place them using a skyline heuristic, and opens new trucks when necessary.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm iteratively selects item types based on a packing density score, attempts to place them using a skyline heuristic, and opens new trucks when necessary.}\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items, trucks_in_use, truck_type)\n\n        if item_index is None:\n            return -1, -1, 0.0, 0.0, 0.0, 0\n\n        truck_index, x, y, z, orientation = self._find_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_item_index = None\n        best_density = -1\n\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] <= 0:\n                continue\n\n            volume = item_type['length'] * item_type['width'] * item_type['height']\n            quantity = item_type['quantity']\n            density = volume * quantity / (truck_type[0] * truck_type[1] * truck_type[2])\n\n            if density > best_density:\n                best_density = density\n                best_item_index = item_index\n\n        return best_item_index\n\n    def _find_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        item_type = unplaced_items[item_index]\n        best_truck_index = -1\n        best_x, best_y, best_z, best_orientation = 0.0, 0.0, 0.0, 0\n        \n        min_z = float('inf')\n        \n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n                \n            x, y, z, orientation = self._find_skyline_position(item_type, truck, truck_type)\n            if z is not None and z < min_z:\n                min_z = z\n                best_truck_index = truck_index\n                best_x, best_y = x, y\n                best_z = z\n                best_orientation = orientation\n        \n        if best_truck_index == -1:\n            x, y, z, orientation = self._find_skyline_position(item_type, {'occupied_volumes': []}, truck_type) \n            if z is not None:\n                return -1, x, y, z, orientation\n            else:\n                return -1, 0.0, 0.0, 0.0, 0\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_skyline_position(self, item_type, truck, truck_type):\n        occupied_volumes = truck['occupied_volumes']\n        container_dims = truck_type\n        best_x, best_y, best_z, best_orientation = None, None, None, None\n        min_z = float('inf')\n        \n        for orientation_index, (orientation, item_dims) in enumerate(self._get_orientations(item_type)):\n            \n            for x in np.arange(0, container_dims[0] - item_dims[0] + self.epsilon, 1):\n                for y in np.arange(0, container_dims[1] - item_dims[1] + self.epsilon, 1):\n                    \n                    z = self._calculate_skyline_height(x, y, item_dims[0], item_dims[1], occupied_volumes)\n                    \n                    if self._is_valid_placement((x, y, z), item_dims, container_dims, occupied_volumes):\n                        if z < min_z:\n                            min_z = z\n                            best_x, best_y, best_z, best_orientation = x, y, z, orientation_index\n                            \n        return best_x, best_y, best_z, best_orientation\n\n    def _calculate_skyline_height(self, x, y, length, width, occupied_volumes):\n        max_z = 0.0\n        \n        for placed_item in occupied_volumes:\n            placed_item_x = placed_item['x']\n            placed_item_y = placed_item['y']\n            placed_item_z = placed_item['z']\n            placed_item_length = placed_item['length']\n            placed_item_width = placed_item['width']\n            placed_item_height = placed_item['height']\n\n            if (x < placed_item_x + placed_item_length and x + length > placed_item_x and\n                y < placed_item_y + placed_item_width and y + width > placed_item_y):\n                max_z = max(max_z, placed_item_z + placed_item_height)\n                \n        return max_z",
          "objective": 25.4,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "The algorithm iterates through unplaced items, tries all orientations and placement positions using Bottom-Left-Fill strategy within either existing or new trucks, prioritizing items based on a volume heuristic and separation constraints.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {The algorithm iterates through unplaced items, tries all orientations and placement positions using Bottom-Left-Fill strategy within either existing or new trucks, prioritizing items based on a volume heuristic and separation constraints.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_volume_utilization = -1\n\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] <= 0:\n                continue\n\n            for truck_index in range(-1, len(trucks_in_use)):\n                if truck_index == -1:\n                    separation_set = None\n                    occupied_volumes = []\n                else:\n                    separation_set = trucks_in_use[truck_index]['separation_set']\n                    occupied_volumes = trucks_in_use[truck_index]['occupied_volumes']\n                \n                if separation_set is not None and item_type.get('separation_set') is not None and separation_set != item_type['separation_set']:\n                    continue\n\n\n                x, y, z, orientation = self._find_placement_position(item_type, truck_type, occupied_volumes)\n\n                if x != -1:\n                    item_dims = self._get_orientations(item_type)[orientation][1]\n                    volume = item_dims[0] * item_dims[1] * item_dims[2]\n                    truck_volume = truck_type[0] * truck_type[1] * truck_type[2]\n                    current_volume_utilization = volume / truck_volume\n\n                    if best_truck_index == -1 or current_volume_utilization > best_volume_utilization:\n                        best_truck_index = truck_index\n                        best_item_index = item_index\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation\n                        best_volume_utilization = current_volume_utilization\n        \n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_placement_position(self, item_type, container_dims, occupied_volumes):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        \n        for orientation, dims in self._get_orientations(item_type):\n            l, w, h = dims\n            \n            positions = self._generate_candidate_positions(container_dims, occupied_volumes, dims)\n            \n            if positions:\n                for pos in positions:\n                    x, y, z = pos\n                    if self._is_valid_placement((x, y, z), (l, w, h), container_dims, occupied_volumes):\n                        return x, y, z, orientation\n\n        return best_x, best_y, best_z, best_orientation\n    \n    def _generate_candidate_positions(self, container_dims, occupied_volumes, item_dims):\n        candidate_positions = []\n        \n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        for item in occupied_volumes:\n            x_new = item['x'] + item['length']\n            y_new = item['y'] + item['width']\n            z_new = item['z'] + item['height']\n\n            candidate_positions.extend([(x_new, item['y'], item['z']), \n                                        (item['x'], y_new, item['z']),\n                                        (item['x'], item['y'], z_new)])\n\n        return candidate_positions",
          "objective": 25.45,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm prioritizes minimizing the number of trucks used by maximizing volume utilization and penalizing distance from the bottom-left-front corner, while also considering separation constraints.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes minimizing the number of trucks used by maximizing volume utilization and penalizing distance from the bottom-left-front corner, while also considering separation constraints.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = -1\n\n        for item_index in range(len(unplaced_items)):\n            item_type = unplaced_items[item_index]\n            if item_type['quantity'] <= 0:\n                continue\n\n            for truck_index in range(-1, len(trucks_in_use)):\n                truck_data = self._get_truck_data(trucks_in_use, truck_index)\n\n                if truck_data is None:\n                  separation_set = None\n                  occupied_volumes = []\n                else:\n                  truck, separation_set, occupied_volumes = truck_data\n\n                if separation_set is not None and item_type.get('separation_set') is not None and separation_set != item_type['separation_set']:\n                    continue\n\n                placement_result = self._evaluate_placements(item_type, truck_type, occupied_volumes)\n\n                if placement_result:\n                    x, y, z, orientation, score = placement_result\n                    if best_truck_index == -1 or score > best_score:\n                        best_truck_index = truck_index\n                        best_item_index = item_index\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation\n                        best_score = score\n\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _get_truck_data(self, trucks_in_use, truck_index):\n        if truck_index == -1:\n            return None\n        else:\n            truck = trucks_in_use[truck_index]\n            return truck, truck['separation_set'], truck['occupied_volumes']\n\n    def _evaluate_placements(self, item_type, container_dims, occupied_volumes):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = -1\n\n        for orientation, dims in self._get_orientations(item_type):\n            l, w, h = dims\n            positions = self._generate_candidate_positions(container_dims, occupied_volumes, dims)\n\n            if positions:\n                for x, y, z in positions:\n                    if self._is_valid_placement((x, y, z), (l, w, h), container_dims, occupied_volumes):\n                        score = self._calculate_placement_score(item_type, dims, container_dims, occupied_volumes, (x,y,z))\n                        if best_x == -1 or score > best_score:\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            best_orientation = orientation\n                            best_score = score\n\n        if best_x != -1:\n            return best_x, best_y, best_z, best_orientation, best_score\n        else:\n            return None\n\n    def _generate_candidate_positions(self, container_dims, occupied_volumes, item_dims):\n        candidate_positions = []\n\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        epsilon = 1e-6\n        for item in occupied_volumes:\n            x_new = item['x'] + item['length'] + epsilon\n            y_new = item['y'] + item['width'] + epsilon\n            z_new = item['z'] + item['height'] + epsilon\n\n            candidate_positions.extend([(x_new, item['y'], item['z']),\n                                        (item['x'], y_new, item['z']),\n                                        (item['x'], item['y'], z_new)])\n\n        return candidate_positions\n\n    def _calculate_placement_score(self, item_type, item_dims, container_dims, occupied_volumes, position):\n        volume = item_dims[0] * item_dims[1] * item_dims[2]\n        container_volume = container_dims[0] * container_dims[1] * container_dims[2]\n        volume_utilization = volume / container_volume\n\n        x,y,z = position\n        max_x, max_y, max_z = container_dims\n        normalized_x = x / max_x\n        normalized_y = y / max_y\n        normalized_z = z / max_z\n        \n        position_penalty = normalized_x + normalized_y + normalized_z\n\n        return volume_utilization - 0.1 * position_penalty\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _generate_candidate_positions(self, container_dims, occupied_volumes, item_dims):\n        candidate_positions = []\n\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        l, w, h = item_dims\n        c_l, c_w, c_h = container_dims\n        epsilon = 1e-6\n\n        for item in occupied_volumes:\n            x_new = item['x'] + item['length'] + epsilon\n            y_new = item['y'] + item['width'] + epsilon\n            z_new = item['z'] + item['height'] + epsilon\n\n            if x_new + l <= c_l + epsilon:\n                candidate_positions.append((x_new, item['y'], item['z']))\n            if y_new + w <= c_w + epsilon:\n                candidate_positions.append((item['x'], y_new, item['z']))\n            if z_new + h <= c_h + epsilon:\n                candidate_positions.append((item['x'], item['y'], z_new))\n\n        return candidate_positions\nimport numpy as np\n\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _generate_candidate_positions(self, container_dims, occupied_volumes, item_dims):\n        candidate_positions = []\n\n        if not occupied_volumes:\n            return [(0, 0, 0)]\n\n        l, w, h = item_dims\n        c_l, c_w, c_h = container_dims\n        epsilon = self.epsilon\n\n        for item in occupied_volumes:\n            x_new = item['x'] + item['length']\n            y_new = item['y'] + item['width']\n            z_new = item['z'] + item['height']\n\n            if x_new + l <= c_l + epsilon and x_new >= 0 - epsilon:\n                candidate_positions.append((x_new, item['y'], item['z']))\n            if y_new + w <= c_w + epsilon and y_new >= 0 - epsilon:\n                candidate_positions.append((item['x'], y_new, item['z']))\n            if z_new + h <= c_h + epsilon and z_new >= 0 - epsilon:\n                candidate_positions.append((item['x'], item['y'], z_new))\n\n        return candidate_positions",
          "objective": 25.75,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     }
]