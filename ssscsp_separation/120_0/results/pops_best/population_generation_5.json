{
     "algorithm": "Selects an item based on the ratio of its volume to its surface area, places it using a bottom-left heuristic, and prioritizes trucks with similar separation sets while minimizing the empty space in the truck.",
     "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects an item based on the ratio of its volume to its surface area, places it using a bottom-left heuristic, and prioritizes trucks with similar separation sets while minimizing the empty space in the truck.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_ratio = -1\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                volume = unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height']\n                surface_area = 2 * (unplaced_items[i]['length'] * unplaced_items[i]['width'] +\n                                      unplaced_items[i]['length'] * unplaced_items[i]['height'] +\n                                      unplaced_items[i]['width'] * unplaced_items[i]['height'])\n                if surface_area > 0:\n                  ratio = volume / surface_area\n                else:\n                  ratio = 0\n                if ratio > max_ratio:\n                    max_ratio = ratio\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n\n        item_type = unplaced_items[item_index]\n        item_separation_set = item_type.get('separation_set')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            truck_separation_set = truck.get('separation_set')\n            \n            if item_separation_set is not None and truck_separation_set is not None and item_separation_set != truck_separation_set:\n                continue\n\n            x, y, z, orientation, waste = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and waste < min_waste:\n                min_waste = waste\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation, waste = self._create_new_truck(item_type, truck_type)\n            if best_truck_index == -2:\n                return -1, item_index, 0, 0, 0, 0\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n        occupied_volumes = truck['occupied_volumes']\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            x, y, z = self._bottom_left_fill(length, width, height, truck_type, occupied_volumes)\n            if x != -1:\n                waste = self._evaluate_placement(x, y, z, length, width, height, truck_type)\n                if waste < min_waste:\n                    min_waste = waste\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _bottom_left_fill(self, length, width, height, truck_type, occupied_volumes):\n        best_x, best_y, best_z = -1, -1, -1\n        \n        possible_positions = []\n        if not occupied_volumes:\n          if self._is_valid_placement((0, 0, 0), (length, width, height), truck_type, occupied_volumes):\n            return 0, 0, 0\n          else:\n            return -1, -1, -1\n        \n        for z in sorted(list(set([0] + [item['z'] + item['height'] for item in occupied_volumes]))):\n          for y in sorted(list(set([0] + [item['y'] + item['width'] for item in occupied_volumes]))):\n            for x in sorted(list(set([0] + [item['x'] + item['length'] for item in occupied_volumes]))):\n              if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                possible_positions.append((x,y,z))\n        \n        if not possible_positions:\n          return -1, -1, -1\n        \n        \n        \n        \n        placed = False\n        for x, y, z in sorted(possible_positions, key=lambda k: (k[2], k[1], k[0])):\n          if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n            return x, y, z\n            placed = True\n            break\n            \n        if not placed:\n          return -1, -1, -1\n        \n\n    def _evaluate_placement(self, x, y, z, length, width, height, truck_type):\n        return (truck_type[0] - (x + length)) * (truck_type[1] - (y + width)) * (truck_type[2] - (z + height))\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n        min_waste = float('inf')\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                waste = (truck_type[0] - length) * (truck_type[1] - width) * (truck_type[2] - height)\n                if waste < min_waste:\n                    min_waste = waste\n                    best_orientation = orientation_index\n\n        if best_orientation != -1:\n            separation_set = item_type.get('separation_set')\n            return -1, 0, 0, 0, best_orientation, min_waste\n        return -2, -1, -1, -1, -1, float('inf')",
     "objective": 24.0,
     "other_inf": null,
     "class_name": "Algorithm"
}