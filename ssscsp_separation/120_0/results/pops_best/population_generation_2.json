{
     "algorithm": "Select the item with largest surface area, place it using a skyline heuristic to find the lowest-z position, and prioritize filling lower truck indices and minimizing wasted space.",
     "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select the item with largest surface area, place it using a skyline heuristic to find the lowest-z position, and prioritize filling lower truck indices and minimizing wasted space.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_area = -1\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                area = 2 * (unplaced_items[i]['length'] * unplaced_items[i]['width'] +\n                            unplaced_items[i]['length'] * unplaced_items[i]['height'] +\n                            unplaced_items[i]['width'] * unplaced_items[i]['height'])\n                if area > max_area:\n                    max_area = area\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n            x, y, z, orientation, waste = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and waste < min_waste:\n                min_waste = waste\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation, waste = self._create_new_truck(item_type, truck_type)\n            if best_truck_index == -2:\n              return -1, item_index, 0, 0, 0, 0\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n        \n        occupied_volumes = truck['occupied_volumes']\n        \n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            for x in np.arange(0, truck_type[0] - length + self.epsilon, 1):\n                for y in np.arange(0, truck_type[1] - width + self.epsilon, 1):\n                    z = self._find_lowest_valid_z(x, y, length, width, height, truck_type, occupied_volumes)\n                    if z is not None:\n                        if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                            waste = self._evaluate_placement(x, y, z, length, width, height, truck_type)\n                            if waste < min_waste:\n                                min_waste = waste\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation_index\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _find_lowest_valid_z(self, x, y, length, width, height, truck_type, occupied_volumes):\n        z = 0\n        while z + height <= truck_type[2]:\n            is_valid = True\n            for placed_item in occupied_volumes:\n                if self._check_overlap_3d((x, y, z), (length, width, height), (placed_item['x'], placed_item['y'], placed_item['z']), (placed_item['length'], placed_item['width'], placed_item['height'])):\n                    is_valid = False\n                    z = placed_item['z'] + placed_item['height']\n                    break\n            if is_valid:\n                return z\n        return None\n    \n    def _evaluate_placement(self, x, y, z, length, width, height, truck_type):\n        return (truck_type[0] - (x + length)) * (truck_type[1] - (y + width)) * (truck_type[2] - (z + height))\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n        min_waste = float('inf')\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                waste = (truck_type[0] - length) * (truck_type[1] - width) * (truck_type[2] - height)\n                if waste < min_waste:\n                    min_waste = waste\n                    best_orientation = orientation_index\n                    \n        if best_orientation != -1:\n          separation_set = item_type.get('separation_set')\n          return -1, 0, 0, 0, best_orientation, min_waste\n        return -2, -1, -1, -1, -1, float('inf')",
     "objective": 24.45,
     "other_inf": null,
     "class_name": "Algorithm"
}