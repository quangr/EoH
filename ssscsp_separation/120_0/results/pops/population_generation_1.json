[
     {
          "algorithm": "Select the item with the largest remaining quantity and place it using a best-fit heuristic based on minimizing wasted space, prioritizing lower z placement.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select the item with the largest remaining quantity and place it using a best-fit heuristic based on minimizing wasted space, prioritizing lower z placement.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_quantity = -1\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                if unplaced_items[i]['quantity'] > max_quantity:\n                    max_quantity = unplaced_items[i]['quantity']\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n            x, y, z, orientation, waste = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and waste < min_waste:\n                min_waste = waste\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n        \n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._create_new_truck(item_type, truck_type)\n        \n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n        \n        occupied_volumes = truck['occupied_volumes']\n        \n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            for x in np.arange(0, truck_type[0] - length + self.epsilon, 1):\n                for y in np.arange(0, truck_type[1] - width + self.epsilon, 1):\n                    z = self._find_lowest_valid_z(x, y, length, width, height, truck_type, occupied_volumes)\n                    if z is not None:\n                        if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                            waste = self._evaluate_placement(x, y, z, length, width, height, truck_type, occupied_volumes)\n                            if waste < min_waste:\n                                min_waste = waste\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation_index\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _find_lowest_valid_z(self, x, y, length, width, height, truck_type, occupied_volumes):\n        z = 0\n        while z + height <= truck_type[2]:\n            is_valid = True\n            for placed_item in occupied_volumes:\n                if self._check_overlap_3d((x, y, z), (length, width, height), (placed_item['x'], placed_item['y'], placed_item['z']), (placed_item['length'], placed_item['width'], placed_item['height'])):\n                    is_valid = False\n                    z = placed_item['z'] + placed_item['height']\n                    break\n            if is_valid:\n                return z\n        return None\n\n    def _evaluate_placement(self, x, y, z, length, width, height, truck_type, occupied_volumes):\n        total_volume = truck_type[0] * truck_type[1] * truck_type[2]\n        occupied_volume = 0\n        for item in occupied_volumes:\n            occupied_volume += item['length'] * item['width'] * item['height']\n        \n        new_item_volume = length * width * height\n        \n        return total_volume - (occupied_volume + new_item_volume) + z * 0.0001\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                best_orientation = orientation_index\n                return -1, 0, 0, 0, best_orientation\n        return -1, -1, -1, -1, -1",
          "objective": 25.4,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Select the item with the largest volume and place it in the best available position, considering all orientations, within existing trucks or create a new truck if necessary.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select the item with the largest volume and place it in the best available position, considering all orientations, within existing trucks or create a new truck if necessary.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                volume = unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        max_score = -1\n\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n            x, y, z, orientation, score = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and score > max_score:\n                max_score = score\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n        \n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._create_new_truck(item_type, truck_type)\n        \n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = -1\n        \n        occupied_volumes = truck['occupied_volumes']\n        \n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            for x in np.arange(0, truck_type[0] - length + self.epsilon, 1):\n                for y in np.arange(0, truck_type[1] - width + self.epsilon, 1):\n                    z = self._find_lowest_valid_z(x, y, length, width, height, truck_type, occupied_volumes)\n                    if z is not None:\n                        if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                            score = self._evaluate_placement(x, y, z, length, width, height, truck_type)\n                            if score > best_score:\n                                best_score = score\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation_index\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_lowest_valid_z(self, x, y, length, width, height, truck_type, occupied_volumes):\n        z = 0\n        while z + height <= truck_type[2]:\n            is_valid = True\n            for placed_item in occupied_volumes:\n                if self._check_overlap_3d((x, y, z), (length, width, height), (placed_item['x'], placed_item['y'], placed_item['z']), (placed_item['length'], placed_item['width'], placed_item['height'])):\n                    is_valid = False\n                    z = placed_item['z'] + placed_item['height']\n                    break\n            if is_valid:\n                return z\n        return None\n\n    def _evaluate_placement(self, x, y, z, length, width, height, truck_type):\n        return truck_type[0] - (x + length) + truck_type[1] - (y + width) + truck_type[2] - (z + height)\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                best_orientation = orientation_index\n                return -1, 0, 0, 0, best_orientation\n        return -1, -1, -1, -1, -1",
          "objective": 25.85,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm prioritizes items with the largest footprint, attempting to place them in existing trucks using a skyline approach, and opens a new truck only when no existing truck has space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes items with the largest footprint, attempting to place them in existing trucks using a skyline approach, and opens a new truck only when no existing truck has space.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        footprints = np.array([item['length'] * item['width'] for item in unplaced_items])\n        item_index = np.argmax(footprints)\n        return item_index\n\n    def _find_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n             if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n            \n             x, y, z, orientation = self._find_position_in_truck(item_type, truck, truck_type)\n             if x is not None:\n                 return truck_index, x, y, z, orientation\n\n        truck_index, x, y, z, orientation = self._create_new_truck(item_type, trucks_in_use, truck_type)\n        return truck_index, x, y, z, orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n\n        for orientation, (length, width, height) in orientations:\n            x, y, z = self._find_skyline_position(length, width, height, truck_type, occupied_volumes)\n            if x is not None:\n                return x, y, z, orientation\n        return None, None, None, None\n\n    def _find_skyline_position(self, length, width, height, truck_dims, occupied_volumes):\n        best_x, best_y, best_z = None, None, None\n        min_z = float('inf')\n        \n        for x in np.arange(0, truck_dims[0] - length + self.epsilon, max(length, width) / 4):\n            for y in np.arange(0, truck_dims[1] - width + self.epsilon, max(length, width) / 4):\n                z = self._calculate_skyline_height(x, y, length, width, occupied_volumes)\n                if z + height <= truck_dims[2] + self.epsilon and self._is_valid_placement((x, y, z), (length, width, height), truck_dims, occupied_volumes):\n                    if z < min_z:\n                        min_z = z\n                        best_x, best_y, best_z = x, y, z\n\n        if best_x is not None:\n            return best_x, best_y, best_z\n        else:\n            return None, None, None\n\n    def _calculate_skyline_height(self, x, y, length, width, occupied_volumes):\n        max_height = 0\n        for placed_item in occupied_volumes:\n            if self._check_overlap_2d((x, y), (length, width), (placed_item['x'], placed_item['y']), (placed_item['length'], placed_item['width'])):\n                max_height = max(max_height, placed_item['z'] + placed_item['height'])\n        return max_height\n    \n    def _check_overlap_2d(self, item1_pos, item1_dims, item2_pos, item2_dims):\n        x1, y1 = item1_pos\n        l1, w1 = item1_dims\n        x2, y2 = item2_pos\n        l2, w2 = item2_dims\n        return (x1 < x2 + l2 and x1 + l1 > x2 and y1 < y2 + w2 and y1 + w1 > y2)\n\n    def _create_new_truck(self, item_type, trucks_in_use, truck_type):\n        orientations = self._get_orientations(item_type)\n        for orientation, (length, width, height) in orientations:\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                return -1, 0, 0, 0, orientation\n        return None, None, None, None, None\nclass AlgorithmFIX1(Algorithm):\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return int(truck_index), int(item_index), x, y, z, int(orientation)\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _select_item(self, unplaced_items):\n        remaining_quantities = np.array([item['quantity'] for item in unplaced_items])\n        valid_indices = np.where(remaining_quantities > 0)[0]\n        if len(valid_indices) == 0:\n            return -1\n        volumes = np.array([item['length'] * item['width'] * item['height'] for item in unplaced_items])\n        scores = remaining_quantities * volumes\n        \n        \n        valid_scores = scores[valid_indices]\n        if len(valid_scores) > 0 :\n            item_index = valid_indices[np.argmax(valid_scores)]\n        else:\n            item_index = -1 # Handle the edge case where all scores are zero\n\n        return item_index\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n       \n        item_index = self._select_item(unplaced_items)\n        if item_index == -1 :\n            return -1, -1, 0, 0, 0, 0\n\n        truck_index, x, y, z, orientation = self._find_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return int(truck_index), int(item_index), x, y, z, int(orientation)\n    def _find_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n             if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n            \n             x, y, z, orientation = self._find_position_in_truck(item_type, truck, truck_type)\n             if x is not None:\n                 return truck_index, x, y, z, orientation\n\n        truck_index, x, y, z, orientation = self._create_new_truck(item_type, trucks_in_use, truck_type)\n        return truck_index, x, y, z, orientation\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n\n        for orientation, (length, width, height) in orientations:\n            x, y, z = self._find_skyline_position(length, width, height, truck_type, occupied_volumes)\n            if x is not None:\n                return x, y, z, orientation\n        return None, None, None, None\n    def _create_new_truck(self, item_type, trucks_in_use, truck_type):\n      \n        orientations = self._get_orientations(item_type) \n        for orientation, (length, width, height) in orientations:\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                separation_set = item_type.get('separation_set')\n                if separation_set is not None:\n                     trucks_in_use.append({'separation_set':separation_set,'occupied_volumes':[]})   \n                return -1, 0, 0, 0, orientation\n                           \n        return None, None, None, None, None\n    def _find_skyline_position(self, length, width, height, truck_dims, occupied_volumes):\n        best_x, best_y, best_z = None, None, None\n        min_z = float('inf')\n        \n        x_step = max(length, width) / 4\n        y_step = max(length, width) / 4\n\n        for x in np.arange(0, truck_dims[0] - length + self.epsilon, x_step):\n            for y in np.arange(0, truck_dims[1] - width + self.epsilon, y_step):\n                z = self._calculate_skyline_height(x, y, length, width, occupied_volumes)\n                if z + height <= truck_dims[2] + self.epsilon and self._is_valid_placement((x, y, z), (length, width, height), truck_dims, occupied_volumes):\n                    if z < min_z:\n                        min_z = z\n                        best_x, best_y, best_z = x, y, z\n\n        if best_x is not None:\n            return best_x, best_y, best_z\n        else:\n            return None, None, None\n    def _is_valid_placement(self, item_to_place_pos, item_to_place_dims, container_dims, occupied_volumes):\n\n        if not self._is_within_container_bounds(item_to_place_pos, item_to_place_dims, container_dims):\n            return False\n        for placed_item in occupied_volumes:\n            placed_item_pos = (placed_item['x'], placed_item['y'], placed_item['z'])\n            placed_item_dims = (placed_item['length'], placed_item['width'], placed_item['height'])\n            if self._check_overlap_3d(item_to_place_pos, item_to_place_dims, placed_item_pos, placed_item_dims):\n                return False\n        \n        return True\n    def _check_overlap_3d(self, item1_pos, item1_dims, item2_pos, item2_dims):\n        x1, y1, z1 = item1_pos\n        l1, w1, h1 = item1_dims\n        x2, y2, z2 = item2_pos\n        l2, w2, h2 = item2_dims\n        return (x1 < x2 + l2 and x1 + l1 > x2 and\n                y1 < y2 + w2 and y1 + w1 > y2 and\n                z1 < z2 + h2 and z1 + h1 > z2)\n    def _check_overlap_2d(self, item1_pos, item1_dims, item2_pos, item2_dims):\n        x1, y1 = item1_pos\n        l1, w1 = item1_dims\n        x2, y2 = item2_pos\n        l2, w2 = item2_dims\n        return (x1 < x2 + l2 and x1 + l1 > x2 and y1 < y2 + w2 and y1 + w1 > y2)\n\n    def _is_within_container_bounds(self, item_pos, item_dims, container_dims):\n        px, py, pz = item_pos\n        pl, pw, ph = item_dims\n        cl, cw, ch = container_dims\n        return (px >= 0.0 - self.epsilon and px + pl <= cl + self.epsilon and\n                py >= 0.0 - self.epsilon and py + pw <= cw + self.epsilon and\n                pz >= 0.0 - self.epsilon and pz + ph <= ch + self.epsilon)\n    def _calculate_skyline_height(self, x, y, length, width, occupied_volumes):\n        max_height = 0\n        for placed_item in occupied_volumes:\n            if self._check_overlap_2d((x, y), (length, width), (placed_item['x'], placed_item['y']), (placed_item['length'], placed_item['width'])):\n                max_height = max(max_height, placed_item['z'] + placed_item['height'])\n        return max_height\n    def _get_orientations(self, item_type):\n        L, W, H = item_type['length'], item_type['width'], item_type['height']\n        return [\n            (0, (L, W, H)), (1, (L, H, W)), (2, (W, L, H)),\n            (3, (W, H, L)), (4, (H, L, W)), (5, (H, W, L))\n        ]",
          "objective": 26.55,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     },
     {
          "algorithm": "Select the item with the largest surface area and place it within existing trucks or create a new truck; prioritize placing items near the bottom to improve stability.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select the item with the largest surface area and place it within existing trucks or create a new truck; prioritize placing items near the bottom to improve stability.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_area = -1\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                area = 2 * (unplaced_items[i]['length'] * unplaced_items[i]['width'] +\n                            unplaced_items[i]['length'] * unplaced_items[i]['height'] +\n                            unplaced_items[i]['width'] * unplaced_items[i]['height'])\n                if area > max_area:\n                    max_area = area\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        max_score = -1\n\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n            x, y, z, orientation, score = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and score > max_score:\n                max_score = score\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n        \n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._create_new_truck(item_type, truck_type)\n        \n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = -1\n        \n        occupied_volumes = truck['occupied_volumes']\n        \n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            for x in np.arange(0, truck_type[0] - length + self.epsilon, 2):\n                for y in np.arange(0, truck_type[1] - width + self.epsilon, 2):\n                    z = self._find_lowest_valid_z(x, y, length, width, height, truck_type, occupied_volumes)\n                    if z is not None:\n                        if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                            score = self._evaluate_placement(x, y, z, length, width, height, truck_type)\n                            if score > best_score:\n                                best_score = score\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation_index\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_lowest_valid_z(self, x, y, length, width, height, truck_type, occupied_volumes):\n        z = 0\n        while z + height <= truck_type[2]:\n            is_valid = True\n            for placed_item in occupied_volumes:\n                if self._check_overlap_3d((x, y, z), (length, width, height), (placed_item['x'], placed_item['y'], placed_item['z']), (placed_item['length'], placed_item['width'], placed_item['height'])):\n                    is_valid = False\n                    z = placed_item['z'] + placed_item['height']\n                    break\n            if is_valid:\n                return z\n        return None\n\n    def _evaluate_placement(self, x, y, z, length, width, height, truck_type):\n        stability_bonus = truck_type[2] - z\n        return (truck_type[0] - (x + length) +\n                truck_type[1] - (y + width) +\n                truck_type[2] - (z + height) +\n                stability_bonus * 0.5)\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                best_orientation = orientation_index\n                return -1, 0, 0, 0, best_orientation\n        return -1, -1, -1, -1, -1",
          "objective": 26.6,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Prioritize placing items that best utilize the remaining volume in existing trucks, selecting the item with the smallest volume after filtering for valid placements.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Prioritize placing items that best utilize the remaining volume in existing trucks, selecting the item with the smallest volume after filtering for valid placements.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items, trucks_in_use, truck_type)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_item_index = -1\n        min_volume = float('inf')\n\n        potential_items = []\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                potential_items.append(i)\n\n        if not potential_items:\n            return -1\n        \n        valid_items = []\n        for item_index in potential_items:\n            item_type = unplaced_items[item_index]\n            for truck_index, truck in enumerate(trucks_in_use):\n                if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                    continue\n                x, y, z, orientation, score = self._find_position_in_truck(item_type, truck, truck_type)\n                if x != -1:\n                    valid_items.append(item_index)\n                    break\n            if not trucks_in_use:\n                valid_items.append(item_index)\n                break\n\n\n        if not valid_items:\n            for item_index in potential_items:\n                volume = unplaced_items[item_index]['length'] * unplaced_items[item_index]['width'] * unplaced_items[item_index]['height']\n                if volume < min_volume:\n                    min_volume = volume\n                    best_item_index = item_index\n        else:\n            min_volume = float('inf')\n            for item_index in valid_items:\n                volume = unplaced_items[item_index]['length'] * unplaced_items[item_index]['width'] * unplaced_items[item_index]['height']\n                if volume < min_volume:\n                    min_volume = volume\n                    best_item_index = item_index\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        max_score = -1\n\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n            x, y, z, orientation, score = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and score > max_score:\n                max_score = score\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n        \n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._create_new_truck(item_type, truck_type)\n        \n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_score = -1\n        \n        occupied_volumes = truck['occupied_volumes']\n        \n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            for x in np.arange(0, truck_type[0] - length + self.epsilon, 1):\n                for y in np.arange(0, truck_type[1] - width + self.epsilon, 1):\n                    z = self._find_lowest_valid_z(x, y, length, width, height, truck_type, occupied_volumes)\n                    if z is not None:\n                        if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                            score = self._evaluate_placement(x, y, z, length, width, height, truck_type)\n                            if score > best_score:\n                                best_score = score\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation_index\n        return best_x, best_y, best_z, best_orientation, best_score\n\n    def _find_lowest_valid_z(self, x, y, length, width, height, truck_type, occupied_volumes):\n        z = 0\n        while z + height <= truck_type[2]:\n            is_valid = True\n            for placed_item in occupied_volumes:\n                if self._check_overlap_3d((x, y, z), (length, width, height), (placed_item['x'], placed_item['y'], placed_item['z']), (placed_item['length'], placed_item['width'], placed_item['height'])):\n                    is_valid = False\n                    z = placed_item['z'] + placed_item['height']\n                    break\n            if is_valid:\n                return z\n        return None\n\n    def _evaluate_placement(self, x, y, z, length, width, height, truck_type):\n        return truck_type[0] - (x + length) + truck_type[1] - (y + width) + truck_type[2] - (z + height)\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                best_orientation = orientation_index\n                return -1, 0, 0, 0, best_orientation\n        return -1, -1, -1, -1, -1",
          "objective": 27.9,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]