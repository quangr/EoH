[
     {
          "algorithm": "Selects the item with the largest volume, places it using a first-fit decreasing height heuristic, respecting separation constraints and minimizing wasted space below the item.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item with the largest volume, places it using a first-fit decreasing height heuristic, respecting separation constraints and minimizing wasted space below the item.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                volume = unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n\n            x, y, z, orientation, waste = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and waste < min_waste:\n                min_waste = waste\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._create_new_truck(item_type, truck_type)\n            if best_truck_index == -2:\n                return -1, item_index, 0, 0, 0, 0\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n        occupied_volumes = truck['occupied_volumes']\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            for x in range(int(truck_type[0] - length + 1)):\n                for y in range(int(truck_type[1] - width + 1)):\n                    z = self._calculate_support_height((x, y), (length, width), occupied_volumes)\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                      waste = z\n                      if waste < min_waste:\n                        min_waste = waste\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _calculate_support_height(self, position, dimensions, occupied_volumes):\n        x, y = position\n        length, width = dimensions\n        max_z = 0\n        for item in occupied_volumes:\n            item_x = item['x']\n            item_y = item['y']\n            item_length = item['length']\n            item_width = item['width']\n            item_height = item['height']\n            item_z = item['z']\n            if (x < item_x + item_length and x + length > item_x and\n                    y < item_y + item_width and y + width > item_y):\n                max_z = max(max_z, item_z + item_height)\n        return max_z\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n        min_height = float('inf')\n        best_z = 0\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                if height < min_height:\n                    min_height = height\n                    best_orientation = orientation_index\n\n        if best_orientation != -1:\n            separation_set = item_type.get('separation_set')\n            return -1, 0, 0, best_z, best_orientation\n        return -2, -1, -1, -1, -1",
          "objective": 22.7,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects items based on remaining quantity and volume, placing them using a skyline-based approach that prioritizes filling the lowest available space within existing trucks.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects items based on remaining quantity and volume, placing them using a skyline-based approach that prioritizes filling the lowest available space within existing trucks.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n        self.quantity_weight = 0.6\n        self.volume_weight = 0.4\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        best_score = -1\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                item = unplaced_items[i]\n                volume = item['length'] * item['width'] * item['height']\n                quantity = item['quantity']\n                score = self.quantity_weight * quantity + self.volume_weight * volume\n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_z = float('inf')\n\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n            x, y, z, orientation = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and z < min_z:\n                min_z = z\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._create_new_truck(item_type, truck_type)\n            if best_truck_index == -2:\n                return -1, item_index, 0, 0, 0, 0\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_z = float('inf')\n        occupied_volumes = truck['occupied_volumes']\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            x, y, z = self._skyline_placement(length, width, height, truck_type, occupied_volumes)\n\n            if x != -1 and z < min_z:\n                min_z = z\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation\n\n    def _skyline_placement(self, length, width, height, truck_type, occupied_volumes):\n        best_x, best_y, best_z = -1, -1, -1\n        min_z = float('inf')\n        for x in range(0, int(truck_type[0] - length + 1)):\n            for y in range(0, int(truck_type[1] - width + 1)):\n                z = self._calculate_z(x, y, length, width, height, truck_type, occupied_volumes)\n                if z is not None and self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes) and z < min_z:\n                    min_z =z\n                    best_x, best_y, best_z = x, y, z\n        return best_x, best_y, best_z\n\n    def _calculate_z(self, x, y, length, width, height, truck_type, occupied_volumes):\n        max_z = 0\n        for item in occupied_volumes:\n            if self._check_overlap_2d((x, y), (length, width), (item['x'], item['y']), (item['length'], item['width'])):\n                max_z = max(max_z, item['z'] + item['height'])\n        if max_z + height > truck_type[2]:\n            return None\n        return max_z\n\n    def _check_overlap_2d(self, item1_pos, item1_dims, item2_pos, item2_dims):\n        x1, y1 = item1_pos\n        l1, w1 = item1_dims\n        x2, y2 = item2_pos\n        l2, w2 = item2_dims\n        return (x1 < x2 + l2 and x1 + l1 > x2 and\n                y1 < y2 + w2 and y1 + w1 > y2)\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n        min_height = float('inf')\n        best_z=0\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                if height < min_height:\n                    min_height = height\n                    best_orientation = orientation_index\n\n        if best_orientation != -1:\n            separation_set = item_type.get('separation_set')\n            return -1, 0, 0, best_z, best_orientation\n\n        return -2, -1, -1, -1, -1",
          "objective": 22.85,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects items based on a volume utilization score, and places them using a bottom-left-fill heuristic, prioritizing stability and minimizing the distance to the bottom-left corner.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects items based on a volume utilization score, and places them using a bottom-left-fill heuristic, prioritizing stability and minimizing the distance to the bottom-left corner.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items, truck_type)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items, truck_type):\n        best_item_index = -1\n        best_volume_utilization = -1\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                item = unplaced_items[i]\n                volume = item['length'] * item['width'] * item['height']\n                container_volume = truck_type[0] * truck_type[1] * truck_type[2]\n                volume_utilization = volume / container_volume\n\n                if volume_utilization > best_volume_utilization:\n                    best_volume_utilization = volume_utilization\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_bottom_left_distance = float('inf')\n\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n            x, y, z, orientation, bottom_left_distance = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and bottom_left_distance < min_bottom_left_distance:\n                min_bottom_left_distance = bottom_left_distance\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._create_new_truck(item_type, truck_type)\n            if best_truck_index == -2:\n                return -1, item_index, 0, 0, 0, 0\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_bottom_left_distance = float('inf')\n        occupied_volumes = truck['occupied_volumes']\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            x, y, z = self._bottom_left_fill_placement(length, width, height, truck_type, occupied_volumes)\n\n            if x != -1:\n                bottom_left_distance = self._calculate_bottom_left_distance(x, y, z)\n\n                if bottom_left_distance < min_bottom_left_distance:\n                    min_bottom_left_distance = bottom_left_distance\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation, min_bottom_left_distance\n\n    def _bottom_left_fill_placement(self, length, width, height, truck_type, occupied_volumes):\n        best_x, best_y, best_z = -1, -1, -1\n\n        for z in sorted(list(set([0] + [item['z'] + item['height'] for item in occupied_volumes]))):\n            for y in sorted(list(set([0] + [item['y'] + item['width'] for item in occupied_volumes]))):\n                for x in sorted(list(set([0] + [item['x'] + item['length'] for item in occupied_volumes]))):\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                        is_stable = self._is_stable((x, y, z), (length, width, height), truck_type, occupied_volumes)\n                        if is_stable:\n                            return x, y, z\n        return best_x, best_y, best_z\n\n    def _is_stable(self, position, dimensions, truck_type, occupied_volumes):\n        x, y, z = position\n        length, width, height = dimensions\n\n        if z == 0:\n            return True\n\n        for placed_item in occupied_volumes:\n            px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n            pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n\n            if (x < px + pl and x + length > px and\n                y < py + pw and y + width > py and\n                z == pz + ph):\n                return True\n\n        return False\n\n    def _calculate_bottom_left_distance(self, x, y, z):\n        return (x**2 + y**2 + z**2)**0.5\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n        min_height = float('inf')\n        best_z=0\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                if height < min_height:\n                    min_height = height\n                    best_orientation = orientation_index\n\n        if best_orientation != -1:\n            separation_set = item_type.get('separation_set')\n            return -1, 0, 0, best_z, best_orientation\n\n        return -2, -1, -1, -1, -1",
          "objective": 23.2,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Prioritizing item selection by largest volume, places each item using a bottom-left-fill heuristic within existing trucks or a new truck if necessary, minimizing wasted space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Prioritizing item selection by largest volume, places each item using a bottom-left-fill heuristic within existing trucks or a new truck if necessary, minimizing wasted space.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                item = unplaced_items[i]\n                volume = item['length'] * item['width'] * item['height']\n\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n            x, y, z, orientation, waste = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and waste < min_waste:\n                min_waste = waste\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._create_new_truck(item_type, truck_type)\n            if best_truck_index == -2:\n                return -1, item_index, 0, 0, 0, 0\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n        occupied_volumes = truck['occupied_volumes']\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            x, y, z = self._bottom_left_fill(length, width, height, truck_type, occupied_volumes)\n\n            if x != -1:\n                waste = self._calculate_waste(x, y, z, length, width, height, truck_type)\n\n                if waste < min_waste:\n                    min_waste = waste\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _bottom_left_fill(self, length, width, height, truck_type, occupied_volumes):\n        best_x, best_y, best_z = -1, -1, -1\n        \n        # Sort occupied volumes by z, then y, then x\n        sorted_volumes = sorted(occupied_volumes, key=lambda v: (v['z'], v['y'], v['x']))\n\n        for z in sorted(list(set([0] + [item['z'] + item['height'] for item in sorted_volumes]))):\n            for y in sorted(list(set([0] + [item['y'] + item['width'] for item in sorted_volumes]))):\n                for x in sorted(list(set([0] + [item['x'] + item['length'] for item in sorted_volumes]))):\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                        return x, y, z\n\n        return best_x, best_y, best_z\n\n    def _calculate_waste(self, x, y, z, length, width, height, truck_type):\n        return (truck_type[0] * truck_type[1] * truck_type[2]) - ((truck_type[0] - x) * (truck_type[1] - y) * (truck_type[2] - z))\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n        min_height = float('inf')\n        best_z=0\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                if height < min_height:\n                    min_height = height\n                    best_orientation = orientation_index\n\n        if best_orientation != -1:\n            separation_set = item_type.get('separation_set')\n            return -1, 0, 0, best_z, best_orientation\n\n        return -2, -1, -1, -1, -1",
          "objective": 23.25,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects items based on their largest dimension and places them by simulating a Tetris-like packing strategy, prioritizing stable placements and minimizing empty space above placed items.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects items based on their largest dimension and places them by simulating a Tetris-like packing strategy, prioritizing stable placements and minimizing empty space above placed items.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_dimension = -1\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                item = unplaced_items[i]\n                max_val = max(item['length'], item['width'], item['height'])\n\n                if max_val > max_dimension:\n                    max_dimension = max_val\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_empty_space = float('inf')\n\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n            x, y, z, orientation, empty_space = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and empty_space < min_empty_space:\n                min_empty_space = empty_space\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._create_new_truck(item_type, truck_type)\n            if best_truck_index == -2:\n                return -1, item_index, 0, 0, 0, 0\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_empty_space = float('inf')\n        occupied_volumes = truck['occupied_volumes']\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            x, y, z = self._tetris_placement(length, width, height, truck_type, occupied_volumes)\n\n            if x != -1:\n                empty_space = self._calculate_empty_space(x, y, z, length, width, height, truck_type)\n\n                if empty_space < min_empty_space:\n                    min_empty_space = empty_space\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation, min_empty_space\n\n    def _tetris_placement(self, length, width, height, truck_type, occupied_volumes):\n        valid_positions = []\n\n        for z in sorted(list(set([0] + [item['z'] + item['height'] for item in occupied_volumes]))):\n            for y in sorted(list(set([0] + [item['y'] + item['width'] for item in occupied_volumes]))):\n                for x in sorted(list(set([0] + [item['x'] + item['length'] for item in occupied_volumes]))):\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                        valid_positions.append((x, y, z))\n\n        if not valid_positions:\n            return -1, -1, -1\n\n        best_x, best_y, best_z = -1, -1, -1\n        min_z = float('inf')\n\n        for x, y, z in valid_positions:\n          \n            is_stable = self._is_stable((x, y, z), (length, width, height), truck_type, occupied_volumes)\n            if z < min_z and is_stable:\n                min_z = z\n                best_x, best_y, best_z = x, y, z\n\n        if best_x == -1:\n          return -1, -1, -1\n        return best_x, best_y, best_z\n\n    def _is_stable(self, position, dimensions, truck_type, occupied_volumes):\n        x, y, z = position\n        length, width, height = dimensions\n\n        if z == 0:\n            return True\n\n        for placed_item in occupied_volumes:\n            px, py, pz = placed_item['x'], placed_item['y'], placed_item['z']\n            pl, pw, ph = placed_item['length'], placed_item['width'], placed_item['height']\n\n            if (x < px + pl and x + length > px and\n                y < py + pw and y + width > py and\n                z == pz + ph):\n                return True\n\n        return False\n\n    def _calculate_empty_space(self, x, y, z, length, width, height, truck_type):\n        return (truck_type[0] - (x + length)) * (truck_type[1] - (y + width)) * (truck_type[2] - (z + height))\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n        min_height = float('inf')\n        best_z=0\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                if height < min_height:\n                    min_height = height\n                    best_orientation = orientation_index\n\n        if best_orientation != -1:\n            separation_set = item_type.get('separation_set')\n            return -1, 0, 0, best_z, best_orientation\n\n        return -2, -1, -1, -1, -1",
          "objective": 23.35,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]