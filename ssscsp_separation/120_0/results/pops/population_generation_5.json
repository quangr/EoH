[
     {
          "algorithm": "Selects an item based on the ratio of its volume to its surface area, places it using a bottom-left heuristic, and prioritizes trucks with similar separation sets while minimizing the empty space in the truck.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects an item based on the ratio of its volume to its surface area, places it using a bottom-left heuristic, and prioritizes trucks with similar separation sets while minimizing the empty space in the truck.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_ratio = -1\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                volume = unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height']\n                surface_area = 2 * (unplaced_items[i]['length'] * unplaced_items[i]['width'] +\n                                      unplaced_items[i]['length'] * unplaced_items[i]['height'] +\n                                      unplaced_items[i]['width'] * unplaced_items[i]['height'])\n                if surface_area > 0:\n                  ratio = volume / surface_area\n                else:\n                  ratio = 0\n                if ratio > max_ratio:\n                    max_ratio = ratio\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n\n        item_type = unplaced_items[item_index]\n        item_separation_set = item_type.get('separation_set')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            truck_separation_set = truck.get('separation_set')\n            \n            if item_separation_set is not None and truck_separation_set is not None and item_separation_set != truck_separation_set:\n                continue\n\n            x, y, z, orientation, waste = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and waste < min_waste:\n                min_waste = waste\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation, waste = self._create_new_truck(item_type, truck_type)\n            if best_truck_index == -2:\n                return -1, item_index, 0, 0, 0, 0\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n        occupied_volumes = truck['occupied_volumes']\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            x, y, z = self._bottom_left_fill(length, width, height, truck_type, occupied_volumes)\n            if x != -1:\n                waste = self._evaluate_placement(x, y, z, length, width, height, truck_type)\n                if waste < min_waste:\n                    min_waste = waste\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _bottom_left_fill(self, length, width, height, truck_type, occupied_volumes):\n        best_x, best_y, best_z = -1, -1, -1\n        \n        possible_positions = []\n        if not occupied_volumes:\n          if self._is_valid_placement((0, 0, 0), (length, width, height), truck_type, occupied_volumes):\n            return 0, 0, 0\n          else:\n            return -1, -1, -1\n        \n        for z in sorted(list(set([0] + [item['z'] + item['height'] for item in occupied_volumes]))):\n          for y in sorted(list(set([0] + [item['y'] + item['width'] for item in occupied_volumes]))):\n            for x in sorted(list(set([0] + [item['x'] + item['length'] for item in occupied_volumes]))):\n              if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                possible_positions.append((x,y,z))\n        \n        if not possible_positions:\n          return -1, -1, -1\n        \n        \n        \n        \n        placed = False\n        for x, y, z in sorted(possible_positions, key=lambda k: (k[2], k[1], k[0])):\n          if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n            return x, y, z\n            placed = True\n            break\n            \n        if not placed:\n          return -1, -1, -1\n        \n\n    def _evaluate_placement(self, x, y, z, length, width, height, truck_type):\n        return (truck_type[0] - (x + length)) * (truck_type[1] - (y + width)) * (truck_type[2] - (z + height))\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n        min_waste = float('inf')\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                waste = (truck_type[0] - length) * (truck_type[1] - width) * (truck_type[2] - height)\n                if waste < min_waste:\n                    min_waste = waste\n                    best_orientation = orientation_index\n\n        if best_orientation != -1:\n            separation_set = item_type.get('separation_set')\n            return -1, 0, 0, 0, best_orientation, min_waste\n        return -2, -1, -1, -1, -1, float('inf')",
          "objective": 24.0,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects the largest remaining item and places it using a bottom-left heuristic, prioritizing trucks with compatible separation sets while aiming for minimal empty volume.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the largest remaining item and places it using a bottom-left heuristic, prioritizing trucks with compatible separation sets while aiming for minimal empty volume.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                volume = unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n\n        item_type = unplaced_items[item_index]\n        item_separation_set = item_type.get('separation_set')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            truck_separation_set = truck.get('separation_set')\n            \n            if item_separation_set is not None and truck_separation_set is not None and item_separation_set != truck_separation_set:\n                continue\n\n            x, y, z, orientation, waste = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and waste < min_waste:\n                min_waste = waste\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation, waste = self._create_new_truck(item_type, truck_type)\n            if best_truck_index == -2:\n                return -1, item_index, 0, 0, 0, 0\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n        occupied_volumes = truck['occupied_volumes']\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            x, y, z = self._bottom_left_fill(length, width, height, truck_type, occupied_volumes)\n            if x != -1:\n                waste = self._evaluate_placement(x, y, z, length, width, height, truck_type)\n                if waste < min_waste:\n                    min_waste = waste\n                    best_x = x\n                    best_y = y\n                    best_z = z\n                    best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _bottom_left_fill(self, length, width, height, truck_type, occupied_volumes):\n        best_x, best_y, best_z = -1, -1, -1\n        \n        possible_positions = []\n        if not occupied_volumes:\n          if self._is_valid_placement((0, 0, 0), (length, width, height), truck_type, occupied_volumes):\n            return 0, 0, 0\n          else:\n            return -1, -1, -1\n        \n        for z in sorted(list(set([0] + [item['z'] + item['height'] for item in occupied_volumes]))):\n          for y in sorted(list(set([0] + [item['y'] + item['width'] for item in occupied_volumes]))):\n            for x in sorted(list(set([0] + [item['x'] + item['length'] for item in occupied_volumes]))):\n              if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                possible_positions.append((x,y,z))\n        \n        if not possible_positions:\n          return -1, -1, -1\n        \n        \n        \n        \n        placed = False\n        for x, y, z in sorted(possible_positions, key=lambda k: (k[2], k[1], k[0])):\n          if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n            return x, y, z\n            placed = True\n            break\n            \n        if not placed:\n          return -1, -1, -1\n        \n\n    def _evaluate_placement(self, x, y, z, length, width, height, truck_type):\n        return (truck_type[0] - (x + length)) * (truck_type[1] - (y + width)) * (truck_type[2] - (z + height))\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n        min_waste = float('inf')\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                waste = (truck_type[0] - length) * (truck_type[1] - width) * (truck_type[2] - height)\n                if waste < min_waste:\n                    min_waste = waste\n                    best_orientation = orientation_index\n\n        if best_orientation != -1:\n            separation_set = item_type.get('separation_set')\n            return -1, 0, 0, 0, best_orientation, min_waste\n        return -2, -1, -1, -1, -1, float('inf')",
          "objective": 24.05,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Select the item with the largest volume, place it using a first-fit decreasing height heuristic, prioritizing corners and separation constraints.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select the item with the largest volume, place it using a first-fit decreasing height heuristic, prioritizing corners and separation constraints.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                volume = unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_z = float('inf')\n\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n            x, y, z, orientation = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and z < min_z:\n                min_z = z\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._create_new_truck(item_type, truck_type)\n            if best_truck_index == -2:\n              return -1, item_index, 0, 0, 0, 0\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_z = float('inf')\n        \n        occupied_volumes = truck['occupied_volumes']\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            \n            positions = [(0, 0), (0, truck_type[1] - width), (truck_type[0] - length, 0), (truck_type[0] - length, truck_type[1] - width)]\n\n            for x, y in positions:\n                if x < 0 or y < 0 or x + length > truck_type[0] or y + width > truck_type[1]:\n                  continue\n                z = self._find_lowest_valid_z(x, y, length, width, height, truck_type, occupied_volumes)\n                if z is not None:\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                        if z < min_z:\n                            min_z = z\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            best_orientation = orientation_index\n        return best_x, best_y, best_z, best_orientation\n\n    def _find_lowest_valid_z(self, x, y, length, width, height, truck_type, occupied_volumes):\n        z = 0\n        while z + height <= truck_type[2]:\n            is_valid = True\n            for placed_item in occupied_volumes:\n                if self._check_overlap_3d((x, y, z), (length, width, height), (placed_item['x'], placed_item['y'], placed_item['z']), (placed_item['length'], placed_item['width'], placed_item['height'])):\n                    is_valid = False\n                    z = placed_item['z'] + placed_item['height']\n                    break\n            if is_valid:\n                return z\n        return None\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n        min_height = float('inf')\n        best_z=0\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                if height < min_height:\n                    min_height = height\n                    best_orientation = orientation_index\n                    \n        if best_orientation != -1:\n          separation_set = item_type.get('separation_set')\n          return -1, 0, 0, best_z, best_orientation\n        return -2, -1, -1, -1, -1",
          "objective": 24.2,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects items based on a weighted score of volume and aspect ratio, places them using a best-fit heuristic considering corner positions and minimizing wasted space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects items based on a weighted score of volume and aspect ratio, places them using a best-fit heuristic considering corner positions and minimizing wasted space.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n        self.volume_weight = 0.7\n        self.aspect_ratio_weight = 0.3\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        best_score = -1\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                item = unplaced_items[i]\n                volume = item['length'] * item['width'] * item['height']\n                \n                dims = [item['length'], item['width'], item['height']]\n                max_dim = max(dims)\n                min_dim = min(dims)\n                aspect_ratio = min_dim / max_dim if max_dim > 0 else 0\n                \n                score = self.volume_weight * volume + self.aspect_ratio_weight * aspect_ratio\n\n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_wasted_space = float('inf')\n\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n            x, y, z, orientation, wasted_space = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and wasted_space < min_wasted_space:\n                min_wasted_space = wasted_space\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._create_new_truck(item_type, truck_type)\n            if best_truck_index == -2:\n              return -1, item_index, 0, 0, 0, 0\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_wasted_space = float('inf')\n        occupied_volumes = truck['occupied_volumes']\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            positions = [(0, 0), (0, truck_type[1] - width if truck_type[1] - width > 0 else 0), \n                         (truck_type[0] - length if truck_type[0] - length > 0 else 0, 0), \n                         (truck_type[0] - length if truck_type[0] - length > 0 else 0, truck_type[1] - width if truck_type[1] - width > 0 else 0)]\n\n            for x, y in positions:\n\n                if x < 0 or y < 0 or x + length > truck_type[0] or y + width > truck_type[1]:\n                  continue\n                z = self._find_lowest_valid_z(x, y, length, width, height, truck_type, occupied_volumes)\n                if z is not None:\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                        wasted_space = self._calculate_wasted_space(x, y, z, length, width, height, truck_type, occupied_volumes)\n                        if wasted_space < min_wasted_space:\n                            min_wasted_space = wasted_space\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation, min_wasted_space\n\n    def _find_lowest_valid_z(self, x, y, length, width, height, truck_type, occupied_volumes):\n        z = 0\n        while z + height <= truck_type[2]:\n            is_valid = True\n            for placed_item in occupied_volumes:\n                if self._check_overlap_3d((x, y, z), (length, width, height), (placed_item['x'], placed_item['y'], placed_item['z']), (placed_item['length'], placed_item['width'], placed_item['height'])):\n                    is_valid = False\n                    z = placed_item['z'] + placed_item['height']\n                    break\n            if is_valid:\n                return z\n        return None\n\n    def _calculate_wasted_space(self, x, y, z, length, width, height, truck_type, occupied_volumes):\n        wasted_space = 0\n        \n        wasted_space += x\n        wasted_space += y\n        wasted_space += z\n        \n        wasted_space += truck_type[0] - (x + length)\n        wasted_space += truck_type[1] - (y + width)\n        wasted_space += truck_type[2] - (z + height)\n\n        return wasted_space\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n        min_height = float('inf')\n        best_z=0\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                if height < min_height:\n                    min_height = height\n                    best_orientation = orientation_index\n        if best_orientation != -1:\n          separation_set = item_type.get('separation_set')\n          return -1, 0, 0, best_z, best_orientation\n        return -2, -1, -1, -1, -1",
          "objective": 24.4,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Select the item with largest surface area, place it using a skyline heuristic to find the lowest-z position, and prioritize filling lower truck indices and minimizing wasted space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select the item with largest surface area, place it using a skyline heuristic to find the lowest-z position, and prioritize filling lower truck indices and minimizing wasted space.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_area = -1\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                area = 2 * (unplaced_items[i]['length'] * unplaced_items[i]['width'] +\n                            unplaced_items[i]['length'] * unplaced_items[i]['height'] +\n                            unplaced_items[i]['width'] * unplaced_items[i]['height'])\n                if area > max_area:\n                    max_area = area\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n            x, y, z, orientation, waste = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and waste < min_waste:\n                min_waste = waste\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation, waste = self._create_new_truck(item_type, truck_type)\n            if best_truck_index == -2:\n              return -1, item_index, 0, 0, 0, 0\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n        \n        occupied_volumes = truck['occupied_volumes']\n        \n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            for x in np.arange(0, truck_type[0] - length + self.epsilon, 1):\n                for y in np.arange(0, truck_type[1] - width + self.epsilon, 1):\n                    z = self._find_lowest_valid_z(x, y, length, width, height, truck_type, occupied_volumes)\n                    if z is not None:\n                        if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                            waste = self._evaluate_placement(x, y, z, length, width, height, truck_type)\n                            if waste < min_waste:\n                                min_waste = waste\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation_index\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _find_lowest_valid_z(self, x, y, length, width, height, truck_type, occupied_volumes):\n        z = 0\n        while z + height <= truck_type[2]:\n            is_valid = True\n            for placed_item in occupied_volumes:\n                if self._check_overlap_3d((x, y, z), (length, width, height), (placed_item['x'], placed_item['y'], placed_item['z']), (placed_item['length'], placed_item['width'], placed_item['height'])):\n                    is_valid = False\n                    z = placed_item['z'] + placed_item['height']\n                    break\n            if is_valid:\n                return z\n        return None\n    \n    def _evaluate_placement(self, x, y, z, length, width, height, truck_type):\n        return (truck_type[0] - (x + length)) * (truck_type[1] - (y + width)) * (truck_type[2] - (z + height))\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n        min_waste = float('inf')\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                waste = (truck_type[0] - length) * (truck_type[1] - width) * (truck_type[2] - height)\n                if waste < min_waste:\n                    min_waste = waste\n                    best_orientation = orientation_index\n                    \n        if best_orientation != -1:\n          separation_set = item_type.get('separation_set')\n          return -1, 0, 0, 0, best_orientation, min_waste\n        return -2, -1, -1, -1, -1, float('inf')",
          "objective": 24.45,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]