[
     {
          "algorithm": "Selects the item with the largest volume, places it using a first-fit decreasing height heuristic, respecting separation constraints and minimizing wasted space below the item.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item with the largest volume, places it using a first-fit decreasing height heuristic, respecting separation constraints and minimizing wasted space below the item.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_volume = -1\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                volume = unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height']\n                if volume > max_volume:\n                    max_volume = volume\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n\n            x, y, z, orientation, waste = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and waste < min_waste:\n                min_waste = waste\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._create_new_truck(item_type, truck_type)\n            if best_truck_index == -2:\n                return -1, item_index, 0, 0, 0, 0\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n        occupied_volumes = truck['occupied_volumes']\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            for x in range(int(truck_type[0] - length + 1)):\n                for y in range(int(truck_type[1] - width + 1)):\n                    z = self._calculate_support_height((x, y), (length, width), occupied_volumes)\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                      waste = z\n                      if waste < min_waste:\n                        min_waste = waste\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _calculate_support_height(self, position, dimensions, occupied_volumes):\n        x, y = position\n        length, width = dimensions\n        max_z = 0\n        for item in occupied_volumes:\n            item_x = item['x']\n            item_y = item['y']\n            item_length = item['length']\n            item_width = item['width']\n            item_height = item['height']\n            item_z = item['z']\n            if (x < item_x + item_length and x + length > item_x and\n                    y < item_y + item_width and y + width > item_y):\n                max_z = max(max_z, item_z + item_height)\n        return max_z\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n        min_height = float('inf')\n        best_z = 0\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                if height < min_height:\n                    min_height = height\n                    best_orientation = orientation_index\n\n        if best_orientation != -1:\n            separation_set = item_type.get('separation_set')\n            return -1, 0, 0, best_z, best_orientation\n        return -2, -1, -1, -1, -1",
          "objective": 22.7,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects items based on a space-filling curve heuristic (e.g., Z-order curve) to prioritize dense packing, adapting item placement to minimize wasted space in each container.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects items based on a space-filling curve heuristic (e.g., Z-order curve) to prioritize dense packing, adapting item placement to minimize wasted space in each container.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items, trucks_in_use, truck_type)\n        if item_index == -1:\n            return -1, -1, 0, 0, 0, 0\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items, trucks_in_use, truck_type):\n        best_item_index = -1\n        best_fill_rate = -1\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                item = unplaced_items[i]\n                truck_index, x, y, z, orientation = self._evaluate_item_fitness(item, unplaced_items, trucks_in_use, truck_type)\n\n                if truck_index != -2:\n                    orientation_index, dims = self._get_orientations(item)[orientation]\n                    volume = dims[0] * dims[1] * dims[2]\n                    truck_volume = truck_type[0] * truck_type[1] * truck_type[2]\n                    fill_rate = volume / truck_volume\n\n                    if fill_rate > best_fill_rate:\n                        best_fill_rate = fill_rate\n                        best_item_index = i\n        return best_item_index\n\n    def _evaluate_item_fitness(self, item_type, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_z = float('inf')\n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n            x, y, z, orientation = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and z < min_z:\n                min_z = z\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._create_new_truck(item_type, truck_type)\n            if best_truck_index == -2:\n                return -2, -1, -1, -1, -1,\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        item_type = unplaced_items[item_index]\n        truck_index, x, y, z, orientation = self._evaluate_item_fitness(item_type, unplaced_items, trucks_in_use, truck_type)\n        return truck_index, x, y, z, orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_z = float('inf')\n        occupied_volumes = truck['occupied_volumes']\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            x, y, z = self._space_filling_curve_position((length, width, height), truck_type, occupied_volumes)\n            if x != -1:\n                if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                    if z < min_z:\n                        min_z = z\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n        return best_x, best_y, best_z, best_orientation\n\n    def _space_filling_curve_position(self, dimensions, truck_type, occupied_volumes):\n        length, width, height = dimensions\n        best_x, best_y, best_z = -1, -1, -1\n        container_length, container_width, container_height = truck_type\n\n        for z in range(0, container_height, 1):\n            for y in range(0, container_width, 1):\n                for x in range(0, container_length, 1):\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                        return x, y, z\n        return best_x, best_y, best_z\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n        min_height = float('inf')\n        best_z = 0\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                if height < min_height:\n                    min_height = height\n                    best_orientation = orientation_index\n\n        if best_orientation != -1:\n            separation_set = item_type.get('separation_set')\n            return -1, 0, 0, best_z, best_orientation\n        return -2, -1, -1, -1, -1\nimport numpy as np\n\nclass AlgorithmFIX1(Algorithm):\n    def _space_filling_curve_position(self, dimensions, truck_type, occupied_volumes):\n        length, width, height = dimensions\n        best_x, best_y, best_z = -1, -1, -1\n        container_length, container_width, container_height = truck_type\n\n        possible_positions = []\n        for z in range(0, container_height - int(height) + 1):\n            for y in range(0, container_width - int(width) + 1):\n                for x in range(0, container_length - int(length) + 1):\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                        possible_positions.append((x, y, z))\n\n        if not possible_positions:\n            return best_x, best_y, best_z\n\n        return possible_positions[0]\nimport numpy as np\n\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _space_filling_curve_position(self, dimensions, truck_type, occupied_volumes):\n        length, width, height = dimensions\n        best_x, best_y, best_z = -1, -1, -1\n        container_length, container_width, container_height = truck_type\n        \n        \n        x_coords = sorted(list(set([0.0] + [item['x'] + item['length'] + self.epsilon for item in occupied_volumes] + [container_length - length - self.epsilon])))\n        y_coords = sorted(list(set([0.0] + [item['y'] + item['width'] + self.epsilon for item in occupied_volumes] + [container_width - width - self.epsilon])))\n        z_coords = sorted(list(set([0.0] + [item['z'] + item['height'] + self.epsilon for item in occupied_volumes] + [container_height - height - self.epsilon])))\n        \n        \n        possible_positions = []\n        for z in z_coords:\n            for y in y_coords:\n                for x in x_coords:\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                        possible_positions.append((x, y, z))\n\n        if not possible_positions:\n            return best_x, best_y, best_z\n        \n        return possible_positions[0]\nimport numpy as np\n\nclass AlgorithmFIX3(AlgorithmFIX2):\n    def _space_filling_curve_position(self, dimensions, truck_type, occupied_volumes):\n        length, width, height = dimensions\n        best_x, best_y, best_z = -1, -1, -1\n        container_length, container_width, container_height = truck_type\n\n        possible_positions = []\n        x_coords = sorted(list(set([0.0] + [item['x'] + item['length'] for item in occupied_volumes] )))\n        y_coords = sorted(list(set([0.0] + [item['y'] + item['width'] for item in occupied_volumes] )))\n        z_coords = sorted(list(set([0.0] + [item['z'] + item['height'] for item in occupied_volumes] )))\n        \n        for z in z_coords:\n            for y in y_coords:\n                for x in x_coords:\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                        possible_positions.append((x, y, z))\n\n        if not possible_positions:\n            return best_x, best_y, best_z\n\n        best_pos = possible_positions[0]\n        \n        return best_pos",
          "objective": 22.75,
          "other_inf": null,
          "class_name": "AlgorithmFIX3"
     },
     {
          "algorithm": "Selects the item with the highest priority based on a weighted combination of volume and remaining quantity, placing it using a bottom-left fill approach and adjusting position to minimize the contact area with other items.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects the item with the highest priority based on a weighted combination of volume and remaining quantity, placing it using a bottom-left fill approach and adjusting position to minimize the contact area with other items.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n        self.quantity_weight = 0.5\n        self.volume_weight = 0.5\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        best_score = -1\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                item = unplaced_items[i]\n                volume = item['length'] * item['width'] * item['height']\n                quantity = item['quantity']\n                score = self.quantity_weight * quantity + self.volume_weight * volume\n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_contact_area = float('inf')\n\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n            x, y, z, orientation, contact_area = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and contact_area < min_contact_area:\n                min_contact_area = contact_area\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._create_new_truck(item_type, truck_type)\n            if best_truck_index == -2:\n                return -1, item_index, 0, 0, 0, 0\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_contact_area = float('inf')\n        occupied_volumes = truck['occupied_volumes']\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            x, y, z = self._bottom_left_fill(length, width, height, truck_type, occupied_volumes)\n\n            if x != -1 and self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n              x, y, z, contact_area = self._adjust_position(x, y, z, length, width, height, truck_type, occupied_volumes)\n              if contact_area < min_contact_area:\n                min_contact_area = contact_area\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation, min_contact_area\n\n    def _bottom_left_fill(self, length, width, height, truck_type, occupied_volumes):\n         best_x, best_y, best_z = -1, -1, -1\n\n         for z in sorted(list(set([0] + [item['z'] + item['height'] for item in occupied_volumes]))):\n              for x in sorted(list(set([0] + [item['x'] + item['length'] for item in occupied_volumes]))):\n                for y in sorted(list(set([0] + [item['y'] + item['width'] for item in occupied_volumes]))):\n                  if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                    return x, y, z\n         return best_x, best_y, best_z\n\n    def _adjust_position(self, x, y, z, length, width, height, truck_type, occupied_volumes):\n\n        best_x, best_y, best_z = x, y, z\n        min_contact_area = self._calculate_contact_area(x, y, z, length, width, height, occupied_volumes)\n\n        new_x = x\n        while new_x > 0:\n            new_x -= 1\n            if not self._is_valid_placement((new_x, y, z), (length, width, height), truck_type, occupied_volumes):\n                break\n            contact_area = self._calculate_contact_area(new_x, y, z, length, width, height, occupied_volumes)\n            if contact_area < min_contact_area:\n                min_contact_area = contact_area\n                best_x = new_x\n                \n\n        new_y = y\n        while new_y > 0:\n            new_y -= 1\n            if not self._is_valid_placement((x, new_y, z), (length, width, height), truck_type, occupied_volumes):\n                break\n            contact_area = self._calculate_contact_area(x, new_y, z, length, width, height, occupied_volumes)\n            if contact_area < min_contact_area:\n                min_contact_area = contact_area\n                best_y = new_y\n               \n\n        return best_x, best_y, best_z, min_contact_area\n\n    def _calculate_contact_area(self, x, y, z, length, width, height, occupied_volumes):\n        contact_area = 0\n        for item in occupied_volumes:\n            if self._check_overlap_3d((x, y, z), (length, width, height), (item['x'], item['y'], item['z']), (item['length'], item['width'], item['height'])):\n                overlap_x = max(0, min(x + length, item['x'] + item['length']) - max(x, item['x']))\n                overlap_y = max(0, min(y + width, item['y'] + item['width']) - max(y, item['y']))\n                overlap_z = max(0, min(z + height, item['z'] + item['height']) - max(z, item['z']))\n                contact_area += (overlap_x * overlap_y + overlap_x * overlap_z + overlap_y * overlap_z)\n        return contact_area\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n        min_height = float('inf')\n        best_z = 0\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                if height < min_height:\n                    min_height = height\n                    best_orientation = orientation_index\n\n        if best_orientation != -1:\n            separation_set = item_type.get('separation_set')\n            return -1, 0, 0, best_z, best_orientation\n\n        return -2, -1, -1, -1, -1",
          "objective": 22.8,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects items based on remaining quantity and volume, placing them using a skyline-based approach that prioritizes filling the lowest available space within existing trucks.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects items based on remaining quantity and volume, placing them using a skyline-based approach that prioritizes filling the lowest available space within existing trucks.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n        self.quantity_weight = 0.6\n        self.volume_weight = 0.4\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        best_score = -1\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                item = unplaced_items[i]\n                volume = item['length'] * item['width'] * item['height']\n                quantity = item['quantity']\n                score = self.quantity_weight * quantity + self.volume_weight * volume\n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_z = float('inf')\n\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n            x, y, z, orientation = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and z < min_z:\n                min_z = z\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._create_new_truck(item_type, truck_type)\n            if best_truck_index == -2:\n                return -1, item_index, 0, 0, 0, 0\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_z = float('inf')\n        occupied_volumes = truck['occupied_volumes']\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            x, y, z = self._skyline_placement(length, width, height, truck_type, occupied_volumes)\n\n            if x != -1 and z < min_z:\n                min_z = z\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation\n\n    def _skyline_placement(self, length, width, height, truck_type, occupied_volumes):\n        best_x, best_y, best_z = -1, -1, -1\n        min_z = float('inf')\n        for x in range(0, int(truck_type[0] - length + 1)):\n            for y in range(0, int(truck_type[1] - width + 1)):\n                z = self._calculate_z(x, y, length, width, height, truck_type, occupied_volumes)\n                if z is not None and self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes) and z < min_z:\n                    min_z =z\n                    best_x, best_y, best_z = x, y, z\n        return best_x, best_y, best_z\n\n    def _calculate_z(self, x, y, length, width, height, truck_type, occupied_volumes):\n        max_z = 0\n        for item in occupied_volumes:\n            if self._check_overlap_2d((x, y), (length, width), (item['x'], item['y']), (item['length'], item['width'])):\n                max_z = max(max_z, item['z'] + item['height'])\n        if max_z + height > truck_type[2]:\n            return None\n        return max_z\n\n    def _check_overlap_2d(self, item1_pos, item1_dims, item2_pos, item2_dims):\n        x1, y1 = item1_pos\n        l1, w1 = item1_dims\n        x2, y2 = item2_pos\n        l2, w2 = item2_dims\n        return (x1 < x2 + l2 and x1 + l1 > x2 and\n                y1 < y2 + w2 and y1 + w1 > y2)\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n        min_height = float('inf')\n        best_z=0\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                if height < min_height:\n                    min_height = height\n                    best_orientation = orientation_index\n\n        if best_orientation != -1:\n            separation_set = item_type.get('separation_set')\n            return -1, 0, 0, best_z, best_orientation\n\n        return -2, -1, -1, -1, -1",
          "objective": 22.85,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Selects items based on a scoring function considering volume and quantity, placing them using a bottom-left heuristic with best-fit for available space, and packing to minimize height.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Selects items based on a scoring function considering volume and quantity, placing them using a bottom-left heuristic with best-fit for available space, and packing to minimize height.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        best_score = -1\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                item = unplaced_items[i]\n                volume = item['length'] * item['width'] * item['height']\n                quantity = item['quantity']\n                score = volume * quantity\n                if score > best_score:\n                    best_score = score\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_height = float('inf')\n\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n\n            x, y, z, orientation, height = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and height < min_height:\n                min_height = height\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._create_new_truck(item_type, truck_type)\n            if best_truck_index == -2:\n                return -1, item_index, 0, 0, 0, 0\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_height = float('inf')\n        occupied_volumes = truck['occupied_volumes']\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            x, y, z = self._bottom_left_fill((length, width, height), truck_type, occupied_volumes)\n            if x != -1:\n                if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                    height_increase = z + height\n                    if height_increase < min_height:\n                        min_height = height_increase\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation, min_height\n\n    def _bottom_left_fill(self, dimensions, truck_type, occupied_volumes):\n        length, width, height = dimensions\n        best_x, best_y, best_z = -1, -1, -1\n\n        possible_positions = []\n        for z in sorted(list(set([0] + [item['z'] + item['height'] for item in occupied_volumes]))):\n            for y in sorted(list(set([0] + [item['y'] + item['width'] for item in occupied_volumes]))):\n                for x in sorted(list(set([0] + [item['x'] + item['length'] for item in occupied_volumes]))):\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                        possible_positions.append((x, y, z))\n\n        if not possible_positions:\n            return -1, -1, -1\n\n        best_x, best_y, best_z = possible_positions[0]\n        for x, y, z in possible_positions[1:]:\n            if z < best_z:\n                best_x, best_y, best_z = x, y, z\n            elif z == best_z:\n                if y < best_y:\n                    best_x, best_y, best_z = x, y, z\n                elif y == best_y:\n                    if x < best_x:\n                        best_x, best_y, best_z = x, y, z\n\n        return best_x, best_y, best_z\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n        min_height = float('inf')\n        best_z = 0\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                if height < min_height:\n                    min_height = height\n                    best_orientation = orientation_index\n\n        if best_orientation != -1:\n            separation_set = item_type.get('separation_set')\n            return -1, 0, 0, best_z, best_orientation\n        return -2, -1, -1, -1, -1",
          "objective": 22.9,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]