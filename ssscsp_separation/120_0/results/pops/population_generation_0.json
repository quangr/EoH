[
     {
          "algorithm": "This algorithm prioritizes item selection based on remaining quantity and volume, attempts to place each item with all possible orientations in existing trucks using a bottom-left-back approach, and opens a new truck only if no existing truck can accommodate the item.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm prioritizes item selection based on remaining quantity and volume, attempts to place each item with all possible orientations in existing trucks using a bottom-left-back approach, and opens a new truck only if no existing truck can accommodate the item.}\n    def __init__(self, bottom_left_back=True, epsilon=1e-6):\n        super().__init__(epsilon)\n        self.bottom_left_back = bottom_left_back\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        remaining_quantities = np.array([item['quantity'] for item in unplaced_items])\n        volumes = np.array([item['length'] * item['width'] * item['height'] for item in unplaced_items])\n        scores = remaining_quantities * volumes  # Prioritize items with high quantity and volume\n        item_index = np.argmax(scores)\n        return item_index\n\n    def _find_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index, best_x, best_y, best_z, best_orientation = -1, 0, 0, 0, 0\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n\n            x, y, z, orientation = self._find_position_in_truck(item_type, truck, truck_type)\n            if x is not None:\n                return truck_index, x, y, z, orientation\n\n        truck_index, x, y, z, orientation = self._create_new_truck(item_type, trucks_in_use, truck_type)\n        return truck_index, x, y, z, orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        occupied_volumes = truck['occupied_volumes']\n        orientations = self._get_orientations(item_type)\n\n        for orientation, (length, width, height) in orientations:\n            x, y, z = 0, 0, 0\n            if self.bottom_left_back:\n                x, y, z = self._find_bottom_left_back_position(length, width, height, truck_type, occupied_volumes)\n            \n            if x is not None:\n                return x, y, z, orientation\n\n        return None, None, None, None\n\n    def _find_bottom_left_back_position(self, length, width, height, truck_dims, occupied_volumes):\n        x, y, z = 0.0, 0.0, 0.0\n        while True:\n            valid_x = True\n            while True:\n                valid_y = True\n                while True:\n                    if self._is_valid_placement((x, y, z), (length, width, height), truck_dims, occupied_volumes):\n                        return x, y, z\n                    z_next = float('inf')\n                    for placed_item in occupied_volumes:\n                        if x < placed_item['x'] + placed_item['length'] and x + length > placed_item['x'] and y < placed_item['y'] + placed_item['width'] and y + width > placed_item['y']:\n                            z_next = min(z_next, placed_item['z'] + placed_item['height'])\n                    if z_next == float('inf'):\n                        return None, None, None\n                    z_new = z_next\n                    if z_new + self.epsilon > truck_dims[2]:\n                        break\n                    z = z_new\n                y_next = float('inf')\n                for placed_item in occupied_volumes:\n                    if x < placed_item['x'] + placed_item['length'] and x + length > placed_item['x'] and z < placed_item['z'] + placed_item['height'] and z + height > placed_item['z']:\n                        y_next = min(y_next, placed_item['y'] + placed_item['width'])\n                if y_next == float('inf'):\n                    break\n                y_new = y_next\n                if y_new + self.epsilon > truck_dims[1]:\n                    break\n                y = y_new\n            x_next = float('inf')\n            for placed_item in occupied_volumes:\n                if y < placed_item['y'] + placed_item['width'] and y + width > placed_item['y'] and z < placed_item['z'] + placed_item['height'] and z + height > placed_item['z']:\n                    x_next = min(x_next, placed_item['x'] + placed_item['length'])\n            if x_next == float('inf'):\n                break\n            x_new = x_next\n            if x_new + self.epsilon > truck_dims[0]:\n                break\n            x = x_new\n        return None, None, None\n\n    def _create_new_truck(self, item_type, trucks_in_use, truck_type):\n        truck_index = -1\n        orientations = self._get_orientations(item_type)\n        for orientation, (length, width, height) in orientations:\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                separation_set = item_type.get('separation_set')          \n                return truck_index, 0, 0, 0, orientation\n        return None, None, None, None, None\nclass AlgorithmFIX1(Algorithm):\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return int(truck_index), int(item_index), x, y, z, int(orientation)\nclass AlgorithmFIX2(AlgorithmFIX1):\n    def _find_bottom_left_back_position(self, length, width, height, truck_dims, occupied_volumes):\n       x, y, z = 0.0, 0.0, 0.0\n       max_iterations = 100  # Add a maximum iteration count to prevent infinite loops\n       iteration_count = 0\n       while True:\n           iteration_count += 1\n           if iteration_count > max_iterations:\n               return None, None, None\n           valid_x = True\n           while True:\n               valid_y = True\n               while True:\n                   if self._is_valid_placement((x, y, z), (length, width, height), truck_dims, occupied_volumes):\n                       return x, y, z\n                   z_next = float('inf')\n                   for placed_item in occupied_volumes:\n                       if x < placed_item['x'] + placed_item['length'] and x + length > placed_item['x'] and y < placed_item['y'] + placed_item['width'] and y + width > placed_item['y']:\n                           z_next = min(z_next, placed_item['z'] + placed_item['height'])\n                   if z_next == float('inf'):\n                       break\n                   z_new = z_next\n                   if z_new + height > truck_dims[2] + self.epsilon:\n                       break\n                   if abs(z_new - z) < self.epsilon:\n                        break # avoid infinite looping\n                   z = z_new\n\n               y_next = float('inf')\n               for placed_item in occupied_volumes:\n                   if x < placed_item['x'] + placed_item['length'] and x + length > placed_item['x'] and z < placed_item['z'] + placed_item['height'] and z + height > placed_item['z']:\n                       y_next = min(y_next, placed_item['y'] + placed_item['width'])\n               if y_next == float('inf'):\n                   break\n               y_new = y_next\n               if y_new + width > truck_dims[1] + self.epsilon:\n                   break\n               if abs(y_new - y) < self.epsilon:\n                   break # avoid infinite looping\n               y = y_new\n           x_next = float('inf')\n           for placed_item in occupied_volumes:\n               if y < placed_item['y'] + placed_item['width'] and y + width > placed_item['y'] and z < placed_item['z'] + placed_item['height'] and z + height > placed_item['z']:\n                   x_next = min(x_next, placed_item['x'] + placed_item['length'])\n           if x_next == float('inf'):\n               break\n           x_new = x_next\n           if x_new + length > truck_dims[0] + self.epsilon:\n               break\n           if abs(x_new - x) < self.epsilon:\n                break # avoid infinite looping\n           x = x_new\n       return None, None, None",
          "objective": 31.45,
          "other_inf": null,
          "class_name": "AlgorithmFIX2"
     },
     {
          "algorithm": "Iteratively try to place available items into existing trucks or create a new truck, prioritizing items with separation constraints and using a best-fit placement based on the minimum z-value and maximum coordinate sums after each placement attempt.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Iteratively try to place available items into existing trucks or create a new truck, prioritizing items with separation constraints and using a best-fit placement based on the minimum z-value and maximum coordinate sums after each placement attempt.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n\n        for item_index in range(len(unplaced_items)):\n            if unplaced_items[item_index]['quantity'] > 0:\n                best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation = self._evaluate_trucks(unplaced_items, trucks_in_use, truck_type, item_index)\n                if best_truck_index != -1:\n                    return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n        \n        if len(unplaced_items) > 0:\n            for item_index in range(len(unplaced_items)):\n                if unplaced_items[item_index]['quantity'] > 0:\n                    separation_set = unplaced_items[item_index].get('separation_set')\n                    if separation_set is None:\n                        best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation = self._evaluate_trucks(unplaced_items, trucks_in_use, truck_type, item_index)\n                        if best_truck_index != -1:\n                            return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n        \n        item_index = -1\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                 item_index = i\n                 break\n        if item_index != -1:\n            orientation, dims = self._get_best_orientation_for_new_truck(unplaced_items[item_index], truck_type)\n            best_truck_index = -1\n            best_item_index = item_index\n            best_x = 0\n            best_y = 0\n            best_z = 0\n            best_orientation = orientation\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _get_best_orientation_for_new_truck(self, item_type, truck_type):\n        orientations = self._get_orientations(item_type)\n        best_orientation = 0\n        min_volume = float('inf')\n        for i, (orientation_index, (length, width, height)) in enumerate(orientations):\n            volume = length * width * height\n            if volume < min_volume and length <= truck_type[0] and width <= truck_type[1] and height <= truck_type[2]:\n                min_volume = volume\n                best_orientation = orientation_index\n        return best_orientation, orientations[best_orientation][1]\n    \n    def _evaluate_trucks(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n\n        item = unplaced_items[item_index]\n        separation_set = item.get('separation_set')\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if separation_set is not None and truck.get('separation_set') is not None and truck.get('separation_set') != separation_set:\n                continue\n\n            best_x, best_y, best_z, best_orientation = self._find_position_in_truck(item, truck, truck_type)\n            if best_x != -1:\n                return truck_index, item_index, best_x, best_y, best_z, best_orientation\n        if separation_set is not None:\n            best_x, best_y, best_z, best_orientation = self._find_position_in_new_truck(item, truck_type)\n            if best_x != -1:\n                return -1, item_index, best_x, best_y, best_z, best_orientation\n        return -1, item_index, -1, -1, -1, -1\n\n    def _find_position_in_new_truck(self, item, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_z_value = float('inf')\n        best_coordinate_sum = float('-inf')\n        for orientation_index, (length, width, height) in self._get_orientations(item):\n\n            if length <= truck_type[0] and width <= truck_type[1] and height <= truck_type[2]:\n                x, y, z = 0, 0, 0\n                \n                if self._is_valid_placement((x, y, z), (length, width, height), truck_type, []):\n                    if z < best_z_value:\n                            best_z_value = z\n                            best_coordinate_sum = x + y\n                            best_x = x\n                            best_y = y\n                            best_z = z\n                            best_orientation = orientation_index\n                    elif z == best_z_value and x + y > best_coordinate_sum:\n                        best_coordinate_sum = x + y\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n        return best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_z_value = float('inf')\n        best_coordinate_sum = float('-inf')\n        occupied_volumes = truck['occupied_volumes']\n\n        for orientation_index, (length, width, height) in self._get_orientations(item):\n            x, y, z = 0, 0, 0\n            while z < truck_type[2]:\n                while y < truck_type[1]:\n                    while x < truck_type[0]:\n                        if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                            if z < best_z_value:\n                                best_z_value = z\n                                best_coordinate_sum = x + y\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation_index\n                            elif z == best_z_value and x + y > best_coordinate_sum:\n                                best_coordinate_sum = x + y\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation_index\n                        x += 1\n                    x = 0\n                    y += 1\n                x, y = 0, 0\n                z += 1\n            x, y, z = 0, 0, 0\n        return best_x, best_y, best_z, best_orientation\nclass AlgorithmFIX1(Algorithm):\n    def _find_position_in_truck(self, item, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        best_z_value = float('inf')\n        best_coordinate_sum = float('-inf')\n        occupied_volumes = truck['occupied_volumes']\n\n        for orientation_index, (length, width, height) in self._get_orientations(item):\n            if length > truck_type[0] or width > truck_type[1] or height > truck_type[2]:\n                continue\n\n            x, y, z = 0, 0, 0\n            max_iterations = 100\n            iteration = 0\n\n            while z + height <= truck_type[2] and iteration < max_iterations:\n                y = 0\n                while y + width <= truck_type[1] and iteration < max_iterations:\n                    x = 0\n                    while x + length <= truck_type[0] and iteration < max_iterations:\n                        if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                            if z < best_z_value:\n                                best_z_value = z\n                                best_coordinate_sum = x + y\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation_index\n                            elif z == best_z_value and x + y > best_coordinate_sum:\n                                best_coordinate_sum = x + y\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation_index\n\n                        x += max(1, int(length/2)) \n                        iteration += 1                    \n                    x = 0\n                    y += max(1, int(width/2))\n                    iteration += 1\n                x, y = 0, 0\n                z += max(1, int(height/2))\n                iteration += 1\n            x, y, z = 0, 0, 0\n        return best_x, best_y, best_z, best_orientation",
          "objective": 31.9,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     },
     {
          "algorithm": "The algorithm iterates through unplaced items, their orientations, and potential positions within trucks, selecting a placement based on a first-fit decreasing height strategy.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {The algorithm iterates through unplaced items, their orientations, and potential positions within trucks, selecting a placement based on a first-fit decreasing height strategy.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        truck_index, item_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                for truck_index, truck in enumerate(trucks_in_use):\n                    if (item_type['separation_set'] is None or truck['separation_set'] is None or\n                        item_type['separation_set'] != truck['separation_set']):\n                        x, y, z, orientation = self._find_position_for_item(item_type, truck, truck_type)\n                        if x != -1:\n                            return truck_index, item_index, x, y, z, orientation\n\n                x, y, z, orientation = self._find_position_for_item(item_type, None, truck_type)\n                if x != -1:\n                    return -1, item_index, x, y, z, orientation\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_for_item(self, item_type, truck, truck_type):\n        container_dims = truck_type\n        occupied_volumes = truck['occupied_volumes'] if truck else []\n        separation_set = truck['separation_set'] if truck else None\n\n        for orientation_index, (orientation, dims) in enumerate(self._get_orientations(item_type)):\n            length, width, height = dims\n            \n            positions = self._get_potential_positions(occupied_volumes, container_dims) if occupied_volumes else [(0.0, 0.0, 0.0)]\n\n            for x, y, z in positions:\n                if self._is_valid_placement((x, y, z), (length, width, height), container_dims, occupied_volumes):\n                    return x, y, z, orientation_index\n        return -1, -1, -1, -1\n\n    def _get_potential_positions(self, occupied_volumes, container_dims):\n        positions = []\n        for item in occupied_volumes:\n            x, y, z = item['x'], item['y'], item['z']\n            l, w, h = item['length'], item['width'], item['height']\n            positions.append((x + l, y, z))\n            positions.append((x, y + w, z))\n            positions.append((x, y, z + h))\n\n        positions.append((0.0, 0.0, 0.0))\n        \n        unique_positions = []\n        for x, y, z in positions:\n            is_duplicate = False\n            for ux, uy, uz in unique_positions:\n                if abs(x-ux) < self.epsilon and abs(y-uy) < self.epsilon and abs(z-uz) < self.epsilon:\n                    is_duplicate = True\n                    break\n            if not is_duplicate:\n                unique_positions.append((x,y,z))\n        return unique_positions\nclass AlgorithmFIX1(Algorithm):\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type):\n        best_truck_index = -1\n        best_item_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n\n        for item_index, item_type in enumerate(unplaced_items):\n            if item_type['quantity'] > 0:\n                for truck_index, truck in enumerate(trucks_in_use):\n                    # Correct separation constraint check: Ensure item_type can be added to the truck.\n                    if (item_type['separation_set'] is None or truck['separation_set'] is None or\n                        item_type['separation_set'] != truck['separation_set']):\n                        \n                        can_place = True\n                        if truck['separation_set'] is not None and item_type['separation_set'] is not None:\n                            can_place = truck['separation_set'] == item_type['separation_set']\n                        elif truck['separation_set'] is not None and item_type['separation_set'] is None:\n                            can_place = True\n                        elif truck['separation_set'] is None and item_type['separation_set'] is not None:\n                            truck['separation_set'] = item_type['separation_set']\n                            \n                        if can_place:\n                            x, y, z, orientation = self._find_position_for_item(item_type, truck, truck_type)\n                            if x != -1:\n                                return truck_index, item_index, x, y, z, orientation\n\n                # Find position in a new truck\n                x, y, z, orientation = self._find_position_for_item(item_type, None, truck_type)\n                if x != -1:\n                    return -1, item_index, x, y, z, orientation\n        return best_truck_index, best_item_index, best_x, best_y, best_z, best_orientation",
          "objective": 74.55,
          "other_inf": null,
          "class_name": "AlgorithmFIX1"
     }
]