[
     {
          "algorithm": "Select the item with largest surface area, place it using a skyline heuristic to find the lowest-z position, and prioritize filling lower truck indices and minimizing wasted space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select the item with largest surface area, place it using a skyline heuristic to find the lowest-z position, and prioritize filling lower truck indices and minimizing wasted space.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_area = -1\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                area = 2 * (unplaced_items[i]['length'] * unplaced_items[i]['width'] +\n                            unplaced_items[i]['length'] * unplaced_items[i]['height'] +\n                            unplaced_items[i]['width'] * unplaced_items[i]['height'])\n                if area > max_area:\n                    max_area = area\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n            x, y, z, orientation, waste = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and waste < min_waste:\n                min_waste = waste\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation, waste = self._create_new_truck(item_type, truck_type)\n            if best_truck_index == -2:\n              return -1, item_index, 0, 0, 0, 0\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n        \n        occupied_volumes = truck['occupied_volumes']\n        \n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            for x in np.arange(0, truck_type[0] - length + self.epsilon, 1):\n                for y in np.arange(0, truck_type[1] - width + self.epsilon, 1):\n                    z = self._find_lowest_valid_z(x, y, length, width, height, truck_type, occupied_volumes)\n                    if z is not None:\n                        if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                            waste = self._evaluate_placement(x, y, z, length, width, height, truck_type)\n                            if waste < min_waste:\n                                min_waste = waste\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation_index\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _find_lowest_valid_z(self, x, y, length, width, height, truck_type, occupied_volumes):\n        z = 0\n        while z + height <= truck_type[2]:\n            is_valid = True\n            for placed_item in occupied_volumes:\n                if self._check_overlap_3d((x, y, z), (length, width, height), (placed_item['x'], placed_item['y'], placed_item['z']), (placed_item['length'], placed_item['width'], placed_item['height'])):\n                    is_valid = False\n                    z = placed_item['z'] + placed_item['height']\n                    break\n            if is_valid:\n                return z\n        return None\n    \n    def _evaluate_placement(self, x, y, z, length, width, height, truck_type):\n        return (truck_type[0] - (x + length)) * (truck_type[1] - (y + width)) * (truck_type[2] - (z + height))\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n        min_waste = float('inf')\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                waste = (truck_type[0] - length) * (truck_type[1] - width) * (truck_type[2] - height)\n                if waste < min_waste:\n                    min_waste = waste\n                    best_orientation = orientation_index\n                    \n        if best_orientation != -1:\n          separation_set = item_type.get('separation_set')\n          return -1, 0, 0, 0, best_orientation, min_waste\n        return -2, -1, -1, -1, -1, float('inf')",
          "objective": 24.45,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Select the item with the best volume utilization ratio relative to container size and place using the lowest-z heuristic with minimum wasted space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select the item with the best volume utilization ratio relative to container size and place using the lowest-z heuristic with minimum wasted space.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items, truck_type)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items, truck_type):\n        best_item_index = -1\n        best_utilization_ratio = -1\n\n        truck_volume = truck_type[0] * truck_type[1] * truck_type[2]\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                item_volume = unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height']\n                utilization_ratio = item_volume / truck_volume\n                if utilization_ratio > best_utilization_ratio:\n                    best_utilization_ratio = utilization_ratio\n                    best_item_index = i\n\n        if best_item_index == -1:\n            for i in range(len(unplaced_items)):\n                if unplaced_items[i]['quantity'] > 0:\n                    return i\n\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n            x, y, z, orientation, waste = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and waste < min_waste:\n                min_waste = waste\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._create_new_truck(item_type, truck_type)\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n\n        occupied_volumes = truck['occupied_volumes']\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            for x in np.arange(0, truck_type[0] - length + self.epsilon, 1):\n                for y in np.arange(0, truck_type[1] - width + self.epsilon, 1):\n                    z = self._find_lowest_valid_z(x, y, length, width, height, truck_type, occupied_volumes)\n                    if z is not None:\n                        if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                            waste = self._evaluate_placement(x, y, z, length, width, height, truck_type, occupied_volumes)\n                            if waste < min_waste:\n                                min_waste = waste\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _find_lowest_valid_z(self, x, y, length, width, height, truck_type, occupied_volumes):\n        z = 0\n        while z + height <= truck_type[2]:\n            is_valid = True\n            for placed_item in occupied_volumes:\n                if self._check_overlap_3d((x, y, z), (length, width, height), (placed_item['x'], placed_item['y'], placed_item['z']), (placed_item['length'], placed_item['width'], placed_item['height'])):\n                    is_valid = False\n                    z = placed_item['z'] + placed_item['height']\n                    break\n            if is_valid:\n                return z\n        return None\n\n    def _evaluate_placement(self, x, y, z, length, width, height, truck_type, occupied_volumes):\n        total_volume = truck_type[0] * truck_type[1] * truck_type[2]\n        occupied_volume = 0\n        for item in occupied_volumes:\n            occupied_volume += item['length'] * item['width'] * item['height']\n\n        new_item_volume = length * width * height\n\n        return total_volume - (occupied_volume + new_item_volume) + z * 0.0001\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                return -1, 0, 0, 0, orientation_index\n\n        return -1, -1, -1, -1, -1",
          "objective": 25.2,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "This algorithm selects items based on a volume-to-area ratio and places them prioritizing the best fit based on minimal remaining space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {This algorithm selects items based on a volume-to-area ratio and places them prioritizing the best fit based on minimal remaining space.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        if item_index == -1:\n            return -1, -1, 0, 0, 0, 0\n\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_score = -1\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                volume = unplaced_items[i]['length'] * unplaced_items[i]['width'] * unplaced_items[i]['height']\n                area = unplaced_items[i]['length'] * unplaced_items[i]['width']\n                score = volume / (area + self.epsilon)  \n                if score > max_score:\n                    max_score = score\n                    best_item_index = i\n\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n            x, y, z, orientation, waste = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and waste < min_waste:\n                min_waste = waste\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._create_new_truck(item_type, truck_type, trucks_in_use)\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n\n        occupied_volumes = truck['occupied_volumes']\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            x, y, z = self._find_bottom_left_position(length, width, height, truck_type, occupied_volumes)\n            if x is not None:\n                if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                    waste = self._calculate_waste(x, y, z, length, width, height, truck_type)\n                    if waste < min_waste:\n                        min_waste = waste\n                        best_x = x\n                        best_y = y\n                        best_z = z\n                        best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _find_bottom_left_position(self, length, width, height, truck_type, occupied_volumes):\n        possible_positions = []\n        for x in np.arange(0, truck_type[0] - length + self.epsilon, 1):\n            for y in np.arange(0, truck_type[1] - width + self.epsilon, 1):\n                z = self._find_lowest_valid_z(x, y, length, width, height, truck_type, occupied_volumes)\n                if z is not None:\n                    possible_positions.append((x, y, z))\n\n        if not possible_positions:\n            return None, None, None\n\n        best_x, best_y, best_z = min(possible_positions, key=lambda pos: (pos[0], pos[1], pos[2]))\n        return best_x, best_y, best_z\n\n    def _find_lowest_valid_z(self, x, y, length, width, height, truck_type, occupied_volumes):\n        z = 0\n        while z + height <= truck_type[2] + self.epsilon:\n            is_valid = True\n            for placed_item in occupied_volumes:\n                if self._check_overlap_3d((x, y, z), (length, width, height), (placed_item['x'], placed_item['y'], placed_item['z']), (placed_item['length'], placed_item['width'], placed_item['height'])):\n                    is_valid = False\n                    z = placed_item['z'] + placed_item['height']\n                    break\n            if is_valid:\n                return z\n            \n        return None\n\n    def _calculate_waste(self, x, y, z, length, width, height, truck_type):\n        return (truck_type[0] - (x + length)) + (truck_type[1] - (y + width)) + (truck_type[2] - (z + height))\n\n    def _create_new_truck(self, item_type, truck_type, trucks_in_use):\n        best_orientation = -1\n        \n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                separation_set = item_type.get('separation_set')\n                if separation_set is not None:\n                    trucks_in_use.append({'separation_set': separation_set, 'occupied_volumes': []})\n                else:\n                    trucks_in_use.append({'occupied_volumes': []})\n\n                return -1, 0, 0, 0, orientation_index\n\n        return -1, -1, -1, -1, -1",
          "objective": 25.3,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Select the item with the largest remaining quantity and place it using a best-fit heuristic based on minimizing wasted space, prioritizing lower z placement.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Select the item with the largest remaining quantity and place it using a best-fit heuristic based on minimizing wasted space, prioritizing lower z placement.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_quantity = -1\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                if unplaced_items[i]['quantity'] > max_quantity:\n                    max_quantity = unplaced_items[i]['quantity']\n                    best_item_index = i\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n            x, y, z, orientation, waste = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and waste < min_waste:\n                min_waste = waste\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n        \n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._create_new_truck(item_type, truck_type)\n        \n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_waste = float('inf')\n        \n        occupied_volumes = truck['occupied_volumes']\n        \n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            for x in np.arange(0, truck_type[0] - length + self.epsilon, 1):\n                for y in np.arange(0, truck_type[1] - width + self.epsilon, 1):\n                    z = self._find_lowest_valid_z(x, y, length, width, height, truck_type, occupied_volumes)\n                    if z is not None:\n                        if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                            waste = self._evaluate_placement(x, y, z, length, width, height, truck_type, occupied_volumes)\n                            if waste < min_waste:\n                                min_waste = waste\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation_index\n        return best_x, best_y, best_z, best_orientation, min_waste\n\n    def _find_lowest_valid_z(self, x, y, length, width, height, truck_type, occupied_volumes):\n        z = 0\n        while z + height <= truck_type[2]:\n            is_valid = True\n            for placed_item in occupied_volumes:\n                if self._check_overlap_3d((x, y, z), (length, width, height), (placed_item['x'], placed_item['y'], placed_item['z']), (placed_item['length'], placed_item['width'], placed_item['height'])):\n                    is_valid = False\n                    z = placed_item['z'] + placed_item['height']\n                    break\n            if is_valid:\n                return z\n        return None\n\n    def _evaluate_placement(self, x, y, z, length, width, height, truck_type, occupied_volumes):\n        total_volume = truck_type[0] * truck_type[1] * truck_type[2]\n        occupied_volume = 0\n        for item in occupied_volumes:\n            occupied_volume += item['length'] * item['width'] * item['height']\n        \n        new_item_volume = length * width * height\n        \n        return total_volume - (occupied_volume + new_item_volume) + z * 0.0001\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                best_orientation = orientation_index\n                return -1, 0, 0, 0, best_orientation\n        return -1, -1, -1, -1, -1",
          "objective": 25.4,
          "other_inf": null,
          "class_name": "Algorithm"
     },
     {
          "algorithm": "Prioritize placing items with larger surface area on the bottom, then select the best placement based on minimizing remaining space.",
          "code": "import numpy as np\n\nclass Algorithm(BaseAlgorithm):\n    # {Prioritize placing items with larger surface area on the bottom, then select the best placement based on minimizing remaining space.}\n    def __init__(self, epsilon=1e-6):\n        super().__init__(epsilon)\n\n    def place_item(self, unplaced_items, trucks_in_use, truck_type):\n        item_index = self._select_item(unplaced_items)\n        truck_index, x, y, z, orientation = self._find_best_placement(unplaced_items, trucks_in_use, truck_type, item_index)\n        return truck_index, item_index, x, y, z, orientation\n\n    def _select_item(self, unplaced_items):\n        best_item_index = -1\n        max_area = -1\n\n        for i in range(len(unplaced_items)):\n            if unplaced_items[i]['quantity'] > 0:\n                area = unplaced_items[i]['length'] * unplaced_items[i]['width']\n                if area > max_area:\n                    max_area = area\n                    best_item_index = i\n\n        if best_item_index == -1:\n            for i in range(len(unplaced_items)):\n                if unplaced_items[i]['quantity'] > 0:\n                    return i\n        return best_item_index\n\n    def _find_best_placement(self, unplaced_items, trucks_in_use, truck_type, item_index):\n        best_truck_index = -1\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_remaining_space = float('inf')\n\n        item_type = unplaced_items[item_index]\n\n        for truck_index, truck in enumerate(trucks_in_use):\n            if item_type.get('separation_set') is not None and truck.get('separation_set') is not None and item_type['separation_set'] != truck['separation_set']:\n                continue\n            x, y, z, orientation, remaining_space = self._find_position_in_truck(item_type, truck, truck_type)\n            if x != -1 and remaining_space < min_remaining_space:\n                min_remaining_space = remaining_space\n                best_truck_index = truck_index\n                best_x = x\n                best_y = y\n                best_z = z\n                best_orientation = orientation\n\n        if best_truck_index == -1:\n            best_truck_index, best_x, best_y, best_z, best_orientation = self._create_new_truck(item_type, truck_type)\n\n        return best_truck_index, best_x, best_y, best_z, best_orientation\n\n    def _find_position_in_truck(self, item_type, truck, truck_type):\n        best_x = -1\n        best_y = -1\n        best_z = -1\n        best_orientation = -1\n        min_remaining_space = float('inf')\n\n        occupied_volumes = truck['occupied_volumes']\n\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            for x in np.arange(0, truck_type[0] - length + self.epsilon, 1):\n                for y in np.arange(0, truck_type[1] - width + self.epsilon, 1):\n                    z = self._find_lowest_valid_z(x, y, length, width, height, truck_type, occupied_volumes)\n                    if z is not None:\n                        if self._is_valid_placement((x, y, z), (length, width, height), truck_type, occupied_volumes):\n                            remaining_space = self._calculate_remaining_space(truck_type, occupied_volumes, (x, y, z), (length, width, height))\n                            if remaining_space < min_remaining_space:\n                                min_remaining_space = remaining_space\n                                best_x = x\n                                best_y = y\n                                best_z = z\n                                best_orientation = orientation_index\n\n        return best_x, best_y, best_z, best_orientation, min_remaining_space\n\n    def _find_lowest_valid_z(self, x, y, length, width, height, truck_type, occupied_volumes):\n        z = 0\n        while z + height <= truck_type[2]:\n            is_valid = True\n            for placed_item in occupied_volumes:\n                if self._check_overlap_3d((x, y, z), (length, width, height), (placed_item['x'], placed_item['y'], placed_item['z']), (placed_item['length'], placed_item['width'], placed_item['height'])):\n                    is_valid = False\n                    z = placed_item['z'] + placed_item['height']\n                    break\n            if is_valid:\n                return z\n        return None\n\n    def _calculate_remaining_space(self, truck_type, occupied_volumes, new_item_pos, new_item_dims):\n        total_volume = truck_type[0] * truck_type[1] * truck_type[2]\n        occupied_volume = 0\n        for item in occupied_volumes:\n            occupied_volume += item['length'] * item['width'] * item['height']\n        occupied_volume += new_item_dims[0] * new_item_dims[1] * new_item_dims[2]\n\n        return total_volume - occupied_volume\n\n    def _create_new_truck(self, item_type, truck_type):\n        best_orientation = -1\n        min_space = float('inf')\n        chosen_length = -1\n        chosen_width = -1\n        chosen_height = -1\n        for orientation_index, (length, width, height) in self._get_orientations(item_type):\n            if self._is_within_container_bounds((0, 0, 0), (length, width, height), truck_type):\n                current_space = truck_type[0] * truck_type[1] * truck_type[2] - length*width*height\n                if current_space < min_space:\n                  min_space = current_space\n                  best_orientation = orientation_index\n                  chosen_length = length\n                  chosen_width = width\n                  chosen_height = height\n\n        if best_orientation != -1:\n          return -1, 0, 0, 0, best_orientation\n        else:\n            return -1, -1, -1, -1, -1",
          "objective": 25.6,
          "other_inf": null,
          "class_name": "Algorithm"
     }
]